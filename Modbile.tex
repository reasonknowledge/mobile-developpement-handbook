% filepath: d:\ToZero\books\Mobile.tex
\documentclass{book}
\usepackage{amssymb}
% ====================================================================
% 1. PACKAGES DE BASE (ENCODAGE ET LANGUE)
% ====================================================================
\usepackage{lmodern}        % Police moderne
\usepackage[utf8]{inputenc} % Gestion des caractères accentués
\usepackage[T1]{fontenc}    % Encodage des polices
\usepackage[T1]{fontenc}    % Encodage des polices
\usepackage[french]{babel}  % Règles typographiques françaises
\usepackage{charter}
\usepackage{listingsutf8}
\lstset{inputencoding = utf8/latin1}
% ====================================================================
% 2. PACKAGES DE MISE EN PAGE ET GÉOMÉTRIE
% ====================================================================
\usepackage{geometry}
\geometry{a4paper, margin=1.5cm}
\usepackage{changepage}
% \usepackage{fullpage}       % Plus d'espace sur la page

% ====================================================================
% 3. PACKAGES COULEURS (AVANT TOUT CE QUI UTILISE LES COULEURS)
% ====================================================================
\usepackage[table]{xcolor}  % Package xcolor avec option 'table'
\usepackage{longtable}

% Couleurs personnalisées
\definecolor{navy}{RGB}{0, 0, 128}
\definecolor{titlecolor}{HTML}{0ea5e9}
\definecolor{customred}{HTML}{cb6263}
\definecolor{darkerblue}{RGB}{190, 190, 220}
\definecolor{lightgraybg}{HTML}{F6F8FC}
\definecolor{gray600}{HTML}{4B5563}
\definecolor{gray800}{HTML}{1F2937}
\definecolor{cellbackground}{RGB}{240, 240, 240}
\definecolor{cellborder}{RGB}{200, 200, 200}
\definecolor{green50}{HTML}{F0FDF4}
\definecolor{teal100}{HTML}{CCFBF1}
\definecolor{blue100}{HTML}{DBEAFE}
\definecolor{blue200}{HTML}{BFDBFE}
\definecolor{blue300}{HTML}{619DF5}
\definecolor{blue400}{HTML}{22D3EE}
\definecolor{blue500}{HTML}{1F4EDF}
\definecolor{greencustom}{HTML}{008001}
\definecolor{tailwindgray600}{RGB}{71,85,105}
\definecolor{myred}{RGB}{255, 99, 71}
\colorlet{mytransparentblue}{lightgraybg}
\definecolor{lightgray}{rgb}{0.9,0.9,0.9}
\definecolor{darkgray}{rgb}{0.3,0.3,0.3}


% ====================================================================
% 4. PACKAGES GRAPHIQUES ET IMAGES
% ====================================================================
\usepackage{graphicx}
\usepackage{float}
\usepackage{subcaption}
\usepackage{rotating}

% ====================================================================
% 5. PACKAGES TABLEAUX ET LISTES
% ====================================================================
\usepackage{array}
\usepackage{longtable}
\usepackage{makecell}
\usepackage{enumitem}
\setlist[itemize]{label={\textbullet}}
\usepackage{ragged2e}

% ====================================================================
% 6. PACKAGES BOÎTES ET ENVIRONNEMENTS
% ====================================================================
\usepackage{tcolorbox}
\tcbuselibrary{listings, breakable}
\usepackage{mdframed}
\usepackage{fancyvrb}

% ====================================================================
% 7. PACKAGES CODE ET LISTINGS
% ====================================================================
\usepackage{listings}
\usepackage{textcomp}
% ====================================================================
% 8. PACKAGES DIVERS
% ====================================================================
\usepackage{dirtree}
\usepackage{stackengine}
\usepackage{scalerel}

% ====================================================================
% 9. HYPERREF (TOUJOURS EN DERNIER)
% ====================================================================
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=black,
    filecolor=magenta,
    urlcolor=cyan
}

% ====================================================================
% 10. CONFIGURATIONS PERSONNALISÉES
% ====================================================================

% Configuration tcolorbox
\tcbset{
    myboxstyle/.style={
        colback=gray!10,
        colframe=gray!10,
        boxrule=0pt,
        arc=0.5mm,
        left=2pt,
        right=2pt,
        top=1pt,
        bottom=1pt,
        boxsep=2pt,
        hbox 
    }
}

% Configuration listings de base
\lstset{
    basicstyle=\ttfamily\small,
    keywordstyle=\color{greencustom},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{customred},
    showstringspaces=false,
    breaklines=true,
    numberstyle=\tiny,
}

% Définition du langage JavaScript
\lstdefinelanguage{JavaScript}{
    keywords={typeof,const ,export,default , new, true, false, catch, function, return, null,import, catch, switch, var, if, in, while, do, else, case, break},
    keywordstyle=\color{greencustom}\bfseries,
    ndkeywords={class, export, boolean, throw, implements, import, this},
    ndkeywordstyle=\color{gray600}\bfseries,
    identifierstyle=\color{black},
    sensitive=false,
    comment=[l]{//},
    morecomment=[s]{/*}{*/},
    commentstyle=\color{gray}\itshape,
    stringstyle=\color{customred},
    morestring=[b]',
    morestring=[b]",
    numbers=left,
    numberstyle=\tiny\color{blue400},
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true
}

% Environnement tcolorbox pour JavaScript
\newtcblisting{jscode}[1][]{
    size=fbox,
    boxrule=1pt,
    colback=mytransparentblue,
    colframe=blue100,
    listing only,
    breakable, % Allow the box to break across pages
    listing options={
        language=JavaScript,
        basicstyle=\ttfamily\small,
        keywordstyle=\color{gray}\bfseries,
        commentstyle=\color{gray}\itshape,
        stringstyle=\color{gray},
        showstringspaces=false,
        breaklines=true,
        numbers=left,
        numberstyle=\tiny\color{blue400},
        numbersep=10pt,
        xleftmargin=5pt,
        framexleftmargin=15pt
    },
    left=10pt,
    right=10pt,
    top=5pt,
    bottom=5pt,
    arc=1pt,
    boxrule=1pt,
    #1
}

% Commande danger
\newcommand\dangersign[1][2ex]{%
  \renewcommand\stacktype{L}%
  \scaleto{\stackon[1.3pt]{\color{red}$\triangle$}{\tiny\bfseries !}}{#1}%
}

% Environnement pour les conseils
\newmdenv[
  backgroundcolor=lightgray,
  linecolor=blue100,
  linewidth=2pt,
  topline=false,
  bottomline=false,
  rightline=false,
  leftmargin=1cm,
  rightmargin=1cm,
  innerleftmargin=10pt,
  innerrightmargin=10pt,
  innertopmargin=10pt,
  innerbottommargin=10pt
]{tipbox}

\title{Guide du Developpement Mobile Crossplateform}

\author{Auteur}
\begin{document}

\begin{titlepage}
    \centering
    \vspace*{1cm} % Espace vertical

    % Insérer l'image de la page de couverture
    \includegraphics[width=0.5\textwidth]{Mobiledev.png}\par
    \vspace{1cm} % Espace vertical

    % Titre du document
    {\Huge\bfseries Guide Developpement Mobile Crossplateform\par}
    \vspace{1cm}

    \vspace{2cm}

    \begin{center}
      \textbf{Par}
    \end{center}

    % Auteur
    {\Large\bfseries NGOUBOUNKOU Franck Hervé\par}
    \vspace{1cm}

    % Date
    % {\Large Date: \today\par}

\end{titlepage}


\maketitle


\tableofcontents

% \section*{Introduction}
% Bienvenue dans ce document LaTeX. Ce document montre quelques fonctionnalités de base de LaTeX.

\chapter{ React Native}
\addtocontents{toc}{\vspace{1em}} % Ajoute un espace après le titre du chapitre dans la table des matières
\section{Qu'est-ce que React Native ?}
React Native est un framework open-source créé par Facebook pour développer des applications mobiles multiplateformes.
Il permet aux développeurs d'utiliser JavaScript et React pour créer des applications natives pour iOS et Android à partir d'une seule base de code.
Contrairement aux applications web hybrides, React Native génère des composants natifs, offrant des performances proches des applications développées de manière native.

\begin{itemize}
    \item Langage : Utilise JavaScript et la syntaxe de React.
    \item Multiplateforme : Une seule base de code pour iOS et Android.
    \item Performance : Exploite les API natives pour des rendus rapides.
    \item Écosystème : Large communauté, nombreuses bibliothèques et outils simple Expo pour le développement.
    \item Exemples d'utilisation : Applications comme Facebook, Instagram, Airbnb et Uber Eats utilisent React Native.
    \item \href{https://reactnative.dev/}{https://reactnative.dev/}
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.12\textwidth]{react-native.png}
    \caption{Logo de React Native}
    \label{fig:react-native-logo}
\end{figure}



\subsection{Le framework Expo}
Le framework Expo est un ensemble d'outils et de services open-source qui simplifie le développement d'applications mobiles avec React Native.
Il permet aux développeurs de créer, tester et déployer des applications iOS et Android plus rapidement en fournissant une couche d'abstraction et des outils prêts à l'emploi.
\begin{itemize}
    \item \textbf{Simplification du développement} : Expo fournit un kit de développement (SDK) avec des API préconfigurées pour des fonctionnalités comme la caméra, les notifications push, ou la géolocalisation, sans configuration native complexe.
    \item \textbf{Multiplateforme} : Permet de développer pour iOS et Android avec une seule base de code React Native.
    \item \textbf{Expo Go} : Une application mobile pour tester rapidement les applications en développement sur des appareils réels sans compilation native.
    \item \textbf{Écosystème riche} : Inclut des outils comme Expo CLI pour gérer les projets et des services pour le déploiement (par exemple, EAS pour la compilation et la soumission aux stores).
    \item \textbf{Communauté et documentation} : Large communauté et documentation complète, accessible via 
    \href{https://expo.dev/}{https://expo.dev/}.
    \item Exemple d'insertion d'une image Expo :
    \begin{figure}[h]
        \centering
        \includegraphics[width=0.06\textwidth]{expo.png} 
        \caption{Logo d'Expo}
        \label{fig:expo-logo}
    \end{figure}
\end{itemize}

\subsection{React Native vs Expo }
Expo est ce qu'est Spring Boot pour Spring en Java. En effet, l'objectif étant de se passer des configurations natives et de la complexité de la compilation native.



\subsection{Comment on cree un projet en react }
L'installation d'un projet React Native peut se faire de deux manières principales : avec Expo ou sans Expo (React Native CLI).
Voici les étapes pour chaque méthode :

\subsubsection{React Native CLI}


C'est la pratique la moins recommandée, la moins utilisée et la plus complexe de nos jours depuis l'arrivée d'Expo.
Elle est réservée aux experts et aux cas d'utilisation spécifiques nécessitant un contrôle total sur les configurations natives.
\begin{enumerate}
  \item Assurez-vous d'avoir Node.js installé sur votre machine. \newline
  \textcolor{gray}{node -v}  \newline
  \item Désinstallez React Native CLI installé globalement \newline
  \textcolor{gray} {npm uninstall -g react-native-cli @react-native-community/cli}  \newline
  \item Creer votre projet React Native \newline
  \textcolor{gray}{npx react-native init MyApp}  \newline
  \item Archicteure du projet \newline
\end{enumerate}

\dirtree{%
.1 \textcolor{gray}{AWESOMEPROJECT/}.
.2 \textcolor{gray}{\_\_tests\_\_/} \DTcomment{\textcolor{gray}{Dossier pour les tests}}.
.3 \textcolor{gray}{bundle/}.
.2 \textcolor{gray}{android/} \DTcomment{\textcolor{gray}{Fichiers spécifiques à Android}}.
.2 \textcolor{gray}{ios/} \DTcomment{\textcolor{gray}{Fichiers spécifiques à iOS}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{.eslintrcjs} \DTcomment{\textcolor{gray}{Configuration pour ESLint}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichiers et dossiers ignorés par Git}}.
.2 \textcolor{gray}{.prettierrc.js} \DTcomment{\textcolor{gray}{Configuration pour Prettier}}.
.2 \textcolor{gray}{.watchmanconfig} \DTcomment{\textcolor{gray}{Configuration pour Watchman}}.
.2 \textcolor{gray}{app.json} \DTcomment{\textcolor{gray}{Configuration de l'application React Native}}.
.2 \textcolor{gray}{App.tsx} \DTcomment{\textcolor{gray}{Point d'entrée principal de l'application}}.
.2 \textcolor{gray}{babel.config.js} \DTcomment{\textcolor{gray}{Configuration pour Babel}}.
.2 \textcolor{gray}{Gemfile} \DTcomment{\textcolor{gray}{Fichier de configuration pour Ruby Gems}}.
.2 \textcolor{gray}{index.js} \DTcomment{\textcolor{gray}{Point d'entrée JavaScript de l'application}}.
.2 \textcolor{gray}{jest.config.js} \DTcomment{\textcolor{gray}{Configuration pour Jest}}.
.2 \textcolor{gray}{metro.config.js} \DTcomment{\textcolor{gray}{Configuration pour Metro Bundler}}.
.2 \textcolor{gray}{package-lock.json} \DTcomment{\textcolor{gray}{Fichier verrouillant les versions des dépendances}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Dépendances et scripts npm du projet}}.
.2 \textcolor{gray}{README.md} \DTcomment{\textcolor{gray}{Documentation du projet}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration pour TypeScript}}.
}

\section*{Lancer l'application sur un simulateur ou un appareil physique}
\begin{enumerate}
  \item[5.] npx react-native run-android (pour Android) 
  \begin{itemize}
    \item Rassuerer d avoir l emulateur Android lancé.
    \item sur mobile:branchez votre mobile et activez le mode developpeur dans les parametres de votre mobile.
    \item \hyperlink{https://www.youtube.com/results?search\_query=activation+mode+developpeur+android}{Activation mode developpeur sur android}
  \end{itemize}
  \item[6.] npx react-native run-ios (pour iOS)
\end{enumerate}

\subsubsection{Avec Expo}

\subsubsection{Quels sont les workflows avec Expo ?}

Il y a deux workflows principaux pour React Native avec Expo : le workflow géré (managed workflow) et le workflow non géré (bare workflow).
Un workflow (ou « flux de travail » en français) désigne une suite ordonnée d'étapes, de processus ou d'actions permettant d'accomplir une tâche ou d'atteindre un objectif défini.\newline

Un workflow Expo représente le mode d'organisation et d'exécution du processus de développement d'une application React Native avec Expo c'est-à-dire la manière dont Expo gère le cycle de vie du projet, du code JavaScript jusqu'à la compilation native.\newline

Le workflow géré utilise Expo pour simplifier le développement, tandis que le workflow non géré permet un contrôle total sur les configurations natives.

\subsubsection{React Native avec expo Workflow 1 :no managed (bare workflow)}
Étant donné que la CLI de React Native est moins recommandée, mais que le désir d'avoir toutefois un contrôle sur le code natif
subsiste et demeure, le SDK Expo permet de créer des applications React Native avec un workflow non géré (bare workflow) en y ajoutant les dossiers
\textbf{android/} et \textbf{ios/} pour les configurations natives. \newline
\textcolor{gray600}{Comment créer un projet React Native avec expo bare workflow ?} \newline
La CLI d'Expo met à disposition la commande suivante pour créer un projet React Native avec un workflow non géré (bare workflow) :
\begin{enumerate}
  \item \textcolor{gray600}{Option 1} 
  \subitem Directement avec la commande:
  \subitem \textcolor{gray600}{npx create-expo-app --template bare-minimum NativeApp}
  \subitem \textcolor{gray600}{pnpm create expo-app - -template bare-minimum NativeApp}
  \subitem \textcolor{gray600}{yarn create expo-app - -template bare-minimum NativeApp}
  \subitem \textcolor{gray600}{bun create expo-app - -template bare-minimum NativeApp}
  \item \textcolor{gray600}{Option 2}
  \subitem Si vous ne specifiez pas l option apres - -template:
  \subitem \textcolor{gray600}{npx create-expo-app - -template bare-minimum}
  \subsubitem > Default
  \subsubitem includes tools recommended for most app developers
  \subsubitem Blank
  \subsubitem Blank (TypeScript)
  \subsubitem Navigation (TypeScript)
  \subsubitem 
\end{enumerate}

suivant l'une des deux options, vous obtiendrez un projet React Native en JS avec la structure suivante :

\dirtree{%
.1 \textcolor{gray}{NativeApp/}.
.2 \textcolor{gray}{android/} \DTcomment{\textcolor{gray}{Code natif et configuration Android}}.
.2 \textcolor{gray}{ios/} \DTcomment{\textcolor{gray}{Code natif et configuration iOS}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par pnpm}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichiers et dossiers ignorés par Git}}.
.2 \textcolor{gray}{app.json} \DTcomment{\textcolor{gray}{Configuration basique d'Expo}}.
.2 \textcolor{gray}{App.js} \DTcomment{\textcolor{gray}{Composant racine JavaScript}}.
.2 \textcolor{gray}{index.js} \DTcomment{\textcolor{gray}{Point d'entrée de l'application React Native}}.
.2 \textcolor{gray}{metro.config.js} \DTcomment{\textcolor{gray}{Configuration du bundler Metro}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Métadonnées du projet et scripts pnpm}}.
.2 \textcolor{gray}{pnpm-lock.yaml} \DTcomment{\textcolor{gray}{Fichier de verrouillage des versions pnpm}}.
.2 \textcolor{gray}{README.md} \DTcomment{\textcolor{gray}{Documentation et instructions du projet}}.
}

\vspace{0.5cm}

\begin{flushleft}
  Si vous désirez utiliser TypeScript, vous serez contraint de l'installer manuellement selon votre gestionnaire de dépendances avec lequel vous avez initialisé le projet, avec ses types comme : \newline
\end{flushleft}
\begin{itemize}
  \item \textcolor{gray600}{npm install --save-dev typescript @types/react @types/react-native @types/expo} ou 
  \item \textcolor{gray600}{yarn add --dev typescript @types/react @types/react-native @types/expo} ou
  \item \textcolor{gray600}{bun add --dev typescript @types/react @types/react-native @types/expo} ou
  \item \textcolor{gray600}{pnpm install --save-dev typescript @types/react @types/react-native @types/expo}
\end{itemize}

\subsubsection{Avec Expo : Workflow 1 managed workflow}
Le workflow géré utilise Expo pour simplifier le développement, en fournissant des outils et des bibliothèques prêtes à l'emploi.

\begin{enumerate}
   \item Modèle tabs avec ... par default :
    \subitem \textcolor{gray600}{npx create-expo-app@latest}
  \item Modèle vierge avec JavaScript :
    \subitem \textcolor{gray600}{npx create-expo-app MonProjetExpoJS \hspace{0.05cm} - -template blank}
  \item Modèle vierge avec TypeScript :
    \subitem \textcolor{gray600}{npx create-expo-app MonProjetExpoTS \hspace{0.05cm} - -template blank-typescript}
  \item Dernier modèle avec configuration par défaut : routage basé sur les fichiers avec expo-router :
    \subitem \textcolor{gray600}{npx create-expo-app MonProjetExpoRouter \hspace{0.05cm} - -template tabs}
\end{enumerate}


\subsubsection{Arborescence du template - -template blank-typescript}
\dirtree{%
.1 \textcolor{gray}{MonProjetExpoTS/} \DTcomment{\textcolor{gray}{Racine du projet Expo}}.
.2 \textcolor{gray}{assets/} \DTcomment{\textcolor{gray}{Ressources statiques de l'application}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichier de gestion Git}}.
.2 \textcolor{gray}{app.json} \DTcomment{\textcolor{gray}{Configuration principale de l'application Expo}}.
.2 \textcolor{gray}{App.tsx} \DTcomment{\textcolor{gray}{Composant racine TypeScript}}.
.2 \textcolor{gray}{index.ts} \DTcomment{\textcolor{gray}{Fichier d'entrée TypeScript}}.
.2 \textcolor{gray}{package-lock.json} \DTcomment{\textcolor{gray}{Verrouillage des versions npm}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Métadonnées, scripts et dépendances du projet}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration TypeScript}}.
}

\subsubsection{Arborescence du template - -template tabs}
\dirtree{%
.1 \textcolor{gray}{MonProjetExpoRouter/} \DTcomment{\textcolor{gray}{Racine du projet Expo}}.
.2 \textcolor{gray}{.expo/} \DTcomment{\textcolor{gray}{Dossier de gestion spécifique à Expo}}.
.2 \textcolor{gray}{app/} \DTcomment{\textcolor{gray}{Dossier principal des fichiers de l'application}}.
.3 \textcolor{gray}{(tabs)/} \DTcomment{\textcolor{gray}{Dossier pour la navigation par onglets}}.
.4 \textcolor{gray}{\_layout.tsx} \DTcomment{\textcolor{gray}{Composant de mise en page TypeScript}}.
.4 \textcolor{gray}{+html.tsx} \DTcomment{\textcolor{gray}{Composant TypeScript pour HTML}}.
.4 \textcolor{gray}{+not-found.tsx} \DTcomment{\textcolor{gray}{Composant pour la page 404}}.
.4 \textcolor{gray}{modal.tsx} \DTcomment{\textcolor{gray}{Composant pour les modals}}.
.3 \textcolor{gray}{assets/} \DTcomment{\textcolor{gray}{Ressources statiques de l'application}}.
.3 \textcolor{gray}{components/} \DTcomment{\textcolor{gray}{Dossier des composants réutilisables}}.
.3 \textcolor{gray}{constants/} \DTcomment{\textcolor{gray}{Dossier des constantes du projet}}.
.3 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichier de gestion Git}}.
.2 \textcolor{gray}{app.json} \DTcomment{\textcolor{gray}{Configuration principale de l'application Expo}}.
.2 \textcolor{gray}{app-env.d.ts} \DTcomment{\textcolor{gray}{Définitions TypeScript pour l'environnement}}.
.2 \textcolor{gray}{expo-env.d.ts} \DTcomment{\textcolor{gray}{Définitions TypeScript spécifiques à Expo}}.
.2 \textcolor{gray}{package-lock.json} \DTcomment{\textcolor{gray}{Verrouillage des versions npm}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Métadonnées, scripts et dépendances du projet}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration TypeScript avec 9+ modifications}}.
}


\subsubsection{Commandes expo cli}
\begin{itemize}
  \item \textcolor{gray600}{npx expo-doctor } : Vérifie si les dépendances sont compatibles avec la version d'Expo SDK utilisée
  \item \textcolor{gray600}{npx expo start} : Démarre le serveur de développement pour votre application, utilisable avec Expo Go ou un build de développement.
  \item \textcolor{gray600}{npx expo prebuild} : Génère les répertoires natifs Android et iOS pour votre projet en utilisant Prebuild.
  \item \textcolor{gray600}{npx expo run:android} : Compile et exécute l'application native Android localement ; peut être utilisé pour générer un build pour le déploiement sur Google Play Store.
  \item \textcolor{gray600}{npx expo run:ios} : Compile et exécute l'application native iOS localement (nécessite un Mac et Xcode) ; peut être utilisé pour préparer un build pour l'App Store.
  \item \textcolor{gray600}{npx expo install package-name} : Installe une bibliothèque compatible avec la version de React Native de votre projet ; ajouter \texttt{--fix} pour valider et mettre à jour les dépendances.
  \item \textcolor{gray600}{npx expo lint} : Configure ESLint ou analyse les fichiers du projet si ESLint est déjà configuré.
  \item \textcolor{gray600}{npx expo login} : Connecte l'utilisateur à son compte Expo pour accéder aux services cloud.
  \item \textcolor{gray600}{npx expo logout} : Déconnecte l'utilisateur du compte Expo.
  \item \textcolor{gray600}{npx expo whoami} : Affiche l'utilisateur actuellement connecté à Expo CLI.
  \item \textcolor{gray600}{npx expo register} : Crée un nouveau compte Expo.
  \item \textcolor{gray600}{npx expo config} : Affiche la configuration du projet (app.json) pour inspection ou débogage.
  \item \textcolor{gray600}{npx expo start --offline} : Démarre le serveur de développement sans connexion réseau, en mode hors ligne.
  \item \textcolor{gray600}{npx expo start --tunnel} : Démarre le serveur de développement avec un tunnel public (via ngrok) pour des connexions distantes.
  \item \textcolor{gray600}{npx expo start --dev-client} : Force le lancement de l'app dans un build de développement au lieu d'Expo Go.
  \item \textcolor{gray600}{npx expo start --go} : Force le lancement de l'application dans Expo Go.
\end{itemize}

Découvrez toutes les options expo-cli : \href{https://docs.expo.dev/more/expo-cli/}{https://docs.expo.dev/more/expo-cli/}

Découvrez d'autres templates sur le dépôt officiel d'Expo : \href{https://github.com/expo/examples}{https://github.com/expo/examples} 


\section*{Ma recommandation pour organiser son projet}
Étant donné que les écrans sont découpés en composants réutilisables, et que vous avez des constantes que vous pourriez définir
dans plusieurs composants et/ou écrans ainsi que les couleurs, images. Un cas classique serait de créer ces dossiers et fichiers

\begin{itemize}
  \item \textbf{src/colors/colors.ts} : un dossier couleurs qui reprend toutes les couleurs de TailwindCSS par exemple assez pratiques et autres couleurs personnalisées
  \item \textbf{src/constants/constants.ts} : le dossier des constantes dans le fichier constant.tsx
  \item \textbf{src/components/} : le dossier qui comprends vos composants
  \item \textbf{src/screens/} : le dossier qui comprends vos ecrans , rappelez vous qu ecrans est composés de plusieurs composants . 
\end{itemize}

Exemples de contenu de colors.ts
\begin{jscode}
export const gray50 = "#F9FAFB";
export const gray100 = "#F3F4F6";
export const gray200 = "#E5E7EB";
export const gray300 = "#D1D5DB";
export const gray400 = "#9CA3AF";
export const gray500 = "#6B7280";
export const gray600 = "#4B5563";
export const gray700 = "#374151";
export const gray800 = "#1F2937";
export const gray900 = "#111827";
export const gray950 = "#09090B";

export const red50 = "#FEF2F2";
export const red100 = "#FEE2E2";
export const red200 = "#FECACA";
export const red300 = "#FCA5A5";
export const red400 = "#F87171";
export const red500 = "#EF4444";
export const red600 = "#DC2626";
export const red700 = "#B91C1C";
export const red800 = "#991B1B";
export const red900 = "#7F1D1D";
export const red950 = "#431407";
\end{jscode}

Exemples de contenu de constants.ts
\begin{jscode}
const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get("window");

export const WIDTH_FULL = SCREEN_WIDTH;
export const WIDTH_HALF = SCREEN_WIDTH / 2; // 1/2
export const WIDTH_THIRD = SCREEN_WIDTH / 3; // 1/3
export const WIDTH_QUARTER = SCREEN_WIDTH / 4; // 1/4
export const WIDTH_THREE_QUARTERS = (SCREEN_WIDTH * 3) / 4; // 3/4
export const WIDTH_FIFTH = SCREEN_WIDTH / 5; // 1/5
export const WIDTH_TWO_THIRDS = (SCREEN_WIDTH * 2) / 3; // 2/3
export const WIDTH_THREE_FIFTHS = (SCREEN_WIDTH * 3) / 5; // 3/5
export const WIDTH_FOUR_FIFTHS = (SCREEN_WIDTH * 4) / 5; // 4/5 de la largeur
export const WIDTH_TWO_FIFTHS = (SCREEN_WIDTH * 2) / 5; // 2/5 de la largeur
export const WIDTH_ONE_FIFTH = SCREEN_WIDTH / 5; // 1/5 de la largeur

\end{jscode}

\subsection{Expo + tailwindcss}
Expo et tailwindcss c est sans doute le combo parfait pour les amoureux du web et plus particulierement 
ceux UTILISANT tailwindcss et react , next ils ne peuvent rêver mieux.\newline

\textcolor{gray600}{Comment c est possible ?} \newline

\textbf{Nativewind} \newline

Nativewind vous permet d'utiliser Tailwind CSS pour styliser vos composants dans React Native.
Les composants stylisés peuvent être partagés entre toutes les plateformes React Native, grâce au moteur de style le plus adapté : CSS StyleSheet pour le web et StyleSheet.create pour le natif.
L'objectif est d'offrir une expérience de style cohérente sur toutes les plateformes, améliorant ainsi l'expérience utilisateur des développeurs, les performances des composants et la maintenabilité du code.\newline

Sur les plateformes natives, Nativewind remplit deux fonctions.
Premièrement, lors de la compilation, il compile vos styles CSS Tailwind en StyleSheet.createobjets et détermine la logique conditionnelle des styles (par exemple, survol, focus, actif, etc.).
Deuxièmement, il dispose d'un système d'exécution performant qui applique les styles à vos composants.
Vous pouvez ainsi exploiter toute la puissance de Tailwind CSS, y compris les requêtes média, les requêtes conteneur et les valeurs personnalisées,
tout en bénéficiant des performances d'un système de style natif. \newline 

\textbf{Configuration prete a l emploi} \newline 

Si vous n'êtes pas un ami des configurations manuelles, une configuration expo + nativewind prête à l'emploi
est disponible suivant cette commande : \textcolor{gray}{npx rn-new@latest --nativewind} ou \textcolor{gray}{npx rn-new@latest my-expo-app --nativewind }

\dirtree{%
.1 \textcolor{gray}{my-expo-app/}.
.2 \textcolor{gray}{.git/} \DTcomment{\textcolor{gray}{Dossier de gestion Git}}.
.2 \textcolor{gray}{assets/} \DTcomment{\textcolor{gray}{Ressources statiques de l'application}}.
.2 \textcolor{gray}{componentses/} \DTcomment{\textcolor{gray}{Dossier des Composants}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{app-env.d.log} \DTcomment{\textcolor{gray}{Journal de configuration des logs d'environnement}}.
.2 \textcolor{gray}{app-env.d.ts} \DTcomment{\textcolor{gray}{Définitions TypeScript pour l'environnement}}.
.2 \textcolor{gray}{app.json} \DTcomment{\textcolor{gray}{Configuration principale de l'application Expo}}.
.2 \textcolor{gray}{App.tsx} \DTcomment{\textcolor{gray}{Composant racine TypeScript}}.
.2 \textcolor{gray}{babel.config.js} \DTcomment{\textcolor{gray}{Configuration Babel pour la transpilation}}.
.2 \textcolor{gray}{cesconfig.jsonc} \DTcomment{\textcolor{gray}{Fichier de configuration optionnel pour le débogage}}.
.2 \textcolor{gray}{eslint.config.js} \DTcomment{\textcolor{gray}{Configuration ESLint moderne}}.
.2 \textcolor{gray}{global.less} \DTcomment{\textcolor{gray}{Fichier de styles globaux en LESS}}.
.2 \textcolor{gray}{metro.config.js} \DTcomment{\textcolor{gray}{Configuration Metro bundler pour React Native}}.
.2 \textcolor{gray}{package-lock.json} \DTcomment{\textcolor{gray}{Verrouillage des versions npm}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Fichier des Métadonnées ,script ,dépendances du projet}}.
.2 \textcolor{gray}{prettier.config.js} \DTcomment{\textcolor{gray}{Configuration Prettier pour le formatage de code}}.
.2 \textcolor{gray}{tailwind.config.js} \DTcomment{\textcolor{gray}{Configuration Tailwind CSS}}.
}

\vspace{0.5cm}

\textbf{Configuration manuelle} \newline 

Avant de lancer les commandes qui suivent Rassurez-vous d'avoir choisi votre méthode d'installation
de projet c est a dire avec react native cli ou avec le framework Expo suivant ses differentes options (bare minimum ou workflow managed) .
Ici la configuration concerne le cas d expo peut importe le workflow d expo choisi .Pour react native cli , vous trouverez la
config sur le doc officiel de Nativewind .A Supposez vous avez installé le projet expo .\newline

\begin{enumerate}
  \item \textbf{Installer Nativewind} :\newline 
  Vous devrez installer \textcolor{gray}{nativewindet} ses dépendances homologues \textcolor{gray}{tailwindcss} ,\textcolor{gray}{react-native-reanimatedet} 
  \textcolor{gray}{react-native-safe-area-context.} via npx expo ou avec la commande qui vous a permis d installer le projet expo (\textcolor{gray}{npm} ,\textcolor{gray}{pnpm} ,\textcolor{gray}{yarn} ou \textcolor{gray}{bun}   )
\end{enumerate}

\begin{jscode}
  npx expo install nativewind react-native-reanimated@~3.17.4 react-native-safe-area-context@5.4.0
\end{jscode}

\begin{jscode}
  npx expo install --dev tailwindcss@^3.4.17 prettier-plugin-tailwindcss@^0.5.11
\end{jscode}


\begin{enumerate}
  \item[2.] \textbf{Setup Tailwind CSS}: Lancer la commande suivante pour creer le fichier \textcolor{gray}{tailwindcss.config.json}
  \subitem npx tailwindcss init
\end{enumerate}
Remplissez lz fichier comme suit :
\begin{jscode}
/** @type {import('tailwindcss').Config} */
module.exports = {
  // NOTE: Update this to include the paths to all files that contain Nativewind classes.
  content: ["./App.tsx", "./components/**/*.{js,jsx,ts,tsx}"],
  presets: [require("nativewind/preset")],
  theme: {
    extend: {},
  },
  plugins: [],
}
\end{jscode}

\begin{enumerate}
  \item[3.] \textbf{Fichier CSS global} : Dans votre fichier global, généralement index.css à la racine, mettez ceci ou créez un fichier global.css 
\end{enumerate}


\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
  @tailwind base;
  @tailwind components;
  @tailwind utilities;
\end{lstlisting}
\end{tcolorbox}

\begin{enumerate}
  \item[4.] \textbf{Configuerez bable.config.js}
\end{enumerate}

\begin{jscode}
  module.exports = function (api) {
  api.cache(true);
  return {
    presets: [
      ["babel-preset-expo", { jsxImportSource: "nativewind" }],
      "nativewind/babel",
    ],
  };
};
\end{jscode}

\begin{enumerate}
  \item[5.] \textbf{Creez ou modfiez votre fichier metro.config.js} \newline
  Create a \textcolor{gray}{metro.config.js} file in the root of your project if you don't already have one, then add the following configuration:
\end{enumerate}

\begin{jscode}
const { getDefaultConfig } = require("expo/metro-config");
const { withNativeWind } = require('nativewind/metro');
 
const config = getDefaultConfig(__dirname)
 
module.exports = withNativeWind(config, { input: './global.css' })
\end{jscode}

\begin{enumerate}
  \item[6.] \textbf{Importer votre fichier index.css ou global.css} \newline
  Importer votre fichier index.css ou global.css dans votre point d entré princial App.js/App.ts pour utiliser 
  les classes utilitaires de Tailwind CSS partout dans votre application
\end{enumerate}

\begin{jscode}
import "./global.css"
 
export default App() {
  /* Your App */
}
\end{jscode}


\begin{enumerate}
  \item[7.] \textbf{Modifiez votre fichier app.json} \newline
  Assurez-vous que votre build utilise metro comme suit.
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "expo": {
    "web": {
      "bundler": "metro"
    }
  }
}
\end{lstlisting}
\end{tcolorbox}


\begin{enumerate}
  \item[6.] \textbf{Projet Typescript} \newline
  \item[8.] Si vous utilisez expo avec typescript creez un fichier nommée exactement comme suit : \textcolor{gray}{nativewind-env.d.ts} a 
  la racine du projet et remplissez-le comme ceci :
\end{enumerate}

\begin{jscode}
/// <reference types="nativewind/types" />
\end{jscode}


\section*{Expo + shadcn ui}
Vous etes surement un habitué de la libraire de composant shadcn ui en web , pourquoi ne pas utilisez son equivalent ?
Oui il existe une magnifique bibliothèque UI pour React Native avec Expo, équivalente de shadcn ui appelée \textbf{React Native Reusables} .
Il est construit avec NativeWind, TailwindCSS et Radix. \\

\textbf{Configuration prête à l'emploi}:\textcolor{gray}{npx @react-native-reusables/cli@latest init} \newline
\textbf{Documentation officielle de RNR} :\href{https://reactnativereusables.com/getting-started/introduction/}{https://reactnativereusables.com/getting-started/introduction/} \newline
\textbf{Configuration manuelle}: \href{https://reactnativereusables.com/getting-started/initial-setup/}{https://reactnativereusables.com/getting-started/initial-setup/}

\textbf{NB}:N'oubliez pas d'importer le fichier CSS global index.css dans App.ts car cela n'est pas mentionné dans la documentation.

\section{Notion de composant}
\subsection{Définition}
Le concept de composant est devenu monnaie courante et est partagé par tous les frameworks frontend : React, Vue, Svelte, Angular, etc.
Toutefois, leur implémentation diffère légèrement d'un framework à l'autre, l'objectif restant le même : permettre une grande modularité et réutilisabilité d'une portion de code, comme avec les fonctions.
Cependant, ici, ils embarquent aussi le style CSS.React Native, reposant sur React, le framework web, implémente donc aussi cette notion de composant. \newline

\textcolor{gray}{Mais un composant reutisable c est quoi au juste ?} \newline

Un composant réutilisable est un élément d'interface graphique répétitif sur une page web ou écran d'application dont la forme
se répète mais le contenu textuel diffère \newline
En développement web, on considère qu'une page web est constituée d'éléments courants : comme le menu de navigation (Header), le contenu de la page, et le pied de page (Footer).
Comme ces éléments sont courants et répétitifs, on a convenu de les découper morceau par morceau afin de pouvoir les mettre dans différents fichiers sans avoir à faire du copier-coller.
Cela représente le concept fondamental d'une fonction et s'apparente à l'usage des mots-clés tels que `require`, qui permet d'importer un fichier dans un autre, ou des fichiers 
`.h` (headers en C) pour ce qui concerne les styles, les couleurs, la position, la taille de certains éléments, etc. \newline

Observez la capture suivante .
Vous voyez que les éléments s'y répètent sauf certaines parties à savoir : le nom, l'âge, la filière, par contre le design reste inchangé : c'est ça un composant.



\subsection{Composants UI de base d'une application React Native}


\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{style} $\rightarrow$ Object | Array<Object>}
  \item \textcolor{gray600}{\texttt{accessible} $\rightarrow$ bool}
  \item \textcolor{gray600}{\texttt{accessibilityLabel} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{onLayout} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{pointerEvents} $\rightarrow$ String('auto', 'none', 'box-none', 'box-only')}
  \item \textcolor{gray600}{\texttt{onPress} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{testID} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{children} $\rightarrow$ ReactNode}
  \item \textcolor{gray600}{\texttt{onStartShouldSetResponder} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{hitSlop} $\rightarrow$ Object}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{focus()}}
  \item \textcolor{gray600}{\texttt{measure(callback)}}
  \item \textcolor{gray600}{\texttt{measureInWindow(callback)}}
  \item \textcolor{gray600}{\texttt{setNativeProps(nativeProps)}}
\end{itemize}

\vspace{0.2cm}
\textbf{Text} : Affiche du texte avec des styles personnalisables (taille, couleur, police).
\begin{jscode}[listing options={numbers=none}]
<Text style={{fontSize: 16, color: 'blue'}}>Bonjour, monde !</Text>
\end{jscode}

\vspace{0.2cm}

\section*{Image}
\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{source} $\rightarrow$ {uri: string} | number}
  \item \textcolor{gray600}{\texttt{style} $\rightarrow$ Object}
  \item \textcolor{gray600}{\texttt{resizeMode} $\rightarrow$ String('cover', 'contain', 'stretch')}
  \item \textcolor{gray600}{\texttt{accessible} $\rightarrow$ bool}
  \item \textcolor{gray600}{\texttt{defaultSource} $\rightarrow$ number}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{getSize(uri, success, failure)}}
  \item \textcolor{gray600}{\texttt{prefetch(uri)}}
\end{itemize}

\vspace{0.2cm}
\textbf{Image} : Permet d'afficher des images locales ou distantes avec des options comme \texttt{resizeMode}.
\begin{jscode}[listing options={numbers=none}]
<Image source={{uri: 'https://reactnative.dev/img/logo-og.png'}} style={{width: 100, height: 100}} />
\end{jscode}

\vspace{0.2cm}

\section*{TextInput}
\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{onChangeText} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{value} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{placeholder} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{keyboardType} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{secureTextEntry} $\rightarrow$ bool}
  \item \textcolor{gray600}{\texttt{style} $\rightarrow$ Object}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{focus()}}
  \item \textcolor{gray600}{\texttt{blur()}}
\end{itemize}

\vspace{0.2cm}
\textbf{TextInput} : Permet la saisie au clavier pour des champs de formulaire.
\begin{jscode}[listing options={numbers=none}]
<TextInput placeholder="Entrez votre nom" onChangeText={(text) => setName(text)} />
\end{jscode}

\vspace{0.2cm}

\section*{Button}
\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{onPress} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{title} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{color} $\rightarrow$ String}
  \item \textcolor{gray600}{\texttt{disabled} $\rightarrow$ bool}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{Pas de méthodes publiques fréquemment utilisées.}
\end{itemize}

\vspace{0.2cm}
\textbf{Button} : Bouton pour d\'eclencher des actions via \texttt{onPress}.
\begin{jscode}[listing options={numbers=none}]
<Button title="Cliquer ici" onPress={() => alert('Bouton cliqu\'e !')} />
\end{jscode}

\vspace{0.2cm}

\section*{ScrollView}
\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{horizontal} $\rightarrow$ bool}
  \item \textcolor{gray600}{\texttt{showsVerticalScrollIndicator} $\rightarrow$ bool}
  \item \textcolor{gray600}{\texttt{refreshControl} $\rightarrow$ ReactElement}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{scrollTo(y, x, animated)}}
  \item \textcolor{gray600}{\texttt{scrollToEnd()}}
  \item \textcolor{gray600}{\texttt{scrollToTop()}}
\end{itemize}

\vspace{0.2cm}
\textbf{ScrollView} : Conteneur d\'efilant pour afficher du contenu plus grand que l'\'ecran.
\begin{jscode}[listing options={numbers=none}]
<ScrollView><Text>Contenu long...</Text></ScrollView>
\end{jscode}

\vspace{0.2cm}

\section*{FlatList}
\textbf{Props}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{data} $\rightarrow$ Array}
  \item \textcolor{gray600}{\texttt{renderItem} $\rightarrow$ ({item, index}) $\Rightarrow$ ReactElement}
  \item \textcolor{gray600}{\texttt{keyExtractor} $\rightarrow$ (item, index) $\Rightarrow$ String}
  \item \textcolor{gray600}{\texttt{onEndReached} $\rightarrow$ Function}
  \item \textcolor{gray600}{\texttt{ListHeaderComponent} $\rightarrow$ ReactElement}
  \item \textcolor{gray600}{\texttt{ListFooterComponent} $\rightarrow$ ReactElement}
\end{itemize}
\textbf{Méthodes}
\begin{itemize}[label={}]
  \item \textcolor{gray600}{\texttt{scrollToIndex(params)}}
  \item \textcolor{gray600}{\texttt{scrollToItem(params)}}
  \item \textcolor{gray600}{\texttt{scrollToOffset(params)}}
\end{itemize}

\vspace{0.2cm}
\textbf{FlatList} : Liste optimis\'ee pour de grandes quantit\'es de donn\'ees avec rendu paresseux.
\begin{jscode}[listing options={numbers=none}]
<FlatList data={items} renderItem={({item}) => <Text>{item.name}</Text>} />
\end{jscode}


\subsection{Composants reutilisables Typés avec des props}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';

interface StudentProps {
  id: number;
  firstName: string;
  lastName: string;
  age: number;
  email: string;
  grade?: number;
  validated: boolean;
  courses: string[];
  address: {
    street: string;
    city: string;
    matricule: string;
  };
  image?: any;

const Student: React.FC<{ student: StudentProps }> = ({ student }) => {
  return (
    <View style={styles.container}>
      {student.image && <Image source={student.image} style={styles.image} />}
      <Text style={styles.title}>Student Information</Text>
      <Text>ID: {student.id}</Text>
      <Text>Name: {student.firstName} {student.lastName}</Text>
      <Text>Age: {student.age}</Text>
      <Text>Email: {student.email}</Text>
      {student.grade !== undefined && <Text>Grade: {student.grade}</Text>}
      <Text>Validated: {student.validated ? 'Yes' : 'No'}</Text>
      <Text>Courses: {student.courses.join(', ')}</Text>
      <View>
        <Text style={styles.subtitle}>Address</Text>
        <Text>Street: {student.address.street}</Text>
        <Text>City: {student.address.city}</Text>
        <Text>Matricule: {student.address.matricule}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
  },
  image: {
    width: 100,
    height: 100,
    borderRadius: 50,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 8,
  },
});

export default Student;

\end{lstlisting}
\end{tcolorbox}

Explication du composant Student :

\begin{enumerate}
    \item \textbf{Interface TypeScript (StudentProps)} :
    \begin{itemize}
        \item Définit la structure des données d'un étudiant avec des propriétés typées
        \item Inclut des champs obligatoires (\texttt{id}, \texttt{firstName}, \texttt{lastName}, etc.)
        \item Contient des champs optionnels (\texttt{grade?}, \texttt{image?})
        \item Définit un objet imbriqué pour l'adresse
    \end{itemize}

    \item \textbf{Composant React Native (Student)} :
    \begin{itemize}
        \item Utilise une props typée avec l'interface \texttt{StudentProps}
        \item Rendu conditionnel pour l'image et la note (\texttt{grade})
        \item Affichage formaté des informations de l'étudiant
        \item Conversion du booléen \texttt{validated} en 'Yes'/'No'
        \item Jointure du tableau \texttt{courses} avec des virgules
    \end{itemize}

    \item \textbf{Styling (StyleSheet)} :
    \begin{itemize}
        \item Conteneur principal avec bordure et espacement
        \item Style spécifique pour l'image (circulaire)
        \item Hiérarchie visuelle avec différentes tailles de texte
        \item Utilisation de marges pour l'espacement
    \end{itemize}

    \item \textbf{Points forts du composant} :
    \begin{itemize}
        \item Typage fort avec TypeScript
        \item Gestion propre des champs optionnels
        \item Structure visuelle claire avec des styles bien organisés
        \item Réutilisabilité grâce à l'interface bien définie
    \end{itemize}
\end{enumerate}


Deuxième approche : Composant avec des props explicites
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
	import React from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';

interface StudentProps {
  id: number;
  firstName: string;
  lastName: string;
  age: number;
  email: string;
  grade?: number;
  validated: boolean;
  courses: string[];
  address: {
    street: string;
    city: string;
    matricule: string;
  };
  image?: any;
}

const Student: React.FC<StudentProps> = ({
  id,
  firstName,
  lastName,
  age,
  email,
  grade,
  validated,
  courses,
  address,
  image,
}) => {
  return (
    <View style={styles.container}>
      {image && <Image source={image} style={styles.image} />}
      <Text style={styles.title}>Student Information</Text>
      <Text>ID: {id}</Text>
      <Text>Name: {firstName} {lastName}</Text>
      <Text>Age: {age}</Text>
      <Text>Email: {email}</Text>
      {grade !== undefined && <Text>Grade: {grade}</Text>}
      <Text>Validated: {validated ? 'Yes' : 'No'}</Text>
      <Text>Courses: {courses.join(', ')}</Text>
      <View>
        <Text style={styles.subtitle}>Address</Text>
        <Text>Street: {address.street}</Text>
        <Text>City: {address.city}</Text>
        <Text>Matricule: {address.matricule}</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 16,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
  },
  image: {
    width: 100,
    height: 100,
    borderRadius: 50,
    marginBottom: 16,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 8,
  },
});

export default Student;

\end{lstlisting}
\end{tcolorbox}

\subsection{Composants reutilisables Typés avec des props et defaultProps}

Avec l approche 1:
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';

const studentImage = require('./assets/student-image.jpg');

interface StudentProps {
  id?: number;
  firstName?: string;
  lastName?: string;
  age?: number;
  email?: string;
  grade?: number;
  validated?: boolean;
  courses?: string[];
  address?: {
    street?: string;
    city?: string;
    matricule?: string;
  };
}

\textbf{Explication du composant Student}

\begin{enumerate}
  \item \textbf{Definition du composant} :
  Le composant Student est un composant fonctionnel TypeScript qui affiche les informations d\'un \'etudiant avec des valeurs par d\'efaut.

  \item \textbf{Gestion des props avec valeurs par d\'efaut} :
  Chaque prop poss\`ede une valeur par d\'efaut assign\'ee:
  \begin{itemize}
    \item \texttt{id = 0} : Identifiant initial
    \item \texttt{firstName = 'John'}, \texttt{lastName = 'Doe'} : Nom par d\'efaut
    \item \texttt{age = 18} : Age initial
    \item \texttt{email = 'john.doe@example.com'} : Email par d\'efaut
    \item \texttt{validated = false} : Etat de validation initial
    \item \texttt{courses = []} : Liste vide des cours
    \item \texttt{address} : Objet contenant l\'adresse par d\'efaut
  \end{itemize}
\end{enumerate}

const Student: React.FC<StudentProps> = ({
  id = 0,
  firstName = 'John',
  lastName = 'Doe',
  age = 18,
  email = 'john.doe@example.com',
  grade,
  validated = false,
  courses = [],
  address = {
    street: '123 Main St',
    city: 'Anytown',
    matricule: '000000'
  }
}) => {
  return (
    <View style={styles.card}>
      <Image source={studentImage} style={styles.image} />
      <View style={styles.infoContainer}>
        <Text style={styles.title}>Student Information</Text>
        <Text style={styles.text}>ID: {id}</Text>
        <Text style={styles.text}>Name: {firstName} {lastName}</Text>
        <Text style={styles.text}>Age: {age}</Text>
        <Text style={styles.text}>Email: {email}</Text>
        {grade !== undefined && <Text style={styles.text}>Grade: {grade}</Text>}
        <Text style={styles.text}>Validated: {validated ? 'Yes' : 'No'}</Text>
        <Text style={styles.text}>Courses: {courses.join(', ')}</Text>
        <View style={styles.addressContainer}>
          <Text style={styles.subtitle}>Address</Text>
          <Text style={styles.text}>Street: {address.street}</Text>
          <Text style={styles.text}>City: {address.city}</Text>
          <Text style={styles.text}>Matricule: {address.matricule}</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 16,
    margin: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  image: {
    width: 100,
    height: 100,
    borderRadius: 50,
    alignSelf: 'center',
    marginBottom: 16,
  },
  infoContainer: {
    marginTop: 10,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 8,
  },
  text: {
    fontSize: 14,
    marginBottom: 4,
  },
  addressContainer: {
    marginTop: 10,
    padding: 10,
    backgroundColor: '#f9f9f9',
    borderRadius: 5,
  },
});

export default Student;

\end{lstlisting}
\end{tcolorbox}


Approche 2

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { View, Text, Image, StyleSheet } from 'react-native';

const studentImage = require('./assets/icon.png');

interface StudentProps {
  id?: number;
  firstName?: string;
  lastName?: string;
  age?: number;
  email?: string;
  grade?: number;
  validated?: boolean;
  courses?: string[];
  address?: {
    street?: string;
    city?: string;
    matricule?: string;
  };
}

const Student: React.FC<StudentProps> = (props) => {
  const {
    id = 0,
    firstName = 'John',
    lastName = 'Doe',
    age = 18,
    email = 'john.doe@example.com',
    grade = 0,
    validated = false,
    courses = [],
    address = {
      street: '123 Main St',
      city: 'Anytown',
      matricule: '000000'
    }
  } = props;

  return (
    <View style={styles.card}>
      <Image source={studentImage} style={styles.image} />
      <View style={styles.infoContainer}>
        <Text style={styles.title}>Student Information</Text>
        <Text style={styles.text}>ID: {id}</Text>
        <Text style={styles.text}>Name: {firstName} {lastName}</Text>
        <Text style={styles.text}>Age: {age}</Text>
        <Text style={styles.text}>Email: {email}</Text>
        <Text style={styles.text}>Grade: {grade}</Text>
        <Text style={styles.text}>Validated: {validated ? 'Yes' : 'No'}</Text>
        <Text style={styles.text}>Courses: {courses.join(', ')}</Text>
        <View style={styles.addressContainer}>
          <Text style={styles.subtitle}>Address</Text>
          <Text style={styles.text}>Street: {address.street}</Text>
          <Text style={styles.text}>City: {address.city}</Text>
          <Text style={styles.text}>Matricule: {address.matricule}</Text>
        </View>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#fff',
    borderRadius: 10,
    padding: 16,
    margin: 10,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 4,
    elevation: 5,
  },
  image: {
    width: 100,
    height: 100,
    borderRadius: 50,
    alignSelf: 'center',
    marginBottom: 16,
  },
  infoContainer: {
    marginTop: 10,
  },
  title: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 8,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginTop: 8,
  },
  text: {
    fontSize: 14,
    marginBottom: 4,
  },
  addressContainer: {
    marginTop: 10,
    padding: 10,
    backgroundColor: '#f9f9f9',
    borderRadius: 5,
  },
});

export default Student;

\end{lstlisting}
\end{tcolorbox}



\subsection{Composants reutilisables Typés avec des props et defaultProps et children}

\section{Gestion des états local et global : useState, useContext et Zustand}

\subsection{useState}
En React, useState est un Hook qui permet de gérer l'état (state) dans un composant fonctionnel.
Il est utilisé pour ajouter une variable d'état à un composant et pour gérer les mises à jour de cette variable de manière réactive, c'est-à-dire que lorsque l'état change, le composant se re-rend pour refléter les modifications.4


\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';

function MonComposant() {
  const [etat, setEtat] = useState(valeurInitiale);
  ...
}
\end{lstlisting}
\end{tcolorbox}

\begin{itemize}
  \item \textbf{etat}:La variable qui contient la valeur actuelle de l'état.
  \item \textbf{setEtat}:Une fonction qui permet de mettre à jour la valeur de l'état.
  \item \textbf{valeurInitiale}:La valeur initiale de l'état, qui peut être un nombre, une chaîne, un objet, un tableau, etc.
\end{itemize}

\textbf{Comment cela fonctionne}
\begin{itemize}
  \item \textbf{Déclaration}: useState retourne un tableau avec deux éléments : la valeur de l'état et une fonction
  \item \textbf{Mise à jour}:Lorsque vous appelez \textcolor{gray600}{setEtat} , React met à jour l'état et déclenche un re-rendu du composant avec la nouvelle valeur.
  \item \textbf{Fonction de mise à jour }: Vous pouvez aussi passer une fonction à la fonction de mise à jour pour calculer le nouvel état en fonction de l'état précédent
  \item \textbf{Réactivité}:Toute modification de l'état via \textcolor{gray600}{setEtat} entraîne une mise à jour de l'interface
\end{itemize}

\textbf{Exemples lassiques de useState}
\subsubsection{Composant compteur classique}
\begin{jscode}
import React, { useState } from 'react';

export default function Compteur() {
  const [count, setCount] = useState(0);

  return (
    <View>
      <Text>You clicked {count} times</Text>
      <Button onClick={() => setCount(count + 1)}>
        Click me
      </Button>
    </View>
  );
}

\end{jscode}

\subsubsection{Ouverture et fermeture d une Modal}
\begin{jscode}
import React, { useState } from 'react';
import { View, Button, Modal, Text } from 'react-native';

\textbf{Exemple de Modal dans React Native}

\begin{enumerate}
  \item \textbf{Gestion de l\'etat} :
  \begin{itemize}
    \item Utilisation du hook \texttt{useState} pour controler la visibilite
    \item \texttt{modalVisible} contient l\'etat actuel
    \item \texttt{setModalVisible} est la fonction de mise a jour
  \end{itemize}

  \item \textbf{Proprietes de la Modal} :
  \begin{itemize}
    \item \texttt{animationType="slide"} : Type d\'animation
    \item \texttt{transparent={true}} : Arriere-plan transparent
    \item \texttt{visible={modalVisible}} : Controle de visibilite
    \item \texttt{onRequestClose} : Gestion de la fermeture
  \end{itemize}

  \item \textbf{Interactions} :
  \begin{itemize}
    \item Bouton d\'ouverture : \texttt{setModalVisible(true)}
    \item Bouton de fermeture : \texttt{setModalVisible(false)}
  \end{itemize}
\end{enumerate}

const App = () => {
  const [modalVisible, setModalVisible] = useState(false);

  return (
    <View>
      <Button title="Open Modal" onPress={() => setModalVisible(true)} />

      <Modal
        animationType="slide"
        transparent={true}
        visible={modalVisible}
        onRequestClose={() => {
          setModalVisible(!modalVisible);
        }}
      >
        <View>
          <View>
            <Text>Modal Content</Text>
            <Button title="Close Modal" onPress={() => setModalVisible(false)} />
          </View>
        </View>
      </Modal>
    </View>
  );
};

export default App;

\end{jscode}



\subsection{useContext}
Par opposition à \textbf{useState}, qui gère les données locales donc l'état local d'un composant, le \textbf{useContext} gère les données globales et l'état global de votre application.\newline

\textbf{useContext} est un Hook de React qui permet d'accéder à la valeur d'un contexte dans un composant fonctionnel. Le contexte en React est une manière de partager des données (comme un état global) entre plusieurs composants sans avoir à passer des props manuellement à chaque niveau de l'arbre des composants (ce qu'on appelle le prop drilling).

\section*{Quand utiliser le useContext ?}
\begin{itemize}
  \item \textbf{Authentification utilisateur (utilisateur connecté ou pas ?)}
  \item \textbf{Gestion du thème (dark/light mode)}.
  \item \textbf{Gestion de la langue (i18n)}.
  \item \textbf{Panier e-commerce}.
\end{itemize}

\section*{Comment ça marche concrètement ?}
Dans l'immédiat, deux choses à noter rapidement.
\begin{enumerate}
  \item \textcolor{gray600}{la fonction createContext} : qui crée le contexte comme mentionné.
  \item \textcolor{gray600}{la fonction useContext} : qui va passer les données dont on veut accéder dans n'importe quel composant de l'app.
  \item \textcolor{gray600}{Wrapper le composant principal de notre app} : En effet en React, pour rendre disponibles les données globales, il faut envelopper (wrapper) le composant principal de notre app généralement le composant \textbf{App.tsx} ou \textbf{App.jsx}.
\end{enumerate}

\vspace{0.5cm}

\textbf{Cas d'authentification d'utilisateur} \newline

Le cas d'authentification est la pratique presque incontournable du moment. Elle permet de savoir si l'utilisateur est connecté ou non et d'utiliser ces informations pour lui permettre d'accéder ou non à certaines parties de l'application. C'est particulièrement utile si par exemple vous faites un système d'abonnement (premium, etc.).

\begin{jscode}
import { createContext, useContext, useState } from 'react-native';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
    const [user, setUser] = useState(null);
    const [loading, setLoading] = useState(false);

    const login = async (data) => {
        setLoading(true);
        try {
            const response = await fetch('/api/login', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(data),
            });
            const userData = await response.json();
            setUser(userData);
        } catch (error) {
            console.error('Erreur de connexion:', error);
        } finally {
            setLoading(false);
        }
    };

    const logout = () => setUser(null);

    return (
      <AuthContext.Provider value={{ user, login, logout, loading }}>
        {children}
      </AuthContext.Provider>
    );
};

export const useAuth = () => useContext(AuthContext);
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item Ligne (L1) : Importation des fonctions \textbf{createContext} et \textbf{useContext}.
  \item Ligne (L9) : Déclaration de la fonction \textbf{login}, c'est la clé de voûte, elle attend en paramètre un objet data \{...\} qui proviendra des données entrées par l'utilisateur via un formulaire et vérifiera si les données sont correctes ou non. Si les données sont correctes, la variable user sera remplie, contiendra les infos de l'utilisateur qui vient de se connecter.
  \item Lignes (L29-31) : C'est tout aussi important, c'est grâce à cette ligne qu'on expose les variables qu'on veut voir disponibles partout dans l'app.
  \item Ligne (L35) : C'est cette ligne qui prend les variables et les passe à useContext.
\end{enumerate}

\begin{jscode}
import { useState } from 'react';
import { useNavigation } from '@react-navigation/native';
import { useAuth } from './AuthContext';
import { View, Text, TextInput, Button, ActivityIndicator, StyleSheet } from 'react-native';

\textbf{Explication du composant LoginForm}

\begin{enumerate}
  \item \textbf{Hooks et etats} :
  \begin{itemize}
    \item \texttt{useAuth()} : Hook personnalise pour l\'authentification
    \item \texttt{useState} pour le formulaire : stockage des donnees
    \item \texttt{useState} pour les erreurs : gestion des messages
    \item \texttt{useNavigation} : Hook de navigation
  \end{itemize}

  \item \textbf{Gestion du formulaire} :
  \begin{itemize}
    \item \texttt{handleInputChange} : Mise a jour des champs
    \item \texttt{handleSubmit} : Soumission asynchrone
    \item Gestion des erreurs avec try/catch
  \end{itemize}

  \item \textbf{Securite} :
  \begin{itemize}
    \item Reset des erreurs a chaque modification
    \item Gestion des echecs de connexion
  \end{itemize}
\end{enumerate}

const LoginForm = () => {
    const { user, login, loading } = useAuth();
    const [data, setData] = useState({ email: '', password: '' });
    const [error, setError] = useState(null);
    const navigation = useNavigation();

    const handleInputChange = (name, value) => {
        setData({ ...data, [name]: value });
        setError(null);
    };

    const handleSubmit = async () => {
        setError(null);
        try {
            await login(data);
        } catch (error) {
            setError('Connexion echouee. Veuillez reessayer.');
        }
    };

    if (user && !loading) {
        navigation.navigate('Home');
        return null;
    }

    return (
        <View style={styles.container}>
            {loading ? (
                <ActivityIndicator size="large" color="#0000ff" />
            ) : (
                <View>
                    {error && <Text style={styles.error}>{error}</Text>}
                    <Text>Email:</Text>
                    <TextInput
                        style={styles.input}
                        value={data.email}
                        onChangeText={(value) => handleInputChange('email', value)}
                        keyboardType="email-address"
                        autoCapitalize="none"
                        required
                    />
                    <Text>Mot de passe:</Text>
                    <TextInput
                        style={styles.input}
                        value={data.password}
                        onChangeText={(value) => handleInputChange('password', value)}
                        secureTextEntry
                        required
                    />
                    <Button title="Se connecter" onPress={handleSubmit} />
                </View>
            )}
        </View>
    );
};

const styles = StyleSheet.create({
    container: { flex: 1, justifyContent: 'center', padding: 20 },
    input: { borderWidth: 1, marginBottom: 10, padding: 10 },
    error: { color: 'red', marginBottom: 10 },
});

export default LoginForm;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item Ligne (L20) : C'est bien ici qu'on fait l'usage de notre fonction du contexte qui prend en paramètre les datas.
  \item Lignes (L26-29) : Si l'utilisateur s'est bien connecté, on fait une redirection avec la fonction navigation déclarée à la ligne L10 et qui fait l'usage du hook useNavigation de \textbf{@react-navigation/native} importé à la ligne L2.
\end{enumerate}

\section*{NB}
L'usage de la fonction \textbf{logout} se fera dans tout composant qui donnera la main à l'utilisateur de se déconnecter. Cela peut être dans le home ou partout ailleurs où le besoin se fera.

\begin{jscode}
import { AuthProvider } from './AuthContext';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import LoginForm from './LoginForm';
import Home from './Home';

const Stack = createNativeStackNavigator();

const App = () => (
    <AuthProvider>
      <NavigationContainer>
        <Stack.Navigator>
          <Stack.Screen name="Login" component={LoginForm} />
          <Stack.Screen name="Home" component={Home} />
        </Stack.Navigator>
      </NavigationContainer>
    </AuthProvider>
);

export default App;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item Lignes (L10-17) : C'est sans doute la partie capitale de mise en œuvre du useContext. C'est ici qu'on wrappe notre app. Pour simplifier, c'est grâce à cet enveloppement qu'on rend disponibles dans toute l'application les données de l'utilisateur qui vient de se connecter dans tous les composants de votre application.
\end{enumerate}

\begin{jscode}
import { useAuth } from './AuthContext';
import { View, Text } from 'react-native';

const Home = () => {
  const { user } = useAuth();

  return (
      <View>
        <Text>Bienvenue sur la page d'accueil !</Text>
        {user ? (
          <Text>Bienvenue, {user.name} (ID: {user.id}) ! Vous \'etes connect\'e.</Text>
        ) : (
          <Text>Veuillez vous connecter pour voir vos informations.</Text>
        )}
      </View>
  );
};

export default Home;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item Ligne (L5) : On récupère les infos de l'utilisateur connecté via la variable user.
  \item Ligne (L10) : On vérifie, si les données existent, c'est-à-dire la variable user n'est pas vide, on affiche ces infos.
  \item Ligne (L12) : Si la variable user est vide, on affiche 'Veuillez vous connecter pour voir vos informations'. NB : c'est un opérateur ternaire ici.
\end{enumerate}


\section*{Gestion du thème avec useContext}
La gestion du thème (par exemple, mode sombre ou clair) est un cas d'usage courant pour \textbf{useContext}. Elle permet de partager les préférences de thème entre plusieurs composants sans passer par des props à chaque niveau de l'arbre des composants (prop drilling). Avec \textbf{useContext}, vous pouvez définir un thème global et permettre à chaque composant d'y accéder et de le modifier.

\subsection*{Exemple pratique : Gestion du thème sombre/clair}

\textbf{Cas d'usage : Basculement entre thèmes} \newline
Cet exemple montre comment implémenter un système de thème sombre/clair avec \textbf{useContext}. L'utilisateur peut basculer entre les modes via un bouton, et les composants s'adaptent automatiquement au thème actif.

\begin{jscode}
import { createContext, useContext, useState } from 'react';

const ThemeContext = createContext(null);

export const ThemeProvider = ({ children }) => {
    const [theme, setTheme] = useState('light');

    const toggleTheme = () => {
        setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
    };

    const themeStyles = {
        light: {
            backgroundColor: '#FFFFFF',
            textColor: '#000000',
            buttonColor: '#007AFF',
        },
        dark: {
            backgroundColor: '#1C2526',
            textColor: '#FFFFFF',
            buttonColor: '#40C4FF',
        },
    };

    return (
        <ThemeContext.Provider value={{ theme, toggleTheme, styles: themeStyles[theme] }}>
            {children}
        </ThemeContext.Provider>
    );
};

export const useTheme = () => useContext(ThemeContext);
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 1} : Importation de \texttt{createContext}, \texttt{useContext}, et \texttt{useState} depuis \texttt{react}.
  \item \textbf{Ligne 3} : Création du \texttt{ThemeContext} avec \texttt{createContext} pour stocker les données du thème.
  \item \textbf{Lignes 6--9} : Déclaration de l'état \texttt{theme} (par défaut \texttt{'light'}) et de la fonction \texttt{toggleTheme} pour basculer entre \texttt{light} et \texttt{dark}.
  \item \textbf{Lignes 11--20} : Définition des styles pour chaque thème (\texttt{light} et \texttt{dark}) avec des propriétés comme \texttt{backgroundColor} et \texttt{textColor}.
  \item \textbf{Lignes 22--24} : Fourniture du \texttt{theme}, \texttt{toggleTheme}, et \texttt{styles} via \texttt{ThemeContext.Provider} pour les rendre accessibles dans toute l'application.
  \item \textbf{Ligne 28} : Exportation de \texttt{useTheme} pour permettre aux composants d'accéder au contexte.
\end{enumerate}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { useTheme } from './ThemeContext';

const ThemeToggleScreen = () => {
    const { theme, toggleTheme, styles } = useTheme();

    return (
        <View style={[localStyles.container, { backgroundColor: styles.backgroundColor }]}>
            <Text style={[localStyles.text, { color: styles.textColor }]}>
                Mode actuel : {theme === 'light' ? 'Clair' : 'Sombre'}
            </Text>
            <TouchableOpacity
                style={[localStyles.button, { backgroundColor: styles.buttonColor }]}
                onPress={toggleTheme}
            >
                <Text style={localStyles.buttonText}>
                    Basculer vers {theme === 'light' ? 'mode sombre' : 'mode clair'}
                </Text>
            </TouchableOpacity>
        </View>
    );
};

const localStyles = StyleSheet.create({
    container: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
    text: { fontSize: 18, marginBottom: 20 },
    button: { padding: 10, borderRadius: 5 },
    buttonText: { color: '#FFFFFF', fontSize: 16 },
});

export default ThemeToggleScreen;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 3} : Importation de \texttt{useTheme} pour accéder au contexte du thème.
  \item \textbf{Ligne 5} : Récupération de \texttt{theme}, \texttt{toggleTheme}, et \texttt{styles} depuis le contexte.
  \item \textbf{Lignes 8--17} : Rendu d'une vue avec un fond et un texte utilisant les styles du thème actif (\texttt{styles.backgroundColor}, \texttt{styles.textColor}).
  \item \textbf{Lignes 12--16} : Bouton \texttt{TouchableOpacity} qui appelle \texttt{toggleTheme} pour basculer le thème, avec un style dynamique basé sur \texttt{styles.buttonColor}.
  \item \textbf{Lignes 21--25} : Définition de \texttt{localStyles} pour les styles statiques non gérés par le thème (par exemple, \texttt{fontSize}, \texttt{padding}).
\end{enumerate}

\begin{jscode}
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { ThemeProvider } from './ThemeContext';
import ThemeToggleScreen from './ThemeToggleScreen';

const Stack = createNativeStackNavigator();

const App = () => (
    <ThemeProvider>
        <NavigationContainer>
            <Stack.Navigator>
                <Stack.Screen name="ThemeToggle" component={ThemeToggleScreen} />
            </Stack.Navigator>
        </NavigationContainer>
    </ThemeProvider>
);

export default App;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Lignes 4--15} : Enveloppement de l'application dans \texttt{ThemeProvider} pour rendre le contexte du thème disponible à tous les composants.
  \item \textbf{Lignes 10--12} : Configuration d'une route pour \texttt{ThemeToggleScreen} avec \texttt{@react-navigation/native-stack}.
\end{enumerate}

\subsection*{Créer un composant réutilisable pour afficher le thème}

Pour illustrer la réutilisation du thème dans d'autres composants, voici un exemple de composant qui affiche un message stylé selon le thème actif.

\begin{jscode}
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useTheme } from './ThemeContext';

const WelcomeMessage = () => {
    const { theme, styles } = useTheme();

    return (
        <View style={[localStyles.container, { backgroundColor: styles.backgroundColor }]}>
            <Text style={[localStyles.text, { color: styles.textColor }]}>
                Bienvenue ! Le th\`eme actuel est {theme === 'light' ? 'clair' : 'sombre'}.
            </Text>
        </View>
    );
};

const localStyles = StyleSheet.create({
    container: { padding: 20, alignItems: 'center' },
    text: { fontSize: 16 },
});

export default WelcomeMessage;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 3} : Importation de \texttt{useTheme} pour accéder au contexte.
  \item \textbf{Ligne 5} : Récupération de \texttt{theme} et \texttt{styles} depuis le contexte.
  \item \textbf{Lignes 8--10} : Utilisation des styles dynamiques (\texttt{styles.backgroundColor}, \texttt{styles.textColor}) pour rendre le composant réactif au thème actif.
  \item \textbf{Lignes 14--16} : Définition de \texttt{localStyles} pour les styles statiques comme \texttt{padding} et \texttt{fontSize}.
\end{enumerate}

\subsection*{NB}
La fonction \texttt{toggleTheme} peut être utilisée dans n'importe quel composant enveloppé par \texttt{ThemeProvider}, ce qui permet une gestion centralisée du thème. Contrairement à Zustand, \texttt{useContext} nécessite un \texttt{Provider}, mais il est idéal pour des cas simples comme la gestion du thème.


\subsection{Zustand}
Zustand (qui signifie "état" en allemand) est une bibliothèque de gestion d'état légère. Elle est compatible avec plusieurs frameworks frontend : React, Vue, Angular.

\section*{Pourquoi utiliser Zustand ?}
\begin{itemize}
  \item \textbf{Ultra léger : $\sim$2.5kb gzippé}
  \item \textbf{Pas de boilerplate :} Moins de code que Redux 
  \item \textbf{TypeScript friendly :} Excellente prise en charge de TypeScript 
  \item \textbf{Performant :} Re-renders optimisés automatiquement
\end{itemize}

\begin{table}[h]
\arrayrulecolor{gray}
\renewcommand{\arraystretch}{1.2}
\begin{tabular}{|>{\small}l|>{\small}c|>{\small}c|>{\small}c|}
\hline
\rowcolor{lightgray}
\textbf{\color{darkgray}Feature} & \textbf{\color{darkgray}Zustand} & \textbf{\color{darkgray}Redux} & \textbf{\color{darkgray}Context API} \\
\hline
{\small Taille} & {\small $\sim$2.5kb} & {\small $\sim$47kb} & {\small Natif React} \\
\hline
{\small Boilerplate} & {\small Minimal} & {\small Beaucoup} & {\small Moyen} \\
\hline
{\small Performance} & {\small Excellente} & {\small Bonne} & {\small Peut être lente} \\
\hline
{\small DevTools} & {\small Oui} & {\small Oui} & {\small Non} \\
\hline
{\small TypeScript} & {\small Excellent} & {\small Bon} & {\small Moyen} \\
\hline
\end{tabular}
\captionsetup{justification=raggedright, singlelinecheck=false}
\caption{Comparaison des solutions de gestion d'état}
\label{tab:state_management_comparison}
\end{table}

\section*{Quand utiliser Zustand ?}
\begin{enumerate}
  \item \textbf{\textcolor{gray600}{Authentification utilisateur}}
  \item \textbf{\textcolor{gray600}{Panier e-commerce}}
  \item \textbf{\textcolor{gray600}{Thème et préférences UI}}
  \item \textbf{\textcolor{gray600}{Notifications/Toast système}}
  \item \textbf{\textcolor{gray600}{État de chargement global}}
  \item \textbf{\textcolor{gray600}{Éviter le Props Drilling}}
  \item \textbf{\textcolor{gray600}{Gestion d'état applicatif global}}
  \item \textbf{\textcolor{gray600}{Partage de données entre composants non-liés}}
  \item \textbf{\textcolor{gray600}{Persistance d'état entre remontages de composants}}
  \item \textbf{\textcolor{gray600}{Logique métier complexe partagée}}
\end{enumerate}

\section*{Comment ça marche concrètement ?}
Avec Zustand, deux points clés à noter :
\begin{enumerate}
  \item \textcolor{gray600}{Créer un store avec \texttt{create}} : Cela définit un magasin global qui contient l'état et les fonctions pour le modifier.
  \item \textcolor{gray600}{Accéder au store} : Les composants utilisent un hook généré par le store (ex. : \texttt{useAuthStore}) pour accéder à l'état et aux actions, sans besoin de \texttt{Provider}.
\end{enumerate}

\section*{Exemples courants pratiques de Zustand}

\textbf{Cas d'authentification d'utilisateur} \newline
L'authentification est un cas d'usage courant. Elle permet de savoir si un utilisateur est connecté, de stocker ses informations (ex. : nom, ID) et de restreindre l'accès à certaines parties de l'application, comme un système d'abonnement premium.

\begin{jscode}
import { create } from 'zustand';

const useAuthStore = create((set) => ({
  user: null,
  loading: false,
  login: async (data) => {
    set({ loading: true });
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });
      if (!response.ok) {
        throw new Error('Connexion \'echou\'ee');
      }
      const userData = await response.json();
      set({ user: userData, loading: false });
    } catch (error) {
      set({ loading: false });
      throw error;
    }
  },
  logout: () => set({ user: null }),
}));

export default useAuthStore;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 1} : Importation de \texttt{create} depuis \texttt{zustand} pour créer le store.
  \item \textbf{Lignes 3--19} : Création du store \texttt{useAuthStore} avec l'état initial (\texttt{user: null}, \texttt{loading: false}) et deux fonctions : \texttt{login} (pour connecter un utilisateur via une requête API) et \texttt{logout} (pour réinitialiser \texttt{user} à \texttt{null}).
  \item \textbf{Lignes 6--17} : La fonction \texttt{login} prend un objet \texttt{data} (ex. : \texttt{\{email, password\}}) provenant d'un formulaire, effectue une requête API, et met à jour \texttt{user} avec les données renvoyées si la connexion réussit.
  \item \textbf{Ligne 19} : La fonction \texttt{logout} réinitialise l'état \texttt{user} à \texttt{null}.
\end{enumerate}


\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import useAuthStore from './useAuthStore';

const LoginForm = () => {
    const { user, login, loading } = useAuthStore();
    const [data, setData] = useState({ email: '', password: '' });
    const [error, setError] = useState(null);
    const navigation = useNavigation();

    const handleInputChange = (name, value) => {
        setData({ ...data, [name]: value });
        setError(null);
    };

    const handleSubmit = async () => {
        setError(null);
        try {
            await login(data);
        } catch (error) {
            setError('Connexion \'echou\'ee. Veuillez r\'eessayer.');
        }
    };

    if (user && !loading) {
        navigation.navigate('Home');
        return null;
    }

    return (
        <View style={styles.container}>
            {loading ? (
                <Text>Chargement...</Text>
            ) : (
                <View>
                    {error && <Text style={styles.error}>{error}</Text>}
                    <View>
                        <Text>Email :</Text>
                        <TextInput
                            style={styles.input}
                            value={data.email}
                            onChangeText={(text) => handleInputChange('email', text)}
                            keyboardType="email-address"
                            autoCapitalize="none"
                            placeholder="Entrez votre email"
                            required
                        />
                    </View>
                    <View>
                        <Text>Mot de passe :</Text>
                        <TextInput
                            style={styles.input}
                            value={data.password}
                            onChangeText={(text) => handleInputChange('password', text)}
                            secureTextEntry
                            placeholder="Entrez votre mot de passe"
                            required
                        />
                    </View>
                    <TouchableOpacity style={styles.button} onPress={handleSubmit}>
                        <Text>Se connecter</Text>
                    </TouchableTouchableOpacity>
                </View>
            )}
        </View>
    );
};

const styles = StyleSheet.create({
    container: { flex: 1, justifyContent: 'center', padding: 20 },
    input: { borderWidth: 1, marginBottom: 10, padding: 10 },
    error: { color: 'red', marginBottom: 10 },
    button: { backgroundColor: '#007AFF', padding: 10, alignItems: 'center' }
});

export default LoginForm;
\end{lstlisting}
\end{tcolorbox}


% \begin{jscode}
% import React, { useState } from 'react';
% import { View, Text, TextInput, TouchableOpacity, StyleSheet } from 'react-native';
% import { useNavigation } from '@react-navigation/native';
% import useAuthStore from './useAuthStore';

% const LoginForm = () => {
%     const { user, login, loading } = useAuthStore();
%     const [data, setData] = useState({ email: '', password: '' });
%     const [error, setError] = useState(null);
%     const navigation = useNavigation();

%     const handleInputChange = (name, value) => {
%         setData({ ...data, [name]: value });
%         setError(null);
%     };

%     const handleSubmit = async () => {
%         setError(null);
%         try {
%             await login(data);
%         } catch (error) {
%             setError('Connexion \'echou\'ee. Veuillez r\'eessayer.');
%         }
%     };

%     if (user && !loading) {
%         navigation.navigate('Home');
%         return null;
%     }

%     return (
%         <View style={styles.container}>
%             {loading ? (
%                 <Text>Chargement...</Text>
%             ) : (
%                 <View>
%                     {error && <Text style={styles.error}>{error}</Text>}
%                     <View>
%                         <Text>Email :</Text>
%                         <TextInput
%                             style={styles.input}
%                             value={data.email}
%                             onChangeText={(text) => handleInputChange('email', text)}
%                             keyboardType="email-address"
%                             autoCapitalize="none"
%                             placeholder="Entrez votre email"
%                             required
%                         />
%                     </View>
%                     <View>
%                         <Text>Mot de passe :</Text>
%                         <TextInput
%                             style={styles.input}
%                             value={data.password}
%                             onChangeText={(text) => handleInputChange('password', text)}
%                             secureTextEntry
%                             placeholder="Entrez votre mot de passe"
%                             required
%                         />
%                     </View>
%                     <TouchableOpacity style={styles.button} onPress={handleSubmit}>
%                         <Text>Se connecter</Text>
%                     </TouchableTouchableOpacity>
%                 </View>
%             )}
%         </View>
%     );
% };

% const styles = StyleSheet.create({
%     container: { flex: 1, justifyContent: 'center', padding: 20 },
%     input: { borderWidth: 1, marginBottom: 10, padding: 10 },
%     error: { color: 'red', marginBottom: 10 },
%     button: { backgroundColor: '#007AFF', padding: 10, alignItems: 'center' }
% });

% export default LoginForm;
% \end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 4} : Importation \texttt{useAuthStore} pour accéder à \texttt{user}, \texttt{login}, et \texttt{loading}.
  \item \textbf{Ligne 19} : Appel de \texttt{login} du store avec les données du formulaire (\texttt{data}).
  \item \textbf{Lignes 24--26} : Si \texttt{user} existe et \texttt{loading} est \texttt{false}, redirection vers \texttt{Home} avec \texttt{useNavigation} (importé ligne 3).
  \item \textbf{Lignes 30--54} : Affichage du formulaire avec gestion des erreurs (\texttt{error}) si la connexion échoue.
\end{enumerate}

\begin{jscode}
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import LoginForm from './LoginForm';
import Home from './Home';

const Stack = createNativeStackNavigator();

const App = () => (
    <NavigationContainer>
        <Stack.Navigator>
            <Stack.Screen name="Login" component={LoginForm} />
            <Stack.Screen name="Home" component={Home} />
        </Stack.Navigator>
    </NavigationContainer>
);

export default App;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Lignes 8--14} : Configuration des routes pour \texttt{LoginForm} (\texttt{Login}) et \texttt{Home} (\texttt{Home}).
  \item Aucune enveloppe (\texttt{Provider}) n'est nécessaire, car Zustand gère l'état global directement via le store.
\end{enumerate}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import useAuthStore from './useAuthStore';

const Home = () => {
    const { user, logout } = useAuthStore();

    return (
        <View style={styles.container}>
            <Text>Bienvenue sur la page d'accueil !</Text>
            {user ? (
                <View>
                    <Text>Bienvenue, {user.name} (ID: {user.id}) ! Vous \'etes connect\'e.</Text>
                    <TouchableOpacity style={styles.button} onPress={logout}>
                        <Text>Se d\'econnecter</Text>
                    </TouchableOpacity>
                </View>
            ) : (
                <Text>Veuillez vous connecter pour voir vos informations.</Text>
            )}
        </View>
    );
};

const styles = StyleSheet.create({
    container: { flex: 1, justifyContent: 'center', padding: 20 },
    button: { backgroundColor: '#007AFF', padding: 10, alignItems: 'center', marginTop: 10 }
});

export default Home;
\end{jscode}

\textbf{Explication}
\begin{enumerate}
  \item \textbf{Ligne 5} : Récupération de \texttt{user} et \texttt{logout} depuis \texttt{useAuthStore}.
  \item \textbf{Lignes 10--14} : Si \texttt{user} that existe, affichage des informations de l'utilisateur (\texttt{user.name}, \texttt{user.id}) et d'un bouton de déconnexion qui appelle \texttt{logout}.
  \item \textbf{Ligne 16} : Si \texttt{user} est \texttt{null}, affichage d'un message demandant de se connecter.
\end{enumerate}

\section*{NB}
L'utilisation de \texttt{logout} se fait dans tout composant où l'utilisateur peut se déconnecter, comme \texttt{Home}. Avec Zustand, l'état global est accessible directement sans \texttt{Provider}, ce qui simplifie la configuration par rapport à \texttt{useContext}.

\subsection*{Créer votre store dans un fichier \texttt{LoadingStore.ts}}
\begin{jscode}
import { create } from 'zustand';

interface LoadingState {
  isLoading: boolean;
  loadingMessage: string;
  showLoading: (message?: string) => void;
  hideLoading: () => void;
}

export const LoadingStore = create<LoadingState>((set) => ({
  isLoading: false,
  loadingMessage: 'Chargement...',
  
  showLoading: (message = 'Chargement...') => 
    set({ 
      isLoading: true, 
      loadingMessage: message 
    }),
  
  hideLoading: () => 
    set({ 
      isLoading: false, 
      loadingMessage: 'Chargement...' 
    }),
}));
\end{jscode}

\subsection*{Composant Loading global}
\begin{jscode}
import React from 'react';
import { View, ActivityIndicator, Text, Modal, StyleSheet } from 'react-native';
import { LoadingStore } from './LoadingStore';

const GlobalLoading = () => {
  const { isLoading, loadingMessage } = LoadingStore();

  if (!isLoading) {
    return null;
  }

  return (
    <Modal
      transparent={true}
      animationType="fade"
      visible={isLoading}
    >
      <View style={styles.modalContainer}>
        <View style={styles.modalContent}>
          <ActivityIndicator 
            size="large" 
            color="#007AFF" 
          />
          <Text style={styles.text}>
            {loadingMessage}
          </Text>
        </View>
      </View>
    </Modal>
  );
};

const styles = StyleSheet.create({
    modalContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0,0,0,0.5)' },
    modalContent: { backgroundColor: 'white', padding: 20, borderRadius: 10, alignItems: 'center' },
    text: { marginTop: 10 }
});

export default GlobalLoading;
\end{jscode}


usage Loading (GlobalLoading) dans un fichier parent en fonction du store (état)






\subsection{Navigation dans React Native / Expo}
\subsubsection{Deux types de navigation :React Navigation et navigation basé sur les fichiers}


\subsubsection{StackNavigator}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{react-navigation.PNG}
    \caption{React Navigation documentation}
    \label{fig:react-navigation-doc}
\end{figure}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';

import Home from '../screens/Home';
import Students from '../screens/Students';
import Courses from '../screens/Courses';
import Account from '../screens/Account';

const Stack = createStackNavigator();

const StackNavigator = () => {
  return (
    <Stack.Navigator initialRouteName="Home">
      <Stack.Screen 
        name="Home" 
        component={Home}
        options={{
          title: 'Accueil',
        }}
      />
      <Stack.Screen 
        name="Students" 
        component={Students}
        options={{
          title: 'Etudiants',
        }}
      />
      <Stack.Screen 
        name="Courses" 
        component={Courses}
        options={{
          title: 'Cours',
        }}
      />
      <Stack.Screen 
        name="Account" 
        component={Account}
        options={{
          title: 'Compte',
        }}
      />
    </Stack.Navigator>
  );
};

export default StackNavigator;
\end{lstlisting}
\end{tcolorbox}




\subsubsection{Tab Navigation}




\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import Home from '../screens/Home';
import Students from '../screens/Students';
import Courses from '../screens/Courses';
import Account from '../screens/Account';

const Tab = createBottomTabNavigator();

function Tabs() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Home" component={Home} />
      <Tab.Screen name="Students" component={Students} />
      <Tab.Screen name="Courses" component={Courses} />
      <Tab.Screen name="Account" component={Account} />
    </Tab.Navigator>
  );
}

export default Tabs;
\end{lstlisting}
\end{tcolorbox}


\subsubsection{Drawer Navigation}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { createDrawerNavigator } from '@react-navigation/drawer';

import Home from '../screens/Home';
import Students from '../screens/Students';
import Courses from '../screens/Courses';
import Account from '../screens/Account';

const Drawer = createDrawerNavigator();

function Menulateral() {
  return (
    <Drawer.Navigator>
      <Drawer.Screen name="Home" component={Home} />
      <Drawer.Screen name="Students" component={Students} />
      <Drawer.Screen name="Courses" component={Courses} />
      <Drawer.Screen name="Account" component={Account} />
    </Drawer.Navigator>
  );
}

export default Menulateral;
\end{lstlisting}
\end{tcolorbox}

\subsubsection{Mutli Navigation/Navigation imbriquée :Stack + Tab + Drawer}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

import Menulateral from './Menulateral';
import Students from '../screens/Students';
import Courses from '../screens/Courses';
import Account from '../screens/Account';

const Tab = createBottomTabNavigator();

function MultiMenu() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="Menulateral" />
      <Tab.Screen name="Students" component={Students} />
      <Tab.Screen name="Courses" component={Courses} />
      <Tab.Screen name="Account" component={Account} />
    </Tab.Navigator>
  );
}

export default MultiMenu;
\end{lstlisting}
\end{tcolorbox}


\section{Liste Rendering : Map, FlatList}
Le rendering de listes est une fonctionnalité essentielle dans les applications React Native, permettant d'afficher efficacement des collections de données. 
React Native propose plusieurs composants pour gérer le rendu de listes, notamment `FlatList` et `ScrollView`.
`FlatList` est optimisé pour les grandes listes et offre des performances supérieures grâce à son rendu paresseux,
tandis que `ScrollView` est plus adapté aux petites listes (max 20 elements) ou aux contenus qui ne nécessitent pas de performance optimale 

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { ScrollView, StyleSheet } from 'react-native';
import Student from './components/Student';

\textbf{Explication du composant Students}

\begin{enumerate}
  \item \textbf{Structure du composant} :
  \begin{itemize}
    \item Composant conteneur pour la liste d\'etudiants
    \item Utilisation de \texttt{ScrollView} pour le defilement
    \item Integration du composant \texttt{Student} individuel
  \end{itemize}

  \item \textbf{Donnees statiques} :
  \begin{itemize}
    \item Tableau d\'objets d\'etudiants
    \item Structure complete pour chaque etudiant :
    \begin{itemize}
      \item Informations de base (id, nom, age, email)
      \item Donnees academiques (note, validation, cours)
      \item Coordonnees (adresse complete)
      \item Image de profil (via require)
    \end{itemize}
  \end{itemize}

  \item \textbf{Bonnes pratiques} :
  \begin{itemize}
    \item Donnees structurees et typees
    \item Separation des responsabilites
    \item Gestion optimisee des ressources
  \end{itemize}
\end{enumerate}

const Students: React.FC = () => {
  const students = [
    {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      age: 20,
      email: 'john.doe@example.com',
      grade: 85,
      validated: true,
      courses: ['Math', 'Science'],
      address: {
        street: '123 Main St',
        city: 'Anytown',
        matricule: 'M12345',
      },
      image: require('./assets/student-image.jpg'),
    },
    {
      id: 2,
      firstName: 'Jane',
      lastName: 'Smith',
      age: 22,
      email: 'jane.smith@example.com',
      validated: false,
      courses: ['Literature', 'History'],
      address: {
        street: '456 Elm St',
        city: 'Othertown',
        matricule: 'M67890',
      },
      image: require('./assets/student-image.jpg'), // Assurez-vous que le chemin est correct
    },
  ];

  return (
    <ScrollView style={styles.container}>
      {students.map((student) => (
        <Student key={student.id} student={student} />
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});

export default Students;
\end{lstlisting}
\end{tcolorbox}


autre FACON DE rendre le composant student dans un ScrollView AVEC LE MODEL 1 de notre composant Student
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { ScrollView, StyleSheet } from 'react-native';
import Student from './Student';

const Students: React.FC = () => {
  const students = [
    {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      age: 20,
      email: 'john.doe@example.com',
      grade: 85,
      validated: true,
      courses: ['Math', 'Science'],
      address: {
        street: '123 Main St',
        city: 'Anytown',
        matricule: 'M12345',
      },
      image: require('./assets/student-image.jpg'),
    },
    {
      id: 2,
      firstName: 'Jane',
      lastName: 'Smith',
      age: 22,
      email: 'jane.smith@example.com',
      validated: false,
      courses: ['Literature', 'History'],
      address: {
        street: '456 Elm St',
        city: 'Othertown',
        matricule: 'M67890',
      },
      image: require('./assets/student-image.jpg'),
    },
  ];

  return (
    <ScrollView style={styles.container}>
      {students.map((student) => (
        <Student
          key={student.id}
          id={student.id}
          firstName={student.firstName}
          lastName={student.lastName}
          age={student.age}
          email={student.email}
          grade={student.grade}
          validated={student.validated}
          courses={student.courses}
          address={student.address}
          image={student.image}
        />
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});

export default Students;

\end{lstlisting}
\end{tcolorbox}



Methode 3: Spread operator pour rendre le composant Student dans un ScrollView AVEC LE MODEL 2 de notre composant Student
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React from 'react';
import { ScrollView, StyleSheet } from 'react-native';
import Student from './Student';

const Students: React.FC = () => {
  const students = [
    {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      age: 20,
      email: 'john.doe@example.com',
      grade: 85,
      validated: true,
      courses: ['Math', 'Science'],
      address: {
        street: '123 Main St',
        city: 'Anytown',
        matricule: 'M12345',
      },
      image: require('./assets/student-image.jpg'),
    },
    {
      id: 2,
      firstName: 'Jane',
      lastName: 'Smith',
      age: 22,
      email: 'jane.smith@example.com',
      validated: false,
      courses: ['Literature', 'History'],
      address: {
        street: '456 Elm St',
        city: 'Othertown',
        matricule: 'M67890',
      },
      image: require('./assets/student-image.jpg'),
    },
    .
    .
    .
  ];

  return (
    <ScrollView style={styles.container}>
      {students.map((student) => (
        <Student key={student.id} {...student} />
      ))}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});

export default Students;
\end{lstlisting}
\end{tcolorbox}

Avec FlatList 1
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
	import React from 'react';
import { FlatList, StyleSheet } from 'react-native';
import Student from './Student';

const Students: React.FC = () => {
  const students = [
    {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      age: 20,
      email: 'john.doe@example.com',
      grade: 85,
      validated: true,
      courses: ['Math', 'Science'],
      address: {
        street: '123 Main St',
        city: 'Anytown',
        matricule: 'M12345',
      },
      image: require('./assets/student-image.jpg'),
    },
    {
      id: 2,
      firstName: 'Jane',
      lastName: 'Smith',
      age: 22,
      email: 'jane.smith@example.com',
      validated: false,
      courses: ['Literature', 'History'],
      address: {
        street: '456 Elm St',
        city: 'Othertown',
        matricule: 'M67890',
      },
      image: require('./assets/student-image.jpg'),
    },
  ];

  return (
    <FlatList
      data={students}
      keyExtractor={(item) => item.id.toString()}
      renderItem={({ item }) => (
        <Student
          id={item.id}
          firstName={item.firstName}
          lastName={item.lastName}
          age={item.age}
          email={item.email}
          grade={item.grade}
          validated={item.validated}
          courses={item.courses}
          address={item.address}
          image={item.image}
        />
      )}
    />
  );
};

export default Students;

\end{lstlisting}
\end{tcolorbox}



FlatList avec Spread operator

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
	import React from 'react';
import { FlatList, StyleSheet } from 'react-native';
import Student from './Student';

const Students: React.FC = () => {
  const students = [
    {
      id: 1,
      firstName: 'John',
      lastName: 'Doe',
      age: 20,
      email: 'john.doe@example.com',
      grade: 85,
      validated: true,
      courses: ['Math', 'Science'],
      address: {
        street: '123 Main St',
        city: 'Anytown',
        matricule: 'M12345',
      },
      image: require('./assets/student-image.jpg'),
    },
    {
      id: 2,
      firstName: 'Jane',
      lastName: 'Smith',
      age: 22,
      email: 'jane.smith@example.com',
      validated: false,
      courses: ['Literature', 'History'],
      address: {
        street: '456 Elm St',
        city: 'Othertown',
        matricule: 'M67890',
      },
      image: require('./assets/student-image.jpg'),
    },
  ];

  return (
    <FlatList
      data={students}
      keyExtractor={(item) => item.id.toString()}
      renderItem={({ item }) => <Student {...item} />}
    />
  );
};

export default Students;

\end{lstlisting}
\end{tcolorbox}


\section{Rendu conditionnel (Conditional Rendering)}

Le rendu conditionnel permet d'afficher différents éléments UI selon l'état de votre application. C'est un concept fondamental en React Native qui améliore l'expérience utilisateur et prévient les erreurs d'affichage.

\subsection{Avec if/else - Return anticipé}

L'utilisation de \texttt{if/else} avec des returns anticipés est la méthode la plus lisible pour gérer plusieurs conditions séquentielles. Cette approche est particulièrement adaptée quand chaque condition retourne un composant complètement différent.

\subsubsection{Quand l'utiliser ?}
\begin{itemize}
    \item Vous avez plusieurs conditions à vérifier séquentiellement
    \item Chaque condition retourne un composant complètement différent
    \item Vous voulez gérer les cas d'erreur en premier (Guard Clauses)
    \item Le code devient plus lisible avec des returns anticipés
\end{itemize}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

export default function Dashboard({ isLoggedIn, hasPermission, user }) {
  if (!isLoggedIn) {
    return (
      <View>
        <Text>Accès refusé</Text>
        <Text>Vous devez être connecté pour accéder à cette page</Text>
        <TouchableOpacity onPress={handleLogin}>
          <Text>Se connecter</Text>
        </TouchableOpacity>
      </View>
    );
  }

  if (!hasPermission) {
    return (
      <View>
        <Text>Permissions insuffisantes</Text>
        <Text>Vous n'avez pas les droits nécessaires</Text>
        <TouchableOpacity onPress={requestAccess}>
          <Text>Demander l'accès</Text>
        </TouchableOpacity>
      </View>
    );
  }

  if (!user || !user.profile) {
    return (
      <View>
        <Text>Chargement des données utilisateur...</Text>
      </View>
    );
  }

  return (
    <View>
      <Text>Bienvenue {user.profile.name}</Text>
      <UserStats stats={user.stats} />
      <RecentActivity activities={user.activities} />
    </View>
  );
}
\end{jscode}

\textbf{Exemple : Gestion des états de chargement}

\begin{jscode}
import React, { useState, useEffect } from 'react';
import { View, Text, Image, TouchableOpacity, ActivityIndicator } from 'react-native';

export default function UserProfile({ userId }) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUserData(userId)
      .then(setData)
      .catch(setError)
      .finally(() => setLoading(false));
  }, [userId]);

  if (loading) {
    return (
      <View>
        <View />
        <View />
        <View />
        <ActivityIndicator size="large" color="#007AFF" />
      </View>
    );
  }

  if (error) {
    return (
      <View>
        <Text>Erreur de chargement</Text>
        <Text>{error.message}</Text>
        <TouchableOpacity onPress={() => window.location.reload()}>
          <Text>Réessayer</Text>
        </TouchableOpacity>
      </View>
    );
  }

  if (!data) {
    return (
      <View>
        <Text>Aucune donnée disponible</Text>
      </View>
    );
  }

  return (
    <View>
      <Image source={{ uri: data.avatar }} />
      <Text>{data.name}</Text>
      <Text>{data.bio}</Text>
    </View>
  );
}
\end{jscode}

\subsection{Avec opérateur ternaire (?:)}

L'opérateur ternaire est une expression conditionnelle compacte qui évalue une condition et retourne l'une des deux valeurs possibles. Il est parfait pour des rendus conditionnels simples avec exactement deux alternatives.

\subsubsection{Syntaxe de base}
\begin{jscode}
condition ? expressionSiVrai : expressionSiFaux
\end{jscode}

\subsubsection{Quand l'utiliser ?}
\begin{itemize}
    \item Vous avez exactement DEUX alternatives (A ou B)
    \item Le rendu conditionnel est simple et court
    \item Vous voulez assigner une valeur selon une condition
    \item Le code reste lisible sur une ou deux lignes
\end{itemize}

\textbf{Exemple}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

function NotLoggedIn() {
  return (
    <View>
      <Text>Accès refusé</Text>
      <Text>Vous devez être connecté</Text>
      <TouchableOpacity onPress={handleLogin}>
        <Text>Se connecter</Text>
      </TouchableOpacity>
    </View>
  );
}

function NoPermission() {
  return (
    <View>
      <Text>Permissions insuffisantes</Text>
      <Text>Accès non autorisé</Text>
      <TouchableOpacity onPress={requestAccess}>
        <Text>Demander l'accès</Text>
      </TouchableOpacity>
    </View>
  );
}

function LoadingUserData() {
  return (
    <View>
      <Text>Chargement...</Text>
    </View>
  );
}

export default function Dashboard({ isLoggedIn, hasPermission, user }) {
  return (
    <View>
      {!isLoggedIn ? (
        <NotLoggedIn />
      ) : !hasPermission ? (
        <NoPermission />
      ) : !user?.profile ? (
        <LoadingUserData />
      ) : (
        <View>
          <Text>Bienvenue {user.profile.name}</Text>
          <UserStats stats={user.stats} />
          <RecentActivity activities={user.activities} />
        </View>
      )}
    </View>
  );
}
\end{jscode}

\textbf{Exemple alternative 1: Early Returns (style le plus courant et recommandé)}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

function NotLoggedIn() {
  return (
    <View>
      <Text>Accès refusé</Text>
      <Text>Vous devez être connecté pour accéder à cette page</Text>
      <TouchableOpacity onPress={handleLogin}>
        <Text>Se connecter</Text>
      </TouchableOpacity>
    </View>
  );
}

function NoPermission() {
  return (
    <View>
      <Text>Permissions insuffisantes</Text>
      <Text>Vous n'avez pas les droits nécessaires</Text>
      <TouchableOpacity onPress={requestAccess}>
        <Text>Demander l'accès</Text>
      </TouchableOpacity>
    </View>
  );
}

function LoadingUserData() {
  return (
    <View>
      <Text>Chargement des données utilisateur...</Text>
    </View>
  );
}

export default function Dashboard({ isLoggedIn, hasPermission, user }) {
  if (!isLoggedIn) {
    return <NotLoggedIn />;
  }

  if (!hasPermission) {
    return <NoPermission />;
  }

  if (!user || !user.profile) {
    return <LoadingUserData />;
  }

  return (
    <View>
      <Text>Bienvenue {user.profile.name}</Text>
      <UserStats stats={user.stats} />
      <RecentActivity activities={user.activities} />
    </View>
  );
}
\end{jscode}

\textbf{Version alternative 2 : Avec variable content (style plus déclaratif)}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

function NotLoggedIn() {
  return (
    <View>
      <Text>Accès refusé</Text>
      <Text>Vous devez être connecté</Text>
      <TouchableOpacity onPress={handleLogin}>
        <Text>Se connecter</Text>
      </TouchableOpacity>
    </View>
  );
}

function NoPermission() {
  return (
    <View>
      <Text>Permissions insuffisantes</Text>
      <Text>Vous n'avez pas les droits nécessaires</Text>
      <TouchableOpacity onPress={requestAccess}>
        <Text>Demander l'accès</Text>
      </TouchableOpacity>
    </View>
  );
}

function LoadingUserData() {
  return (
    <View>
      <Text>Chargement des données utilisateur...</Text>
    </View>
  );
}

export default function Dashboard({ isLoggedIn, hasPermission, user }) {
  let content;

  if (!isLoggedIn) {
    content = <NotLoggedIn />;
  } else if (!hasPermission) {
    content = <NoPermission />;
  } else if (!user?.profile) {
    content = <LoadingUserData />;
  } else {
    content = (
      <View>
        <Text>Bienvenue {user.profile.name}</Text>
        <UserStats stats={user.stats} />
        <RecentActivity activities={user.activities} />
      </View>
    );
  }

  return <View>{content}</View>;
}
\end{jscode}

\subsubsection{Ternaires imbriqués (à éviter si possible)}

\begin{jscode}
import React from 'react';
import { View, Text } from 'react-native';

function OrderStatus({ status }) {
  const bgColor = 
    status === 'pending' ? '#ffeaa7' :
    status === 'processing' ? '#74b9ff' :
    status === 'shipped' ? '#a29bfe' :
    status === 'delivered' ? '#55efc4' :
    '#dfe6e9';

  const label = 
    status === 'pending' ? 'En attente' :
    status === 'processing' ? 'En traitement' :
    status === 'shipped' ? 'Expédié' :
    status === 'delivered' ? 'Livré' :
    'Inconnu';

  return (
    <View style={{ backgroundColor: bgColor }}>
      <Text>{label}</Text>
    </View>
  );
}
\end{jscode}

\textbf{Préférer la version switch/case}

\begin{jscode}
import React from 'react';
import { View, Text } from 'react-native';

function OrderStatus({ status }) {
  let bgColor, label;

  switch(status) {
    case 'pending':
      bgColor = '#ffeaa7';
      label = 'En attente';
      break;
    case 'processing':
      bgColor = '#74b9ff';
      label = 'En traitement';
      break;
    case 'shipped':
      bgColor = '#a29bfe';
      label = 'Expédié';
      break;
    case 'delivered':
      bgColor = '#55efc4';
      label = 'Livré';
      break;
    default:
      bgColor = '#dfe6e9';
      label = 'Inconnu';
  }

  return (
    <View style={{ backgroundColor: bgColor }}>
      <Text>{label}</Text>
    </View>
  );
}
\end{jscode}

\subsection{Avec l'opérateur \&\& (Logical AND)}

L'opérateur logique \texttt{\&\&} permet d'afficher un élément uniquement si une condition est vraie, sans alternative. C'est le cas d'usage le plus courant en React Native.

\subsubsection{Principe de fonctionnement}

En JavaScript, l'opérateur \texttt{\&\&} évalue l'expression de gauche. Si elle est \textit{truthy}, il retourne l'expression de droite. Si elle est \textit{falsy}, il retourne la valeur de gauche.

\begin{jscode}
// Si condition est true, affiche le composant
// Si condition est false, n'affiche rien
{condition && <Component />}
\end{jscode}

\subsubsection{Quand l'utiliser ?}
\begin{itemize}
    \item Vous voulez afficher quelque chose SEULEMENT si une condition est vraie
    \item Pas besoin d'alternative (pas de "sinon")
    \item Affichage conditionnel d'éléments optionnels
    \item Notifications, badges, messages d'erreur
\end{itemize}

\subsubsection{Exemple : Notifications et badges}

\begin{jscode}
import React from 'react';
import { View, Text, Image } from 'react-native';

function Header({ user, notificationCount, isPremium }) {
  return (
    <View>
      <Text>Mon Application</Text>
      
      {isPremium && (
        <View>
          <Text>Premium</Text>
        </View>
      )}
      
      {notificationCount > 0 && (
        <View>
          <Text>{notificationCount} nouvelles notifications</Text>
        </View>
      )}
      
      {user && (
        <View>
          <Image source={{ uri: user.avatar }} />
          <Text>{user.name}</Text>
        </View>
      )}
    </View>
  );
}
\end{jscode}

\subsubsection{Exemple : Messages d'erreur et de succès}

\begin{jscode}
import React, { useState } from 'react';
import { View, TextInput, Text, TouchableOpacity } from 'react-native';

function Form() {
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);

  return (
    <View>
      <TextInput placeholder="Email" placeholderTextColor="#999" />
      
      {error && (
        <View>
          <Text>{error}</Text>
        </View>
      )}
      
      {success && (
        <View>
          <Text>Formulaire envoyé avec succès !</Text>
        </View>
      )}
      
      <TouchableOpacity>
        <Text>Envoyer</Text>
      </TouchableOpacity>
    </View>
  );
}
\end{jscode}

\textbf{PIÈGE IMPORTANT : Le problème du zéro}

\begin{jscode}
import React from 'react';
import { View, Text } from 'react-native';

function ItemList({ items }) {
  return (
    <View>
      {items.length && <Text>Liste des items</Text>}
    </View>
  );
}

function ItemList({ items }) {
  return (
    <View>
      {items.length > 0 && <Text>Liste des items</Text>}
    </View>
  );
}

function ItemList({ items }) {
  return (
    <View>
      {Boolean(items.length) && <Text>Liste des items</Text>}
      {!!items.length && <Text>Liste des items</Text>}
    </View>
  );
}
\end{jscode}

\subsubsection{Exemple : Affichage conditionnel de sections}

\begin{jscode}
import React from 'react';
import { View, Text, ScrollView, FlatList } from 'react-native';

function ProductPage({ product, reviews, relatedProducts }) {
  return (
    <ScrollView>
      <Text>{product.name}</Text>
      <Text>{product.description}</Text>
      
      {product.onSale && (
        <View>
          <Text>{product.discount}% de réduction !</Text>
        </View>
      )}
      
      {reviews.length > 0 && (
        <View>
          <Text>Avis clients ({reviews.length})</Text>
          <FlatList
            data={reviews}
            keyExtractor={(item) => item.id}
            renderItem={({ item }) => <ReviewCard review={item} />}
          />
        </View>
      )}
      
      {relatedProducts && relatedProducts.length > 0 && (
        <View>
          <Text>Produits similaires</Text>
          <ProductGrid products={relatedProducts} />
        </View>
      )}
    </ScrollView>
  );
}
\end{jscode}

\subsubsection{Exemple : Système de rôles utilisateur}

\begin{jscode}
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';

function UserDashboard({ userRole }) {
  switch(userRole) {
    case 'admin':
      return (
        <View>
          <Text>Panneau d'administration</Text>
          <AdminTools />
          <UserManagement />
          <SystemSettings />
        </View>
      );
    
    case 'moderator':
      return (
        <View>
          <Text>Panneau de modération</Text>
          <ContentModeration />
          <ReportQueue />
        </View>
      );
    
    case 'user':
      return (
        <View>
          <Text>Mon tableau de bord</Text>
          <UserProfile />
          <UserContent />
        </View>
      );
    
    case 'guest':
      return (
        <View>
          <Text>Visiteur</Text>
          <Text>Veuillez vous connecter pour accéder à plus de fonctionnalités</Text>
          <TouchableOpacity>
            <Text>Se connecter</Text>
          </TouchableOpacity>
        </View>
      );
    
    default:
      return (
        <View>
          <Text>Rôle non reconnu</Text>
          <Text>Contactez l'administrateur</Text>
        </View>
      );
  }
}
\end{jscode}

\subsection{Différences clés avec React Web}

\begin{itemize}
    \item Utilisation de \texttt{View} au lieu de \texttt{div}
    \item Utilisation obligatoire de \texttt{Text} pour tout contenu textuel
    \item Utilisation de \texttt{TouchableOpacity} ou \texttt{Pressable} au lieu de \texttt{button}
    \item Utilisation de \texttt{Image} avec \texttt{source=\{\{ uri: ... \}\}} au lieu de \texttt{<img src />}
    \item Utilisation de \texttt{ScrollView} ou \texttt{FlatList} pour le contenu scrollable
    \item Les styles sont généralement définis avec \texttt{StyleSheet.create()} ou inline avec des objets JavaScript
\end{itemize}

\section{Gestion des formulaires avec appels API: Axios et Fetch}
\subsection{Envoie des données}
\section*{Avec fetch}

fetch est une API native de JavaScript pour effectuer des requêtes HTTP. Elle est intégrée dans les navigateurs modernes et permet de faire des requêtes réseau de manière asynchrone. Voici le lien vers la documentation officielle de fetch sur le site de Mozilla : Fetch API.
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';

const StudentForm = () => {
  const [nom, setNom] = useState('');
  const [prenom, setPrenom] = useState('');
  const [age, setAge] = useState('');
  const [email, setEmail] = useState('');
  const [tel, setTel] = useState('');

  const handleSubmit = async () => {
    if (!nom || !prenom || !age || !email || !tel) {
      Alert.alert('Erreur', 'Veuillez remplir tous les champs.');
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert('Erreur', 'Veuillez entrer une adresse email valide.');
      return;
    }

    if (tel.length < 8 || isNaN(tel)) {
      Alert.alert('Erreur', 'Veuillez entrer un numero de telephone valide (au moins 8 chiffres).');
      return;
    }

    const studentData = {
      nom,
      prenom,
      age: parseInt(age),
      email,
      tel,
    };

    try {
      const response = await fetch('VOTRE_URL_API/students', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(studentData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Echec de la soumission du formulaire.');
      }

      const responseData = await response.json();
      Alert.alert('Succes', 'Donnees de l etudiant soumises avec succes !');
      console.log('Reponse de l API :', responseData);

      setNom('');
      setPrenom('');
      setAge('');
      setEmail('');
      setTel('');

    } catch (error) {
      console.error('Erreur lors de la soumission :', error);
      Alert.alert('Erreur', `Probleme lors de la soumission : ${error.message}`);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Formulaire Etudiant</Text>

      <TextInput
        style={styles.input}
        placeholder="Nom"
        value={nom}
        onChangeText={setNom}
      />
      <TextInput
        style={styles.input}
        placeholder="Prenom"
        value={prenom}
        onChangeText={setPrenom}
      />
      <TextInput
        style={styles.input}
        placeholder="Age"
        value={age}
        onChangeText={setAge}
        keyboardType="numeric"
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        style={styles.input}
        placeholder="Telephone"
        value={tel}
        onChangeText={setTel}
        keyboardType="numeric"
      />

      <Button title="Soumettre" onPress={handleSubmit} />
    </View>
  );
};

const styles = StyleSheet.create({completet le style});

export default StudentForm;
\end{lstlisting}
\end{tcolorbox}




AVEC formData
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';

export default function StudentForm() {
  const [nom, setNom] = useState('');
  const [prenom, setPrenom] = useState('');
  const [age, setAge] = useState('');
  const [email, setEmail] = useState('');
  const [tel, setTel] = useState('');

  const handleSubmit = async () => {
    if (!nom || !prenom || !age || !email || !tel) {
      Alert.alert('Erreur', 'Veuillez remplir tous les champs.');
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert('Erreur', 'Veuillez entrer une adresse email valide.');
      return;
    }

    if (tel.length < 8 || isNaN(tel)) {
      Alert.alert('Erreur', 'Veuillez entrer un numero de telephone valide (au moins 8 chiffres).');
      return;
    }

    const studentData = {
      nom,
      prenom,
      age: parseInt(age),
      email,
      tel,
    };

    try {
      const response = await fetch('VOTRE_URL_API/students', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(studentData),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.message || 'Echec de la soumission du formulaire.');
      }

      const responseData = await response.json();
      Alert.alert('Succes', 'Donnees de l etudiant soumises avec succes !');
      console.log('Reponse de l API :', responseData);

      setNom('');
      setPrenom('');
      setAge('');
      setEmail('');
      setTel('');

    } catch (error) {
      console.error('Erreur lors de la soumission :', error);
      Alert.alert('Erreur', `Probleme lors de la soumission : ${error.message}`);
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Formulaire Etudiant</Text>

      <TextInput
        style={styles.input}
        placeholder="Nom"
        value={nom}
        onChangeText={setNom}
      />
      <TextInput
        style={styles.input}
        placeholder="Prenom"
        value={prenom}
        onChangeText={setPrenom}
      />
      <TextInput
        style={styles.input}
        placeholder="Age"
        value={age}
        onChangeText={setAge}
        keyboardType="numeric"
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        style={styles.input}
        placeholder="Telephone"
        value={tel}
        onChangeText={setTel}
        keyboardType="numeric"
      />

      <Button title="Soumettre" onPress={handleSubmit} />
    </View>
  );
};


\end{lstlisting}
\end{tcolorbox}

Avec Axios
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';
import axios from 'axios';

export default function StudentForm() {
  const [nom, setNom] = useState('');
  const [prenom, setPrenom] = useState('');
  const [age, setAge] = useState('');
  const [email, setEmail] = useState('');
  const [tel, setTel] = useState('');

  const handleSubmit = async () => {
    if (!nom || !prenom || !age || !email || !tel) {
      Alert.alert('Erreur', 'Veuillez remplir tous les champs.');
      return;
    }

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email)) {
      Alert.alert('Erreur', 'Veuillez entrer une adresse email valide.');
      return;
    }

    if (tel.length < 8 || isNaN(tel)) {
      Alert.alert('Erreur', 'Veuillez entrer un numero de telephone valide (au moins 8 chiffres).');
      return;
    }

    const studentData = {
      nom,
      prenom,
      age: parseInt(age),
      email,
      tel,
    };

    try {
      const response = await axios.post('VOTRE_URL_API/students', studentData);

      Alert.alert('Succes', 'Donnees de l etudiant soumises avec succes !');
      console.log('Reponse de l API :', response.data);

      setNom('');
      setPrenom('');
      setAge('');
      setEmail('');
      setTel('');

    } catch (error) {
      console.error('Erreur lors de la soumission :', error);
      if (error.response) {
        Alert.alert('Erreur', `Probleme lors de la soumission : ${error.response.data.message || 'Erreur serveur.'}`);
      } else if (error.request) {
        Alert.alert('Erreur', 'Impossible de connecter au serveur. Verifiez votre connexion internet.');
      } else {
        Alert.alert('Erreur', `Une erreur inattendue est survenue : ${error.message}`);
      }
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Formulaire Etudiant</Text>

      <TextInput
        style={styles.input}
        placeholder="Nom"
        value={nom}
        onChangeText={setNom}
      />
      <TextInput
        style={styles.input}
        placeholder="Prenom"
        value={prenom}
        onChangeText={setPrenom}
      />
      <TextInput
        style={styles.input}
        placeholder="Age"
        value={age}
        onChangeText={setAge}
        keyboardType="numeric"
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        style={styles.input}
        placeholder="Telephone"
        value={tel}
        onChangeText={setTel}
        keyboardType="numeric"
      />

      <Button title="Soumettre" onPress={handleSubmit} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
    backgroundColor: '#f5f5f5',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 30,
    textAlign: 'center',
  },
  input: {
    height: 50,
    borderColor: '#ccc',
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 15,
    marginBottom: 15,
    backgroundColor: '#fff',
    fontSize: 16,
  },
});

export default StudentForm;
\end{lstlisting}
\end{tcolorbox}

\subsubsection(axios et formData)

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet, Alert } from 'react-native';
import axios from 'axios';

export default function StudentForm() {
  const [nom, setNom] = useState('');
  const [prenom, setPrenom] = useState('');
  const [age, setAge] = useState('');
  const [email, setEmail] = useState('');
  const [tel, setTel] = useState('');

  const handleSubmit = async () => {
    if (!nom || !prenom || !age || !email || !tel) {
      Alert.alert('Erreur', 'Veuillez remplir tous les champs.');
      return;
    }

    const emailRegex = /^[^\s@]+\@[^\s@]+\.[^\s@]+\$/;
    if (!emailRegex.test(email)) {
      Alert.alert('Erreur', 'Veuillez entrer une adresse email valide.');
      return;
    }

    if (tel.length < 8 || isNaN(tel)) {
      Alert.alert('Erreur', 'Veuillez entrer un num\'ero de t\'el\'ephone valide (au moins 8 chiffres).');
      return;
    }

    const formData = new FormData();
    formData.append('nom', nom);
    formData.append('prenom', prenom);
    formData.append('age', parseInt(age));
    formData.append('email', email);
    formData.append('tel', tel);

    try {
      const response = await axios.post('VOTRE\_URL\_API/students', formData);

      Alert.alert('Succ\'es', 'Donn\'ees de l\'\'etudiant soumises avec succ\'es !');
      console.log('R\'eponse de l\'API :', response.data);

      setNom('');
      setPrenom('');
      setAge('');
      setEmail('');
      setTel('');

    } catch (error) {
      console.error('Erreur lors de la soumission :', error);
      if (error.response) {
        Alert.alert('Erreur', `Probl\'eme lors de la soumission : ${error.response.data.message || 'Erreur serveur.'}`);
      } else if (error.request) {
        Alert.alert('Erreur', 'Impossible de se connecter au serveur. V\'erifiez votre connexion internet.');
      } else {
        Alert.alert('Erreur', `Une erreur inattendue est survenue : ${error.message}`);
      }
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Formulaire \'Etudiant</Text>

      <TextInput
        style={styles.input}
        placeholder="Nom"
        value={nom}
        onChangeText={setNom}
      />
      <TextInput
        style={styles.input}
        placeholder="Pr\'enom"
        value={prenom}
        onChangeText={setPrenom}
      />
      <TextInput
        style={styles.input}
        placeholder="Ages"
        value={age}
        onChangeText={setAge}
        keyboardType="numeric"
      />
      <TextInput
        style={styles.input}
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        keyboardType="email-address"
        autoCapitalize="none"
      />
      <TextInput
        style={styles.input}
        placeholder="T\'el\'ephone"
        value={tel}
        onChangeText={setTel}
        keyboardType="numeric"
      />

      <Button title="Soumettre" onPress={handleSubmit} />
    </View>
  );
};

\end{lstlisting}
\end{tcolorbox}


\subsection{Récuperation des données}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, ActivityIndicator, StyleSheet, Alert } from 'react-native';

const API_URL = 'VOTRE\_URL\_API/students';

export default StudentListFetch() {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchStudents = async () => {
      try {
        const response = await fetch(API_URL);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        setStudents(data);
      } catch (err) {
        console.error("Erreur lors de la r\'ecup\'eration des donn\'ees avec Fetch:", err);
        setError(err.message);
        Alert.alert('Erreur de chargement', `Impossible de charger les donn\'ees : ${err.message}`);
      } finally {
        setLoading(false);
      }
    };

    fetchStudents();
  }, []);

  const renderStudentItem = ({ item }) => (
    <View style={styles.itemContainer}>
      <Text style={styles.itemText}>Nom: {item.nom} {item.prenom}</Text>
      <Text style={styles.itemText}>Ages: {item.age}</Text>
      <Text style={styles.itemText}>Email: {item.email}</Text>
      <Text style={styles.itemText}>T\'el: {item.tel}</Text>
    </View>
  );

  if (loading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color="\#0000ff" />
        <Text>Chargement des \'etudiants...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>Erreur: {error}</Text>
        <Text>Veuillez v\'erifier votre connexion ou l\'URL de l\'API.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Liste des \'Etudiants (Fetch)</Text>
      {students.length === 0 ? (
        <Text style={styles.noDataText}>Aucun \'etudiant trouv\'e.</Text>
      ) : (
        <FlatList
          data={students}
          keyExtractor={(item, index) => item.id ? item.id.toString() : index.toString()}
          renderItem={renderStudentItem}
          contentContainerStyle={styles.listContent}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '\#f5f5f5',
    paddingTop: 50,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '\#f5f5f5',
  },
  errorText: {
    color: 'red',
    fontSize: 18,
    marginBottom: 10,
  },
  itemContainer: {
    backgroundColor: '\#fff',
    padding: 15,
    borderRadius: 8,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '\#ddd',
  },
  itemText: {
    fontSize: 16,
    marginBottom: 4,
  },
  listContent: {
    paddingBottom: 20,
  },
  noDataText: {
    textAlign: 'center',
    fontSize: 18,
    marginTop: 50,
    color: '\#666',
  },
});

\end{lstlisting}
\end{tcolorbox}




\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import React, { useState, useEffect } from 'react';
import { View, Text, ScrollView, ActivityIndicator, StyleSheet, Alert } from 'react-native';

const API_URL = 'VOTRE_URL_API/students';

export default StudentListFetchScrollView() {
  const [students, setStudents] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchStudents = async () => {
      try {
        const response = await fetch(API_URL);
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        setStudents(data);
      } catch (err) {
        console.error("Erreur lors de la recup\'eration des donn\'ees avec Fetch:", err);
        setError(err.message);
        Alert.alert('Erreur de chargement', `Impossible de charger les donn\'ees : ${err.message}`);
      } finally {
        setLoading(false);
      }
    };

    fetchStudents();
  }, []);

  if (loading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color="#0000ff" />
        <Text>Chargement des \'etudiants...</Text>
      </View>
    );
  }

  if (error) {
    return (
      <View style={styles.centered}>
        <Text style={styles.errorText}>Erreur: {error}</Text>
        <Text>Veuillez v\'erifier votre connexion ou l'URL de l'API.</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Liste des Etudiants (Fetch avec ScrollView)</Text>
      {students.length === 0 ? (
        <Text style={styles.noDataText}>Aucun \'etudiant trouv\'e.</Text>
      ) : (
        <ScrollView contentContainerStyle={styles.scrollViewContent}>
          {students.map((item) => (
            <View key={item.id ? item.id.toString() : Math.random().toString()} style={styles.itemContainer}>
              <Text style={styles.itemText}>Nom: {item.nom} {item.prenom}</Text>
              <Text style={styles.itemText}>Age: {item.age}</Text>
              <Text style={styles.itemText}>Email: {item.email}</Text>
              <Text style={styles.itemText}>T\'elephone: {item.tel}</Text>
            </View>
          ))}
        </ScrollView>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    backgroundColor: '#f5f5f5',
    paddingTop: 50,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 20,
    textAlign: 'center',
  },
  centered: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f5f5f5',
  },
  errorText: {
    color: 'red',
    fontSize: 18,
    marginBottom: 10,
  },
  scrollViewContent: {
    paddingBottom: 20,
  },
  itemContainer: {
    backgroundColor: '#fff',
    padding: 15,
    borderRadius: 8,
    marginBottom: 10,
    borderWidth: 1,
    borderColor: '#ddd',
  },
  itemText: {
    fontSize: 16,
    marginBottom: 4,
  },
  noDataText: {
    textAlign: 'center',
    fontSize: 18,
    marginTop: 50,
    color: '#666',
  },
});

\end{lstlisting}
\end{tcolorbox}


\subsection{Gestion des formulaires : Formik et Yup}
Formik est une bibliothèque populaire pour la gestion des formulaires dans les applications React.
Elle aide les développeurs à gérer l'état des formulaires, la validation et la soumission des données de manière efficace et avec moins de code boilerplate.
Formik est souvent utilisé en combinaison avec d'autres bibliothèques comme Yup pour la validation des schémas. \href{https://formik.org/}{https://formik.org/}

\subsubsection{Composants de Formik :props et methodes}

\begin{itemize}
    \item \textbf{\textcolor{gray}{\textless Formik /\textgreater}}
    \begin{itemize}
        \item \textbf{\textcolor{gray}{Props}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{initialValues: object}}
            \item \texttt{\textcolor{gray}{onSubmit: function}}
            \item \texttt{\textcolor{gray}{validationSchema: object}}
            \item \texttt{\textcolor{gray}{validate: function}}
            \item \texttt{\textcolor{gray}{enableReinitialize: boolean}}
            \item \texttt{\textcolor{gray}{isInitialValid: boolean | function}}
            \item \texttt{\textcolor{gray}{initialErrors: object}}
            \item \texttt{\textcolor{gray}{initialTouched: object}}
            \item \texttt{\textcolor{gray}{initialStatus: any}}
            \item \texttt{\textcolor{gray}{validateOnChange: boolean}}
            \item \texttt{\textcolor{gray}{validateOnBlur: boolean}}
            \item \texttt{\textcolor{gray}{validateOnMount: boolean}}
            \item \texttt{\textcolor{gray}{isValidating: boolean}}
        \end{itemize}
        \item \textbf{\textcolor{gray}{Méthodes}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{handleSubmit: function: void}}
            \item \texttt{\textcolor{gray}{handleChange: function: void}}
            \item \texttt{\textcolor{gray}{handleBlur: function: void}}
            \item \texttt{\textcolor{gray}{setFieldValue: function: void}}
            \item \texttt{\textcolor{gray}{setFieldTouched: function: void}}
            \item \texttt{\textcolor{gray}{setFormikState: function: void}}
            \item \texttt{\textcolor{gray}{resetForm: function: void}}
            \item \texttt{\textcolor{gray}{setStatus: function: void}}
            \item \texttt{\textcolor{gray}{setErrors: function: void}}
            \item \texttt{\textcolor{gray}{setTouched: function: void}}
            \item \texttt{\textcolor{gray}{validateForm: function: void}}
            \item \texttt{\textcolor{gray}{validateField: function: void}}
        \end{itemize}
    \end{itemize}

    \item \textbf{\textcolor{gray}{\textless Field /\textgreater}}
    \begin{itemize}
        \item \textbf{\textcolor{gray}{Props}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{name: string}}
            \item \texttt{\textcolor{gray}{type: string}}
            \item \texttt{\textcolor{gray}{component: string | React.Component}}
            \item \texttt{\textcolor{gray}{validate: function}}
            \item \texttt{\textcolor{gray}{value: any}}
            \item \texttt{\textcolor{gray}{onChange: function}}
            \item \texttt{\textcolor{gray}{onBlur: function}}
        \end{itemize}
        \item \textbf{\textcolor{gray}{Méthodes}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{onChange: function: void}}
            \item \texttt{\textcolor{gray}{onBlur: function: void}}
        \end{itemize}
    \end{itemize}

    \item \textbf{\textcolor{gray}{\textless Form /\textgreater}}
    \begin{itemize}
        \item \textbf{\textcolor{gray}{Props}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{children: React.ReactNode}}
        \end{itemize}
        \item \textbf{\textcolor{gray}{Méthodes}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{handleSubmit: function: void}}
        \end{itemize}
    \end{itemize}

    \item \textbf{\textcolor{gray}{\textless ErrorMessage /\textgreater}}
    \begin{itemize}
        \item \textbf{\textcolor{gray}{Props}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{name: string}}
            \item \texttt{\textcolor{gray}{component: string | React.Component}}
            \item \texttt{\textcolor{gray}{className: string}}
        \end{itemize}
        \item \textbf{\textcolor{gray}{Méthodes}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{Aucune méthode spécifique}}
        \end{itemize}
    \end{itemize}

    \item \textbf{\textcolor{gray}{withFormik()}}
    \begin{itemize}
        \item \textbf{\textcolor{gray}{Props}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{mapPropsToValues: function}}
            \item \texttt{\textcolor{gray}{validate: function}}
            \item \texttt{\textcolor{gray}{handleSubmit: function}}
            \item \texttt{\textcolor{gray}{displayName: string}}
            \item \texttt{\textcolor{gray}{enableReinitialize: boolean}}
            \item \texttt{\textcolor{gray}{isInitialValid: boolean | function}}
            \item \texttt{\textcolor{gray}{mapPropsToStatus: function}}
            \item \texttt{\textcolor{gray}{mapPropsToErrors: function}}
            \item \texttt{\textcolor{gray}{mapPropsToTouched: function}}
        \end{itemize}
        \item \textbf{\textcolor{gray}{Méthodes}}
        \begin{itemize}
            \item \texttt{\textcolor{gray}{setFieldValue: function: void}}
            \item \texttt{\textcolor{gray}{setFieldTouched: function: void}}
            \item \texttt{\textcolor{gray}{setFormikState: function: void}}
            \item \texttt{\textcolor{gray}{resetForm: function: void}}
            \item \texttt{\textcolor{gray}{setStatus: function: void}}
            \item \texttt{\textcolor{gray}{setErrors: function: void}}
            \item \texttt{\textcolor{gray}{setTouched: function: void}}
            \item \texttt{\textcolor{gray}{validateForm: function: void}}
            \item \texttt{\textcolor{gray}{validateField: function: void}}
        \end{itemize}
    \end{itemize}
\end{itemize}

\textbf{Documentation de l API formik}: \href{https://formik.org/docs/api/connect}{https://formik.org/docs/api/connect}

\subsubsection{Yup}
Yup est une bibliothèque de validation de schéma pour JavaScript qui est souvent utilisée avec Formik pour valider les données des formulaires.
Elle permet de définir des schémas de validation de manière déclarative et de valider les objets JavaScript selon ces schémas. \newline

Yup est particulièrement utile pour s'assurer que les données saisies dans un formulaire respectent certaines règles avant la soumission.
Par exemple, vous pouvez définir des règles pour s'assurer qu'un champ est requis, qu'il a une certaine longueur, qu'il correspond à un format spécifique (comme un email), etc.

\begin{jscode}
import React from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  name: Yup.string()
    .required('Name is required')
    .min(2, 'Name must be at least 2 characters'),
  email: Yup.string()
    .email('Invalid email')
    .required('Email is required'),
  password: Yup.string()
    .required('Password is required')
    .min(8, 'Password must be at least 8 characters'),
});

const MyForm = () => {
  return (
    <Formik
      initialValues={{ name: '', email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => {
        console.log(values);
      }}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors, touched, isSubmitting }) => (
        <View style={styles.container}>
          <View style={styles.inputContainer}>
            <Text style={styles.label}>Name</Text>
            <TextInput
              onChangeText={handleChange('name')}
              onBlur={handleBlur('name')}
              value={values.name}
              style={styles.input}
            />
            {errors.name && touched.name && <Text style={styles.error}>{errors.name}</Text>}
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Email</Text>
            <TextInput
              onChangeText={handleChange('email')}
              onBlur={handleBlur('email')}
              value={values.email}
              keyboardType="email-address"
              style={styles.input}
            />
            {errors.email && touched.email && <Text style={styles.error}>{errors.email}</Text>}
          </View>

          <View style={styles.inputContainer}>
            <Text style={styles.label}>Password</Text>
            <TextInput
              onChangeText={handleChange('password')}
              onBlur={handleBlur('password')}
              value={values.password}
              secureTextEntry
              style={styles.input}
            />
            {errors.password && touched.password && <Text style={styles.error}>{errors.password}</Text>}
          </View>

          <Button onPress={handleSubmit} title="Submit" disabled={isSubmitting} />
        </View>
      )}
    </Formik>
  );
};

const styles = StyleSheet.create({style ici ...});

export default MyForm;

\end{jscode}

\textbf{Documentation Yup :} \href{https://yup-docs.vercel.app/docs/intro}{https://yup-docs.vercel.app/docs/intro}

\subsubsection{Zod}

Zod est une bibliothèque de validation de schémas TypeScript-first qui permet de déclarer et valider des structures de données avec une excellente inférence de types.
Contrairement à Yup, Zod est conçu spécifiquement pour TypeScript et offre une meilleure intégration avec le système de types, tout en restant compatible avec React Native. 
Zod est particulièrement apprécié pour sa syntaxe chainable, sa légèreté (pas de dépendances) et sa performance.
\newline Point fort : les schémas sont \textcolor{red}{réutilisables} dans une API (API Node.js par exemple) dans le cas du développement front séparé du backend.

\textbf{Zod permet de :}
\begin{enumerate}
    \item Valider des types primitifs (string, number, boolean, date, etc.)
    \item Définir des validations personnalisées avec des messages d'erreur spécifiques
    \item Créer des schémas d'objets complexes et imbriqués
    \item Valider des tableaux avec des règles sur les éléments et la longueur
    \item Appliquer des transformations de données (parsing, coercion, default values)
    \item Composer et étendre des schémas existants (merge, extend, pick, omit)
    \item Gérer des unions et intersections de types
    \item Valider des données optionnelles et nullables
    \item Inférer automatiquement les types TypeScript depuis les schémas
    \item Générer des messages d'erreur détaillés et structurés
\end{enumerate}
\textbf{Documentation}:\href{https://zod.dev/}{https://zod.dev/}

\begin{jscode}
import { z } from 'zod';
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';

const validationSchema = z.object({
  name: z.string()
    .min(2, { message: 'Name must be at least 2 characters' })
    .nonempty({ message: 'Name is required' }),
  email: z.
    .email({ message: 'Invalid email' })
    .nonempty({ message: 'Email is required' }),
  password: z.string()
    .min(8, { message: 'Password must be at least 8 characters' })
    .nonempty({ message: 'Password is required' }),
});

export default function MyForm() {
  const [values, setValues] = useState({ name: '', email: '', password: '' });
  const [errors, setErrors] = useState({});

  const handleChange = (field, value) => {
    setValues({ ...values, [field]: value });
  };

  const handleSubmit = () => {
    try {
      validationSchema.parse(values);
      console.log('Form is valid:', values);
      setErrors({});
    } catch (error) {
      if (error instanceof z.ZodError) {
        const formattedErrors = {};
        error.errors.forEach((err) => {
          formattedErrors[err.path[0]] = err.message;
        });
        setErrors(formattedErrors);
      }
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.inputContainer}>
        <Text style={styles.label}>Name</Text>
        <TextInput
          onChangeText={(text) => handleChange('name', text)}
          value={values.name}
          style={styles.input}
        />
        {errors.name && <Text style={styles.error}>{errors.name}</Text>}
      </View>

      <View style={styles.inputContainer}>
        <Text style={styles.label}>Email</Text>
        <TextInput
          onChangeText={(text) => handleChange('email', text)}
          value={values.email}
          keyboardType="email-address"
          style={styles.input}
        />
        {errors.email && <Text style={styles.error}>{errors.email}</Text>}
      </View>

      <View style={styles.inputContainer}>
        <Text style={styles.label}>Password</Text>
        <TextInput
          onChangeText={(text) => handleChange('password', text)}
          value={values.password}
          secureTextEntry
          style={styles.input}
        />
        {errors.password && <Text style={styles.error}>{errors.password}</Text>}
      </View>

      <Button onPress={handleSubmit} title="Submit" />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  inputContainer: {
    marginBottom: 15,
  },
  label: {
    fontSize: 16,
    marginBottom: 5,
    fontWeight: '500',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ddd',
    padding: 10,
    borderRadius: 5,
    fontSize: 16,
  },
  error: {
    color: 'red',
    fontSize: 12,
    marginTop: 5,
  },
});


\end{jscode}


\section{Fonctionnalités Navite en Expo}

Les fonctionnalités natives dans Expo (basé sur React Native) permettent d'accéder à des capacités spécifiques des appareils (comme la caméra, les notifications, ou le GPS) tout en restant dans l'écosystème Expo.
Voici un aperçu des principales fonctionnalités natives prises en charge :

\begin{itemize}
\item \textbf{Caméra et média}: Utilisation de la caméra pour prendre des photos ou des vidéos, et gestion des galeries avec des API comme \textcolor{gray}{expo-camera} et \textcolor{gray}{expo-media-library}.
\item \textbf{Notifications}: Envoi et gestion de notifications push via \textcolor{gray}{expo-notifications}, y compris la planification et la personnalisation.
\item \textbf{Localisation}: Accès au GPS et aux données de géolocalisation avec \textcolor{gray}{expo-location}.
\item \textbf{Capteurs}: Accès aux capteurs comme l'accéléromètre, le gyroscope ou le magnétomètre via \textcolor{gray}{expo-sensors}.
\item \textbf{Stockage et fichiers}: Gestion des fichiers locaux avec \textcolor{gray}{expo-file-system} et interaction avec le système de fichiers.
\item \textbf{Authentification}: Intégration avec des services comme Apple Sign-In ou Google Sign-In via \textcolor{gray}{expo-auth-session}.
\item \textbf{Audio et vidéo}: Lecture et enregistrement audio/vidéo avec \textcolor{gray}{expo-av}.
\item \textbf{Bluetooth et réseau}: Communication via Bluetooth ou gestion des connexions réseau avec \textcolor{gray}{expo-ble} et autres modules.
\end{itemize}



\section*{Comment sa marche ?}
Pour mettre en place l une des ces fonctionnalité , vous suffit de vous rendre sur le documentation oficiel d \href{https://docs.expo.dev/versions/latest/}{Expo} ,
Trouver et Télécharger le package souhaité ensuite ,suivez les instructions .

\section*{Exemple d'utilisation d'expo-camera}
Rendez-vous à l'adresse : \href{https://docs.expo.dev/versions/latest/sdk/camera/}{https://docs.expo.dev/versions/latest/sdk/camera/} ou tapez "expo camera" dans la recherche.

\begin{enumerate}
  \item \textbf{Téléchargez le skd expo-camera}: Téléchargez expo-camera 
  \subitem \textcolor{gray}{npx expo install expo-camera}
  \item \textbf{Configurez le fichier app.json}:Configurez les permissions pour l usage dans la camera comme suit.
\end{enumerate}


\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "expo": {
    "plugins": [
      [
        "expo-camera",
        {
          "cameraPermission": "Allow $(PRODUCT_NAME) to access your camera",
          "microphonePermission": "Allow $(PRODUCT_NAME) to access your microphone",
          "recordAudioAndroid": true
        }
      ]
    ]
  }
}
\end{lstlisting}
\end{tcolorbox}


\begin{jscode}
import { CameraView, CameraType, useCameraPermissions } from 'expo-camera';
import { useState } from 'react';
import { Button, StyleSheet, Text, TouchableOpacity, View } from 'react-native';

export default function App() {
  const [facing, setFacing] = useState<CameraType>('back');
  const [permission, requestPermission] = useCameraPermissions();

  if (!permission) {
    return <View />;
  }

  if (!permission.granted) {
    return (
      <View style={styles.container}>
        <Text style={styles.message}>We need your permission to show the camera</Text>
        <Button onPress={requestPermission} title="grant permission" />
      </View>
    );
  }

  function toggleCameraFacing() {
    setFacing(current => (current === 'back' ? 'front' : 'back'));
  }

  return (
    <View style={styles.container}>
      <CameraView style={styles.camera} facing={facing}>
        <View style={styles.buttonContainer}>
          <TouchableOpacity style={styles.button} onPress={toggleCameraFacing}>
            <Text style={styles.text}>Flip Camera</Text>
          </TouchableOpacity>
        </View>
      </CameraView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
  },
  message: {
    textAlign: 'center',
    paddingBottom: 10,
  },
  camera: {
    flex: 1,
  },
  buttonContainer: {
    flex: 1,
    flexDirection: 'row',
    backgroundColor: 'transparent',
    margin: 64,
  },
  button: {
    flex: 1,
    alignSelf: 'flex-end',
    alignItems: 'center',
  },
  text: {
    fontSize: 24,
    fontWeight: 'bold',
    color: 'white',
  },
});

\end{jscode}













\section{Expo + Supabase}
Supabase est une plateforme open-source qui fournit une alternative moderne aux backend-as-a-service (BaaS) comme Firebase. Elle offre une suite d'outils pour développer des applications, notamment :\newline

\begin{figure}[H]
    \centering
    \includegraphics[width=0.10\textwidth]{supabase.png}
    \caption{Supabase logo}
    \label{fig:Supabase}
\end{figure}


\begin{itemize}
\item \textcolor{gray}{Base de données}: Une base de données PostgreSQL hébergée, avec des fonctionnalités comme les requêtes SQL et les relations.
\item \textcolor{gray}{Authentification}: Gestion des utilisateurs avec des options comme email/mot de passe, OAuth (Google, GitHub, etc.), et magie link.
\item \textcolor{gray}{Stockage}: Un système pour uploader, gérer et servir des fichiers.
\item \textcolor{gray}{API en temps réel}: Mise à jour des données en direct via WebSocket.
\item \textcolor{gray}{Fonctions serveur}: Exécution de logique personnalisée côté serveur.
\end{itemize}

\section{Expo + firebase}
Firebase est une plateforme Backend-as-a-Service (BaaS) offrant des services comme la base de données en temps réel, le stockage cloud, l'authentification et l'analyse.
Cette section decrit l integration de Firebase dans un projet Expo en utilisant le Firebase JS SDK, basee sur la documentation officielle.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.08\textwidth]{firebase2.png}
    \caption{firebase logo}
    \label{fig:firebase}
\end{figure}

\begin{itemize}
\item \textcolor{gray}{Base de données en temps réel}: Une base de données NoSQL hébergée permettant des synchronisations en temps réel via WebSocket.
\item \textcolor{gray}{Stockage cloud}: Un système pour uploader, stocker et servir des fichiers comme des images ou vidéos.
\item \textcolor{gray}{Authentification}: Gestion des utilisateurs avec des options comme email/mot de passe, OAuth (Google, Facebook, etc.), et anonyme.
\item \textcolor{gray}{Analyse}: Outils pour suivre l'utilisation de l'application et le comportement des utilisateurs.
\item \textcolor{gray}{Notifications push}: Envoi de notifications ciblées aux utilisateurs via Firebase Cloud Messaging (FCM).
\item \textcolor{gray}{Fonctions cloud}: Exécution de code côté serveur sans gérer d'infrastructure.
\item \textcolor{gray}{Machine Learning}: Intégration de modèles d'apprentissage automatique pour des fonctionnalités comme la reconnaissance d'image.
\end{itemize}


\subsection{Intégration de Firebase avec Expo}

\begin{enumerate}
  \item \textbf{Créer un projet Firebase}
\end{enumerate}

Creer un nouveau projet Firebase ou un projet existant via la console:
\url{https://console.firebase.google.com/}.

\vspace{0.5cm}

\begin{enumerate}
  \item[2.] \textbf{Installer le Firebase JS SDK}
\end{enumerate}

\begin{jscode}
npx expo install firebase
\end{jscode}


\textcolor{gray}{Cette commande installe le SDK Firebase JS pour interagir avec les services Firebase comme l authentification, Firestore, la base de donnees en temps reel et le stockage.}

\vspace{0.5cm}

\begin{enumerate}
  \item[3.] \textbf{Initialiser Firebase dans votre projet}
\end{enumerate}

Creer un fichier \texttt{firebaseConfig.js} dans le repertoire racine de votre projet et initialiser Firebase avec les identifiants de votre projet.

\begin{jscode}
import { initializeApp } from 'firebase/app';

// Configurer les services Firebase desires
// import {...} from 'firebase/auth';
// import {...} from 'firebase/firestore';
// import {...} from 'firebase/database';
// import {...} from 'firebase/storage';

const firebaseConfig = {
  apiKey: 'api-key',
  authDomain: 'project-id.firebaseapp.com',
  databaseURL: 'https://project-id.firebaseio.com',
  projectId: 'project-id',
  storageBucket: 'project-id.appspot.com',
  messagingSenderId: 'sender-id',
  appId: 'app-id',
  measurementId: 'G-measurement-id',
};

const app = initializeApp(firebaseConfig);
\end{jscode}

\textcolor{gray}{Obtenez les identifiants (apiKey, projectId, etc.) en enregistrant une application web dans la console Firebase. Aucun plugin supplémentaire n'est requis pour le Firebase JS SDK.}

\vspace{0.5cm}

\begin{enumerate}
  \item[4.] \textbf{Configurer Metro pour Firebase 9.7.x et superieur}
\end{enumerate}

Générer et mettre à jour le fichier \texttt{metro.config.js} pour assurer un bundling correct du SDK Firebase.
\begin{jscode}
npx expo customize metro.config.js
\end{jscode}

\begin{jscode}
const { getDefaultConfig } = require('@expo/metro-config');

const config = getDefaultConfig(__dirname);
config.resolver.sourceExts.push('cjs');
config.resolver.unstable_enablePackageExports = false;

module.exports = config;
\end{jscode}
\textcolor{gray}{Cette configuration ajoute le support pour les extensions de fichiers CJS, necessaire pour Firebase 9.7.x et plus.} 

\vspace{0.5cm}

\begin{enumerate}
  \item[5.] \textbf{Utiliser les services Firebase}
\end{enumerate}
Importer et utiliser les services Firebase desires, comme Firestore ou autre, directement dans votre projet.
\begin{jscode}
import { getFirestore, collection, addDoc } from 'firebase/firestore';

const db = getFirestore(app);

async function addUser(name, age) {
  try {
    await addDoc(collection(db, 'users'), {
      name: name,
      age: age,
      createdAt: new Date(),
    });
    console.log('Utilisateur ajoute avec succes');
  } catch (e) {
    console.error('Erreur lors de l ajout : ', e);
  }
}
\end{jscode}

\textcolor{gray}{Cet exemple montre comment ajouter un utilisateur a une collection Firestore. Importez uniquement les modules necessaires pour reduire la taille du bundle.}



\section{Gestion des erreures}



\section{Bibliotheques et Gestion des bibliotheques externes}
\subsection{Gestion des bibliothèques externes}
Les problèmes majeurs qui vous donneront l'envie de vous passer de React Native sont l'incompatibilité des packages et l'obsolescence 
de certains. C'est pour cette raison que je vous invite à suivre ce workflow lorsque vous avez déjà créé votre projet, fait des 
installations et que vous avez passé une petite période d'arrêt de développement. Il est commun que le SDK d'Expo soit mis à jour
en consequence certains packages avec . Voici le workflow à suivre en cas de reprise :\newline

\begin{enumerate}
\item \textbf{Vérifiez la version actuelle de votre package manager préféré}:
\subitem \textcolor{gray600}{npm -version ou npm --version}
\subitem \textcolor{gray600}{pnpm -version ou pnpm --version}
\subitem \textcolor{gray600}{yarn -version ou yarn --version}
\subitem \textcolor{gray600}{bun -version ou bun --version}  \newline
\item \textbf{Vérifiez la dernière version de votre package manager préféré}:
\subitem \textcolor{gray600}{npm view npm version}
\subitem \textcolor{gray600}{npm view pnpm version}
\subitem \textcolor{gray600}{npm view yarn version}
\subitem \textcolor{gray600}{npm view bun version}  \newline
\item \textbf{Mettez à jour votre gestionnaire si nécessaire}:
\subitem \textcolor{gray600}{npm install -g npm@latest}
\subitem \textcolor{gray600}{npm install -g pnpm@latest}
\subitem \textcolor{gray600}{npm install -g yarn@latest}
\subitem \textcolor{gray600}{npm install -g bun@latest}  \newline
\item \textbf{ vérification et mises à jour du SDK d'Expo avant le démarrage du serveur}:
\subitem \textcolor{gray600}{npx expo-cli --version}
\subitem \textcolor{gray600}{npm show expo-cli version}
\subitem \textcolor{gray600}{npx expo --version}  \
\subitem \textcolor{gray600}{npx expo install expo@latest}: mise a jour de laderniere version
\subitem \textcolor{gray600}{npx expo install --fix}: mettre à jour toutes les dépendances liées à la dernière version installée
\subitem \textcolor{gray600}{npx expo install expo@\^53.0.0}: specification d une version particuliere \newline
\item \textbf{Toujours vérifier les packages obsolètes}:
\subitem \textcolor{gray600}{npm outdated}
\subitem \textcolor{gray600}{pnpm outdated}
\subitem \textcolor{gray600}{yarn outdated}  \newline
\item \textbf{Lister les packages installés et leurs dépendances}:
\subitem \textcolor{gray600}{npm list}
\subitem \textcolor{gray600}{npm list --depth=2}
\subitem \textcolor{gray600}{npm list --all}
\subitem \textcolor{gray600}{npm list --production}
\subitem \textcolor{gray600}{npm list --dev}
\subitem \textcolor{gray600}{npm list --global} \newline
\item \textbf{Vider le cache d'Expo}:
\subitem \textcolor{gray600}{npx expo start -c}
\subitem \textcolor{gray600}{npx expo start --clear} \newline
\item \textbf{Vider le cache de votre gestionnaire de dépendances}:
\subitem \textcolor{gray600}{npm cache clean --force}
\subitem \textcolor{gray600}{pnpm store prune}
\subitem \textcolor{gray600}{yarn cache clean}
\subitem \textcolor{gray600}{bun pm cache rm}  \newline
\item \textbf{Suppression du dossier node\_modules}:
\subitem \textcolor{gray600}{Suppression de node\_modules en cas de probleme (invite de commande)}
\subitem \textcolor{gray600}{Remove-Item -Recurse -Force node\_modules (PowerShell)}
\subitem \textcolor{gray600}{Remove-Item -Force package-lock.json (PowerShell)}
\subitem \textcolor{gray600}{rm -rf node\_modules (Linux/macOS)}
\subitem \textcolor{gray600}{rm package-lock.json (Linux/macOS)}
\end{enumerate}




\subsection{Bibliotheques}

\section*{Navigation}
Navigation fluide et intuitive pour vos applications \newline
\begin{itemize}
    \item \textbf{\texttt{@react-navigation/native}}: Solution de navigation la plus populaire pour React Native.
    \subitem \href{https://reactnavigation.org/}{https://reactnavigation.org/}
    \item \textbf{\texttt{react-native-navigation}}: Navigation native haute performance par Wix.
    \subitem \href{https://wix.github.io/react-native-navigation/}{https://wix.github.io/react-native-navigation/}
    \item \textbf{\texttt{react-router-native}}: Routage d\'eclaratif pour React Native.
    \subitem \href{https://reactrouter.com/native}{https://reactrouter.com/native}
\end{itemize}

\section*{Interface Utilisateur UI}
Composants et biblioth\`eques pour cr\'eer des interfaces modernes \newline
\begin{itemize}
    \item \textbf{\texttt{React Native Paper}}: une des bibliotheque connu a ce jour react native avec plusieur composants
    \subitem \href{https://callstack.github.io/react-native-paper/}{https://callstack.github.io/react-native-paper/}
    \item \textbf{\texttt{react-native-reusables (rnr)}}: Decouvrez l equivalent de \textbf{shadcn ui} ui pour \textbf{react native} .
    \subitem \href{https://reactnativereusables.com/getting-started/introduction/}{https://reactnativereusables.com/getting-started/introduction/}
    \item \textbf{\texttt{Gluestack}}: Tout come shadcn ui ,gluestack est une meilleurs UI épuré \textbf{shadcn ui} ui pour \textbf{react native} .
    \subitem \href{https://gluestack.io/ui/docs/home/overview/quick-start}{https://gluestack.io/ui/docs/home/overview/quick-start}
    \item \textbf{\texttt{react-native-elements}}: Kit d'interface utilisateur cross-platform complet.
    \subitem \href{https://reactnativeelements.com/}{https://reactnativeelements.com/}
    \item \textbf{\texttt{native-base}}: Composants mobiles essentiels pour React Native.
    \subitem \href{https://nativebase.io/}{https://nativebase.io/}
    \item \textbf{\texttt{react-native-paper}}: Composants Material Design pour React Native.
    \subitem \href{https://callstack.github.io/react-native-paper/}{https://callstack.github.io/react-native-paper/}
    \item \textbf{\texttt{tamagui}}: Framework UI universel avec optimisations de performance.
    \subitem \href{https://tamagui.dev/}{https://tamagui.dev/}
\end{itemize}


\section*{Icônes pour Interfaces Utilisateur}
Ajout d'icônes vectorielles et personnalisables pour enrichir les interfaces React Native \newline
\begin{itemize}
    \item \textbf{\texttt{https://lucide.dev/guide/packages/lucide-react-native}} : Sans doute la plus poupulaire et modulaire avec l avantage de personnaliser l \'epaisseur des bordure (avec la prop strokeWidth)
    \subitem \href{https://lucide.dev/guide/packages/lucide-react-native}{https://lucide.dev/guide/packages/lucide-react-native}
    \item \textbf{\texttt{react-native-vector-icons}} faIcon{star} : Bibliothèque d'icônes vectorielles la plus populaire, offrant des milliers d'icônes de collections comme FontAwesome, Material Icons, et Ionicons.
    \subitem \href{https://oblador.github.io/react-native-vector-icons/}{https://oblador.github.io/react-native-vector-icons/}
    \item \textbf{\texttt{react-native-feather}} faIcon{feather} : Implémentation légère des icônes Feather, élégantes et minimalistes, parfaites pour les interfaces modernes.
    \subitem \href{https://feathericons.com/}{https://feathericons.com/}
    \item \textbf{\texttt{react-native-ionicons}} faIcon{ion} : Collection d'icônes Ionicons, conçues pour une intégration fluide avec React Native et Expo.
    \subitem \href{https://github.com/ionic-team/ionicons}{https://github.com/ionic-team/ionicons}
    \item \textbf{\texttt{react-native-phosphor-icons}} faIcon{lightning} : Icônes modernes et stylisées de la bibliothèque Phosphor, avec des options de personnalisation avancées.
    \subitem \href{https://github.com/duongdev/react-native-phosphor-icons}{https://github.com/duongdev/react-native-phosphor-icons}
\end{itemize}



\section*{Visualisation de Donn\'ees}
Cr\'eation de graphiques et repr\'esentations visuelles \newline
\begin{itemize}
    \item \textbf{\texttt{react-native-gifted-charts}}: Biblioth\`eque pour cr\'eer des graphiques interactifs et personnalisables.
    \subitem \href{https://gifted-charts.web.app/}{https://gifted-charts.web.app/}
    \item \textbf{\texttt{react-native-chart-kit}}: Graphiques simples et \'el\'egants pour React Native.
    \subitem \href{https://github.com/indiespirit/react-native-chart-kit}{https://github.com/indiespirit/react-native-chart-kit}
    \item \textbf{\texttt{victory-native}}: Composants de visualisation de donn\'ees modulaires.
    \subitem \href{https://formidable.com/open-source/victory/}{https://formidable.com/open-source/victory/}
    \item \textbf{\texttt{react-native-svg-charts}}: Graphiques SVG personnalisables et performants.
    \subitem \href{https://github.com/JesperLekland/react-native-svg-charts}{https://github.com/JesperLekland/react-native-svg-charts}
\end{itemize}

\section*{Gestion d'\'Etat}
Solutions pour g\'erer l'\'etat de l'application \newline
\begin{itemize}
    \item \textbf{\texttt{redux}}: Conteneur d'\'etat pr\'evisible pour applications JavaScript.
    \subitem \href{https://redux.js.org/}{https://redux.js.org/}
    \item \textbf{\texttt{zustand}}: Gestion d'\'etat simple et l\'eg\`ere sans boilerplate.
    \subitem \href{https://zustand-demo.pmnd.rs/}{https://zustand-demo.pmnd.rs/}
    \item \textbf{\texttt{mobx-react-lite}}: Gestion d'\'etat r\'eactive simple et extensible.
    \subitem \href{https://mobx.js.org/react-integration.html}{https://mobx.js.org/react-integration.html}
    \item \textbf{\texttt{recoil}}: Gestion d'\'etat exp\'erimentale par Facebook.
    \subitem \href{https://recoiljs.org/}{https://recoiljs.org/}
\end{itemize}

\section*{R\'eseau et API}
Communication avec les services externes \newline
\begin{itemize}
    \item \textbf{\texttt{axios}}: Client HTTP bas\'e sur les promesses pour navigateur et Node.js.
    \subitem \href{https://axios-http.com/}{https://axios-http.com/}
    \item \textbf{\texttt{@tanstack/react-query}}: Hooks pour r\'ecup\'erer, mettre en cache et synchroniser les donn\'ees.
    \subitem \href{https://tanstack.com/query/latest}{https://tanstack.com/query/latest}
    \item \textbf{\texttt{apollo-client}}: Client GraphQL complet avec cache intelligent.
    \subitem \href{https://www.apollographql.com/docs/react/}{https://www.apollographql.com/docs/react/}
    \item \textbf{\texttt{react-native-super-grid}}: Composant FlatList am\'elior\'e pour grilles.
    \subitem \href{https://github.com/saleel/react-native-super-grid}{https://github.com/saleel/react-native-super-grid}
\end{itemize}

\section*{Stockage Local}
Persistance des donn\'ees sur l'appareil \newline
\begin{itemize}
    \item \textbf{\texttt{@react-native-async-storage/async-storage}}: Stockage asynchrone persistant et non chiffr\'e.
    \subitem \href{https://react-native-async-storage.github.io/async-storage/}{https://react-native-async-storage.github.io/async-storage/}
    \item \textbf{\texttt{react-native-mmkv}}: Stockage cl\'e-valeur ultra-rapide pour React Native.
    \subitem \href{https://github.com/mrousavy/react-native-mmkv}{https://github.com/mrousavy/react-native-mmkv}
    \item \textbf{\texttt{realm}}: Base de donn\'ees mobile orient\'ee objet.
    \subitem \href{https://realm.io/}{https://realm.io/}
    \item \textbf{\texttt{react-native-sqlite-storage}}: Interface SQLite pour React Native.
    \subitem \href{https://github.com/andpor/react-native-sqlite-storage}{https://github.com/andpor/react-native-sqlite-storage}
\end{itemize}

\section*{Animation}
Cr\'eation d'animations fluides et performantes \newline
\begin{itemize}
    \item \textbf{\texttt{react-native-reanimated}}: Biblioth\`eque d'animation native haute performance.
    \subitem \href{https://docs.swmansion.com/react-native-reanimated/}{https://docs.swmansion.com/react-native-reanimated/}
    \item \textbf{\texttt{lottie-react-native}}: Rendu d'animations After Effects en temps r\'eel.
    \subitem \href{https://github.com/lottie-react-native/lottie-react-native}{https://github.com/lottie-react-native/lottie-react-native}
    \item \textbf{\texttt{react-native-animatable}}: Animations d\'eclaratives pour React Native.
    \subitem \href{https://github.com/oblador/react-native-animatable}{https://github.com/oblador/react-native-animatable}
    \item \textbf{\texttt{react-native-shared-element}}: Transitions d'\'el\'ements partag\'es entre \'ecrans.
    \subitem \href{https://github.com/IjzerenHein/react-native-shared-element}{https://github.com/IjzerenHein/react-native-shared-element}
\end{itemize}

\section*{M\'edias et Fichiers}
Gestion des images, vid\'eos et fichiers \newline
\begin{itemize}
    \item \textbf{\texttt{react-native-image-picker}}: S\'election d'images depuis la galerie ou cam\'era.
    \subitem \href{https://github.com/react-native-image-picker/react-native-image-picker}{https://github.com/react-native-image-picker/react-native-image-picker}
    \item \textbf{\texttt{react-native-video}}: Composant vid\'eo pour React Native.
    \subitem \href{https://github.com/react-native-video/react-native-video}{https://github.com/react-native-video/react-native-video}
    \item \textbf{\texttt{react-native-fast-image}}: Composant d'image performant avec cache.
    \subitem \href{https://github.com/DylanVann/react-native-fast-image}{https://github.com/DylanVann/react-native-fast-image}
    \item \textbf{\texttt{react-native-document-picker}}: S\'election de documents depuis l'appareil.
    \subitem \href{https://github.com/rnmods/react-native-document-picker}{https://github.com/rnmods/react-native-document-picker}
\end{itemize}

\section*{Fonctionnalit\'es Natives}
Acc\`es aux APIs natives du dispositif \newline
\begin{itemize}
    \item \textbf{\texttt{react-native-permissions}}: Gestion unifi\'ee des permissions.
    \subitem \href{https://github.com/zoontek/react-native-permissions}{https://github.com/zoontek/react-native-permissions}
    \item \textbf{\texttt{@react-native-community/geolocation}}: Services de g\'eolocalisation.
    \subitem \href{https://github.com/react-native-geolocation/react-native-geolocation}{https://github.com/react-native-geolocation/react-native-geolocation}
    \item \textbf{\texttt{react-native-camera}}: Interface cam\'era compl\`ete.
    \subitem \href{https://github.com/react-native-camera/react-native-camera}{https://github.com/react-native-camera/react-native-camera}
    \item \textbf{\texttt{react-native-contacts}}: Acc\`es aux contacts de l'appareil.
    \subitem \href{https://github.com/rt2zz/react-native-contacts}{https://github.com/rt2zz/react-native-contacts}
\end{itemize}

\section*{Notifications}
Gestion des notifications push et locales \newline
\begin{itemize}
    \item \textbf{\texttt{@react-native-firebase/messaging}}: Notifications push via Firebase.
    \subitem \href{https://rnfirebase.io/messaging/usage}{https://rnfirebase.io/messaging/usage}
    \item \textbf{\texttt{react-native-push-notification}}: Notifications locales et push.
    \subitem \href{https://github.com/zo0r/react-native-push-notification}{https://github.com/zo0r/react-native-push-notification}
    \item \textbf{\texttt{@react-native-community/push-notification-ios}}: Notifications push sp\'ecifiques iOS.
    \subitem \href{https://github.com/react-native-push-notification/ios}{https://github.com/react-native-push-notification/ios}
\end{itemize}

\section*{Authentification et S\'ecurit\'e}
Solutions d'authentification et de s\'ecurit\'e \newline
\begin{itemize}
    \item \textbf{\texttt{react-native-keychain}}: Stockage s\'ecuris\'e des credentials.
    \subitem \href{https://github.com/oblador/react-native-keychain}{https://github.com/oblador/react-native-keychain}
    \item \textbf{\texttt{react-native-touch-id}}: Authentification biom\'etrique (Touch ID/Face ID).
    \subitem \href{https://github.com/naoufal/react-native-touch-id}{https://github.com/naoufal/react-native-touch-id}
    \item \textbf{\texttt{@react-native-google-signin/google-signin}}: Authentification Google.
    \subitem \href{https://github.com/react-native-google-signin/google-signin}{https://github.com/react-native-google-signin/google-signin}
    \item \textbf{\texttt{react-native-fbsdk-next}}: SDK Facebook pour React Native.
    \subitem \href{https://github.com/thebergamo/react-native-fbsdk-next}{https://github.com/thebergamo/react-native-fbsdk-next}
\end{itemize}

\section*{Ceux que vous utiliser le plus}

Parmis ces packages, ceux que vous utiliserez le plus sont : \newline
\textcolor{gray600}{npm install lucide-react-native} 
\textcolor{gray600}{npx expo install react-native-svg} \newline
\textcolor{gray600}{npm install @react-navigation/stack} \newline
\textcolor{gray600}{npm install @react-navigation/bottom-tabs} \newline
\textcolor{gray600}{npm install @react-navigation/drawer} \newline
\textcolor{gray600}{npm install @react-navigation/material-top-tabs} \newline
\textcolor{gray600}{npm install react-native-gesture-handler react-native-reanimated} \newline
\textcolor{gray600}{npm install react-native-reanimated-carousel} \newline
\textcolor{gray600}{npm install react-native-collapsible} \newline
\textcolor{gray600}{npm install react-native-element-dropdown} \newline
\textcolor{gray600}{npm install react-native-modal-datetime-picker} \newline
\textcolor{gray600}{npm install react-native-select-dropdown} \newline
\textcolor{gray600}{npm install react-native-safe-area-context} \newline
\textcolor{gray600}{npm install react-native-gifted-charts} \newline 
\textcolor{gray600}{npm install react-native-fingerprint-scanner} \newline

\dangersign[5ex] \textcolor{red}{SI vous utilisez expo avec le workflow managed il est imperative de verifier les compatibilités des packages avec expo comme
recommandé dans la section gestion des bibliothèques externes.} Tous les packages avec @ sont generalment compatibles avec le workflow barre minimum ou sans framework 
c est a dire react native cli .Donc prenez garde et et verifier sur la liste des packages doc expo si ce n est pas possible de le faire 
via la expo autre dit (npx expo install  nom-package ) au lieu de npm install nom-package ou autre gestionaire .\newline 

\textbf{Pourquoi npx expo install au lieu de npm install ou pnpm etc ... ?} \newline

La commande expo \textcolor{gray}{npx expo install nom-packagr} verifie toute les compatibli\'es avec le SDK et installera la bonne version et
s il y a lieu de signaler la mise a jour de d autre package pour ne pas plant\'e , chose qui n est pas le cas directement npm install
qui va vous generer une erreur d installation Et devoir ouvrir le fichier de logs et etre cable de lire pour comprendre l incompatiblit\'e et et d installer 
plutot une version précise


\section{Notion avancés}
\subsection{Notification push}
\subsection{build :EAS}
Après le développement de votre application mobile, l'une des étapes les plus cruciales est la création des builds pour la distribution sur les plateformes comme l'App Store d'Apple et le Google Play Store.\newline

\textbf{Expo Application Services (EAS)} sont des services cloud profondément intégrés pour les applications Expo et React Native, de l'équipe derrière Expo.
Il simplifie et automatise la création de vos applications destinées à la distribution en fournissant des paramètres par défaut prêts à l'emploi, compatibles avec
les projets Expo et React Native, et en gérant automatiquement les identifiants de signature de vos applications (si vous le souhaitez).
Il simplifie également le partage des builds avec votre équipe grâce à la distribution interne (via un provisionnement ad hoc et/ou universel pour l'entreprise) .
EAS offre une suite de services couvrant l'ensemble du cycle de développement et de déploiement :

\vspace{0.5cm}

\begin{enumerate}
  \item \textbf{EAS CLI}: Outil en ligne de commande (\texttt{npx eas ...}) qui permet d'interagir avec tous les services EAS. Sert d'interface unique pour lancer des builds, soumissions, mises à jour et gérer les credentials.\newline
  
  \item \textbf{EAS Build}: Service cloud permettant de \textbf{compiler et signer} des applications Android et iOS (y compris avec du code natif personnalisé). Gère également les credentials, facilite les builds internes et s'intègre étroitement avec EAS Submit et expo-updates.

  \item \textbf{EAS Submit}: Service qui permet de \textbf{publier automatiquement} les binaires (\texttt{.aab} pour Android, \texttt{.ipa} pour iOS) générés par EAS Build sur les \textbf{stores officiels} (Google Play Console et App Store Connect). Automatise l'upload via les API officielles.\newline

  \item \textbf{EAS Update}: Service de déploiement en continu permettant de \textbf{mettre à jour le JavaScript, les assets et le contenu statique} de l'application \textbf{sans repasser par les stores}. Basé sur \texttt{expo-updates}, il offre des mises à jour OTA (Over-The-Air).\newline

  \item \textbf{EAS Insights}: Service d'\textbf{analyse des performances et du cycle de vie} des builds. Fournit des métriques sur les builds, la taille des binaires, la durée de compilation et des rapports utiles pour optimiser le workflow.\newline

  \item \textbf{EAS Device Preview}: Permet de \textbf{tester et partager une application en cours de développement} avec des testeurs, en distribuant facilement une build avant soumission aux stores. Utile pour les tests internes ou les retours rapides d'équipes QA.\newline

  \item \textbf{EAS Credentials}: Gestion centralisée et sécurisée des \textbf{identifiants et certificats} nécessaires aux builds et soumissions (\texttt{keystores Android}, \texttt{certificats Apple}, \texttt{clés API}). Évite à l'utilisateur de les manipuler manuellement.\newline

\end{enumerate}

\textcolor{gray600}{Dans cette sous-section nous nous interesseront uniqument à EAS CLI et EAS build}

\section*{Comment on build son application ?}
\subsubsection{Un buid c est quoi ?}
Un \textbf{build} désigne le \textbf{processus de transformation du code source} d'une application (JavaScript/TypeScript, composants React Native, dépendances, ressources graphiques et sonores, etc.) en un \textbf{binaire exécutable} installable sur un appareil mobile. 

\begin{itemize}
  \item Sur \textbf{Android}, ce binaire est généralement un fichier \texttt{.apk} (Android Package) ou \texttt{.aab} (Android App Bundle).
  \item Sur \textbf{iOS}, ce binaire est un fichier \texttt{.ipa} (iOS App Archive).
\end{itemize}

Le build comprend plusieurs étapes importantes :
\begin{enumerate}
  \item \textbf{Compilation} du code JavaScript/TypeScript et des dépendances natives.
  \item \textbf{Bundling} du code avec Metro bundler afin de générer un \texttt{bundle.js} optimisé.
  \item \textbf{Intégration des assets} (images, polices, vidéos).
  \item \textbf{Signature du binaire} avec les credentials (keystore Android, certificats Apple).
  \item \textbf{Génération du fichier final} (\texttt{.apk}, \texttt{.aab}, ou \texttt{.ipa}) prêt à être testé, distribué ou publié.
\end{enumerate}

Ainsi, un \textbf{build} est l'étape clé qui permet de passer du code source à une \textbf{application concrète}, installable et distribuable.

% \subsubsection{Prérequis et processus EAS Build}
% Pour créer un build, donc un fichier binaire qui sera envoyé sur les stores officiels, vous devez avoir un compte Expo
% Créer votre compte Expo \href{https://expo.dev/signup}{https://expo.dev/signup} \newline

% \begin{enumerate}
%   \item \textbf{Installer la dernière version de l'interface de ligne de commande EAS}
% \end{enumerate}

% \begin{jscode}
% npm install -g eas-cli
% \end{jscode}

% \textbf{Explication}:
% \textcolor{gray600}{EAS CLI est l' outil en ligne de commande qui vous permettra d'interagir avec les services EAS depuis votre terminal.Vous pourrez executer desormais des commandes eas cli partout dans n importe de vos projets expo }

% \begin{enumerate}
%   \item[2.] \textbf{Connectez-vous à votre compte Expo}
% \end{enumerate}

% \begin{jscode}
% eas login
% \end{jscode}

% \textbf{Explication}:
% \textcolor{gray600}{Cette commande vous demandera de renseigner vos identifiants}




\subsubsection{Prérequis et fichiers importants}
Pour créer un build (un fichier binaire) qui sera envoyé sur les stores officiels, vous devez avoir un compte Expo.  
Créer votre compte Expo : \href{https://expo.dev/signup}{https://expo.dev/signup} \newline

\subsubsection{Le fichier app.json / app.config.js}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "expo": {
    "name": "MonApp",
    "slug": "monapp",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "bundleIdentifier": "com.monsite.monapp",
      "buildNumber": "1"
    },
    "android": {
      "package": "com.monsite.monapp",
      "versionCode": 1
    }
  }
}
\end{lstlisting}
\end{tcolorbox}

\textbf{Explication} :  
\textcolor{gray600}{Ce fichier est le cœur de la configuration **Expo**. Il décrit les métadonnées et paramètres de l'application.}  

\begin{itemize}
  \item \textbf{name} : nom de l'application affiché sur l'appareil.
  \item \textbf{slug} : identifiant unique du projet Expo.
  \item \textbf{version} : version visible par les utilisateurs.
  \item \textbf{icon} : icône officielle de l'app.
  \item \textbf{splash} : écran de chargement (image, couleur, mode).
  \item \textbf{ios.bundleIdentifier} : identifiant unique côté iOS.
  \item \textbf{ios.buildNumber} : numéro de build iOS (incrément obligatoire à chaque release).
  \item \textbf{android.package} : identifiant unique côté Android.
  \item \textbf{android.versionCode} : numéro de build Android (incrément obligatoire à chaque release).
\end{itemize}


\subsubsection{Le fichier eas.json}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "cli": {
    "version": ">= 3.0.0"
  },
  "build": {
    "development": {
      "developmentClient": true,
      "distribution": "internal"
    },
    "preview": {
      "distribution": "internal"
    },
    "production": {
      "autoIncrement": true
    }
  },
  "submit": {
    "production": {}
  }
}
\end{lstlisting}
\end{tcolorbox}

\textbf{Explication} :  
\textcolor{gray600}{Ce fichier définit les différents **profils de build** utilisés par EAS. Chaque profil adapte le build à une situation particulière (développement, test, production).}  

\subsubsection{Profils de build}

\begin{flushleft}
  \textcolor{gray600}{Dans le contexte d'EAS Build, un \textbf{profil} est un ensemble de \textbf{paramètres de configuration} définis dans le fichier \texttt{eas.json}.  
  Chaque profil décrit la manière dont l'application doit être construite (buildée) et distribuée.}
\end{flushleft}

\textbf{À quoi ça sert ?}  
\begin{itemize}
  \item Adapter le build selon le \textbf{contexte} : développement, test interne, ou production.
  \item Gérer automatiquement certaines options comme l'\textbf{incrémentation de version}.
  \item Définir le type de \textbf{distribution} : interne (test) ou store (public).
  \item Choisir si l'on inclut un \textbf{client Expo Dev} (utile en développement uniquement).
\end{itemize}

\begin{itemize}
  \item \textbf{development} :  
  \textcolor{gray600}{Crée un **Development Build** incluant le client Expo Dev. Sert aux développeurs pour tester rapidement sur leurs appareils. Distribution : \textbf{interne}.}

  \item \textbf{preview} :  
  \textcolor{gray600}{Crée un build destiné aux **testeurs internes** (QA, collaborateurs). Utile avant la mise en production. Distribution : \textbf{interne}.}

  \item \textbf{production} :  
  \textcolor{gray600}{Crée le build final prêt pour le **Google Play Store** et l'**App Store**. L'option **autoIncrement** permet d'augmenter automatiquement le numéro de build à chaque compilation.}
\end{itemize}

\vspace{0.5cm}

\textbf{Processus du build}  

\vspace{0.5cm}

\begin{enumerate}
  \item \textbf{Installer la dernière version de l'interface de ligne de commande EAS}
\end{enumerate}

\begin{jscode}
npm install -g eas-cli
\end{jscode}

\textbf{Explication} :  
\textcolor{gray600}{EAS CLI est l'outil en ligne de commande qui vous permettra d'interagir avec les services EAS depuis votre terminal. Vous pourrez exécuter désormais des commandes eas cli dans n'importe lequel de vos projets Expo.}

\begin{enumerate}
  \item[2.] \textbf{Connectez-vous à votre compte Expo}
\end{enumerate}

\begin{jscode}
eas login
\end{jscode}

\textbf{Explication} :  
\textcolor{gray600}{Cette commande vous demandera de renseigner vos identifiants (email et mot de passe Expo). Cela permet d'associer vos builds à votre espace Expo.}

\vspace{0.5cm}

\begin{enumerate}
  \item[3.] \textbf{Configurer le projet pour EAS Build}
\end{enumerate}

\begin{jscode}
eas build:configure
\end{jscode}

\textbf{Explication} :  
\textcolor{gray600}{Cette commande crée (ou met à jour) le fichier \texttt{eas.json} à la racine de votre projet. Ce fichier contient les profils de build (développement, preview, production). C'est un fichier clé pour personnaliser vos builds.}  

\vspace{0.5cm}

\begin{enumerate}
  \item[4.] \textbf{Lancer un build pour Android ou iOS}
\end{enumerate}

\begin{jscode}
build en mode developpement (Android)
eas build -p android --profile development

build en mode developpement (iOS)
eas build -p ios --profile development

Pour tous les deux os
eas build --platform all
\end{jscode}

\textbf{Explication} :  
\textcolor{gray600}{Le flag \texttt{-p} précise la plateforme (\texttt{android} ou \texttt{ios}). Le flag \texttt{--profile} précise quel profil de build défini dans \texttt{eas.json} sera utilisé (par défaut : \texttt{development}).}
Ici en mode développement permet dans un prémier de tester rapidement sans passer par les store et vous assurer que tout fonctionne bien avant de faire le build de production .  
La commande generera un un fichier .apk pour android dans votre compte expo , qui d ailleurs a un dashord comme vous avez constaté apres la creation de compte expo .


\vspace{0.5cm}



\subsubsection{Documentation officielle}
Consultez la documentation officielle pour plus de détails :  
\href{https://docs.expo.dev/build/setup/}{https://docs.expo.dev/build/setup/}













\subsection{Déploiement}

Après avoir testé votre build de développement et vous être assuré que tout fonctionne comme prévu, vous pouvez procéder au déploiement de votre application sur les stores officiels
Pour cela vous devez de nouveau utiliser eas cli pour créer et soumettre votre build pour la production adaptés aux les stores officiels.Ici le service EAS Submit qui s en occupe de la soumission au stores .
Pour la soumission voici ce qu il faut faire.

\subsubsection{Publication a Google Play Store}
Pour soumettre votre application sur le Google Play Store vous avec deux possibilités .

\begin{enumerate}
  \item \textbf{Option 1 - Soumission automatique via EAS Submit depuis votre ordinateur en local via le terminal}
  \item \textbf{Option 2 - Via un service CI}
\end{enumerate}


\textbf{Option 1 - Soumission automatique via EAS Submit depuis votre ordinateur en local via le terminal} \newline

\begin{enumerate}
  \item \textbf{Inscrivez-vous pour un compte développeur Google Play} : Un compte développeur Google Play est requis pour soumettre votre application sur le Google Play Store. Vous pouvez créer un compte développeur Google Play sur la console : \href{https://play.google.com/console/signup}{https://play.google.com/console/signup}

  \item \textbf{Créer une application sur Google Play Console}:Créez une application en cliquant sur Créer une application dans la console Google Play .

  \item \textbf{Créer un compte de service Google}:EAS exige que vous téléchargiez et configuriez une clé de compte de service Google pour soumettre votre application Android sur le Google Play Store.
  Vous pouvez en créer une en téléchargant une clé de compte de service Google pour les soumissions sur le Play Store avec le guide EAS sur \href{https://github.com/expo/fyi/blob/main/creating-google-service-account.md}{https://github.com/expo/fyi/blob/main/creating-google-service-account.md}

  \item \textbf{Inclure un nom de package dans app.json} :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "android": {
    "package": "com.yourcompany.yourapp"
  }
}
\end{lstlisting}
\end{tcolorbox}

\begin{enumerate}
  \item[6.] \textbf{Fournir un profil de soumission dans eas.json}:Ensuite, vous devrez fournir un profil de soumission dans eas.json qui inclutserviceAccountKeyPath
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "submit": {
    "production": {
      "android": {
        "serviceAccountKeyPath": "../path/to/api-xxx-yyy-zzz.json"
      }
    }
  }
}

\end{lstlisting}
\end{tcolorbox}

\textcolor{gray600}{D'autres options sont disponibles pour les soumissions Android. Pour en savoir plus, consultez la} \newline
\href{https://docs.expo.dev/eas/json/\#android-specific-options-1}{https://docs.expo.dev/eas/json/\#android-specific-options-1}


\begin{enumerate}
  \item[7.] \textbf{Créer une application de production}:Vous aurez besoin d'une version de production prête à être soumise à la boutique. Vous pouvez en créer une avec EAS Build :
\end{enumerate}


\begin{jscode}
eas build --platform android --profile production
\end{jscode}

\subsubsection{Publication à l'App Store d'Apple}

Pour soumettre votre application sur l'App Store d'Apple, vous avez deux possibilités :

\begin{enumerate}
  \item \textbf{Option 1 - Soumission automatique via EAS Submit depuis votre ordinateur en local via le terminal}
  \item \textbf{Option 2 - Via un service CI/CD}
\end{enumerate}

\textbf{Option 1 - Soumission automatique via EAS Submit depuis votre ordinateur en local via le terminal} \newline

\begin{enumerate}
  \item \textbf{Inscrivez-vous pour un compte développeur Apple} : Un compte développeur Apple est requis pour soumettre votre application sur l'App Store. Vous pouvez créer un compte développeur Apple sur le portail officiel \href{https://developer.apple.com/programs/enroll/}{https://developer.apple.com/programs/enroll/}

  \item \textbf{Inclure un identifiant de bundle dans \texttt{app.json}} : Vous devez définir l'identifiant unique de votre application.
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "ios": {
    "bundleIdentifier": "com.yourcompany.yourapp"
  }
}
\end{lstlisting}
\end{tcolorbox}

\begin{enumerate}
  \item[3.] \textbf{Installer EAS CLI et se connecter à son compte Expo} :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
npm install -g eas-cli && eas login
\end{lstlisting}
\end{tcolorbox}

\begin{enumerate}
  \item[4.] \textbf{Créer une application de production} : Vous aurez besoin d'une version prête pour soumission. Créez-la avec :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
eas build --platform ios --profile production
\end{lstlisting}
\end{tcolorbox}

\textcolor{gray600}{Alternativement, vous pouvez construire en local avec :}  
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
eas build --platform ios --profile production --local
\end{lstlisting}
\end{tcolorbox}

\textcolor{gray600}{ou encore directement via Xcode.}  

\begin{enumerate}
  \item[5.] \textbf{Soumettre l'application à l'App Store} : Exécutez la commande suivante pour lancer le processus de soumission :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
eas submit --platform ios
\end{lstlisting}
\end{tcolorbox}

\textcolor{gray600}{Cette commande vous guidera étape par étape (identifiants Apple, certificats, etc.).}  

\begin{enumerate}
  \item[6.] \textbf{Configurer un profil de soumission dans \texttt{eas.json}} : Pour automatiser certaines étapes, vous pouvez préciser les options suivantes :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
{
  "submit": {
    "production": {
      "ios": {
        "ascAppId": "your-app-store-connect-app-id"
      }
    }
  }
}
\end{lstlisting}
\end{tcolorbox}

\textbf{Comment trouver \texttt{ascAppId}} :  
\textcolor{gray600}{Il correspond à l'ID de l'application dans App Store Connect. Vous pouvez le récupérer en consultant la fiche de l'app dans votre compte Apple.}  

\begin{enumerate}
  \item[7.] \textbf{Soumission automatique après build} : Pour gagner du temps, vous pouvez utiliser l'option \texttt{--auto-submit} :
\end{enumerate}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
eas build --platform ios --auto-submit
\end{lstlisting}
\end{tcolorbox}

\textcolor{gray600}{Ainsi, la soumission est déclenchée automatiquement dès que la build est terminée.}


\chapter{Ionic }
\addtocontents{toc}{\vspace{1em}}

\section{Qu est ce que Ionic}
Ionic est un framework hybride qui permet de construire des applications mobiles, web et desktop à partir d'une seule base de code, utilisant des technologies web comme HTML, CSS et JavaScript.
Il fonctionne avec Angular, React, Vue, ou JavaScript vanilla.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.12\textwidth]{ionic.png}
    \caption{Logo de React Native}
    \label{fig:ionic logo}
\end{figure}

\subsection{Ionic React}
Comme son nom l'indique, Ionic React est la version d'Ionic qui permet de construire des applications mobiles en utilisant React.
Il offre une collection de composants UI et des outils pour faciliter le développement d'applications mobiles avec React.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.12\textwidth]{react-native.png}
    \caption{Logo de React Native}
    \label{fig:ionic-react logo}
\end{figure}

\href{https://ionicframework.com/}{ionic documentation} \newline
\href{https://react.dev/}{react documentation}

\section*{Architecture et fonctionnement d Ionic React}
\begin{itemize}
  \item \textbf{React}:pour la logique et les composants
  \item \textbf{React}:pour l acces aux fonctionnalit\'es natives
  \item \textbf{WebView}:pour le rendu sur mobile
  \item \textbf{Composants UI pré-construits}:avec un design natif
\end{itemize}


\subsection{Installation d un projet Ionic React:structure de base}
Pour installer un projet Ionic React, vous pouvez utiliser la CLI Ionic comme suit:

\subsection*{Cr\'eation d'un projet Ionic React}
Voici les diff\'erentes options pour cr\'eer un projet Ionic React selon les templates disponibles :


\begin{itemize}
  \item \textbf{V\'erifiez la liste des templates disponibles} :\textcolor{gray600}{ ionic start --list }

  \item \textbf{Option 1 - Template blank} : Page unique basique pour commencer
  \subitem \textcolor{gray600}{ionic start MonApp blank --type=react}
  
  \item \textbf{Option 2 - Template tabs} : Application avec navigation par onglets
    \subitem \textcolor{gray600}{ionic start MonApp tabs --type=react}

  \item \textbf{Option 3 - Template sidemenu} : Application avec menu lat\'eral coulissant
    \subitem \textcolor{gray600}{ionic start MonApp sidemenu --type=react}
    
  \item \textbf{Option 4 - Avec TypeScript} : Cr\'eation directe avec TypeScript
    \subitem \textcolor{gray600}{ionic start MonApp blank --type=react --template=blank-typescript}
    \subitem \textcolor{gray600}{ionic start MonApp tabs --type=react --template=tabs-typescript}
    \subitem \textcolor{gray600}{ionic start MonApp sidemenu --type=react --template=sidemenu-typescript}
\end{itemize}


\subsection*{Structure d'un projet Ionic React TypeScript}

Voici l'arborescence par d\'efaut d'un projet Ionic React cr\'e\'e avec le template TypeScript \newline


\dirtree{%
.1 \textcolor{gray}{ionic-react/}.
.2 \textcolor{gray}{.git/} \DTcomment{\textcolor{gray}{Dossier de gestion Git}}.
.2 \textcolor{gray}{.vscode/} \DTcomment{\textcolor{gray}{Configuration Visual Studio Code}}.
.2 \textcolor{gray}{cypress/} \DTcomment{\textcolor{gray}{Tests end-to-end avec Cypress}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{D\'ependances install\'ees par npm}}.
.2 \textcolor{gray}{public/} \DTcomment{\textcolor{gray}{Fichiers statiques servis directement}}.
.2 \textcolor{gray}{src/} \DTcomment{\textcolor{gray}{Code source de l'application}}.
.3 \textcolor{gray}{components/} \DTcomment{\textcolor{gray}{Composants r\'eutilisables}}.
.3 \textcolor{gray}{pages/} \DTcomment{\textcolor{gray}{Pages/\'ecrans de l'application}}.
.3 \textcolor{gray}{theme/} \DTcomment{\textcolor{gray}{Configuration des th\`emes CSS}}.
.4 \textcolor{gray}{variables.css} \DTcomment{\textcolor{gray}{Variables CSS personnalis\'ees}}.
.3 \textcolor{gray}{App.test.tsx} \DTcomment{\textcolor{gray}{Tests unitaires du composant App}}.
.3 \textcolor{gray}{App.tsx} \DTcomment{\textcolor{gray}{Composant racine TypeScript}}.
.3 \textcolor{gray}{index.css} \DTcomment{\textcolor{gray}{Styles CSS globaux}}.
.3 \textcolor{gray}{main.tsx} \DTcomment{\textcolor{gray}{Point d'entr\'ee TypeScript avec Vite}}.
.3 \textcolor{gray}{setupTests.ts} \DTcomment{\textcolor{gray}{Configuration des tests}}.
.3 \textcolor{gray}{vite-env.d.ts} \DTcomment{\textcolor{gray}{D\'efinitions TypeScript pour Vite}}.
.2 \textcolor{gray}{.browserslistrc} \DTcomment{\textcolor{gray}{Configuration des navigateurs support\'es}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichiers ignor\'es par Git}}.
.2 \textcolor{gray}{capacitor.config.ts} \DTcomment{\textcolor{gray}{Configuration Capacitor TypeScript}}.
.2 \textcolor{gray}{cypress.config.ts} \DTcomment{\textcolor{gray}{Configuration Cypress pour les tests}}.
.2 \textcolor{gray}{eslint.config.js} \DTcomment{\textcolor{gray}{Configuration ESLint moderne}}.
.2 \textcolor{gray}{index.html} \DTcomment{\textcolor{gray}{Page HTML principale}}.
.2 \textcolor{gray}{ionic.config.json} \DTcomment{\textcolor{gray}{Configuration du CLI Ionic}}.
.2 \textcolor{gray}{package-lock.json} \DTcomment{\textcolor{gray}{Verrouillage des versions npm}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{M\'etadonn\'ees et scripts npm}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration TypeScript}}.
.2 \textcolor{gray}{tsconfig.node.json} \DTcomment{\textcolor{gray}{Configuration TypeScript pour Node.js}}.
.2 \textcolor{gray}{vite.config.ts} \DTcomment{\textcolor{gray}{Configuration Vite (bundler moderne)}}.
}



\subsection{Composants UI Ionic}
Ionic React propose une large gamme de composants UI pré-construits qui sont optimisés pour les performances mobiles et offrent une expérience utilisateur native.
Voici quelques exemples de composants:

\begin{enumerate}
\item \textbf{IonCard} : utilisé pour afficher du contenu dans des cartes élégantes, idéal pour les listes d'articles ou les profils
\item \textbf{IonCard} : utilisé pour afficher du contenu dans des cartes élégantes, idéal pour les listes d'articles ou les profils
\item \textbf{IonInput} : utilisé pour les champs de saisie de texte avec validation intégrée et styles natifs
\item \textbf{IonList} : utilisé pour afficher des listes d'éléments avec séparateurs, idéal pour les menus et les données structurées
\item \textbf{IonItem} : utilisé comme conteneur pour les éléments de liste, souvent combiné avec IonList
\item \textbf{IonHeader} : utilisé pour créer l'en-tête de page avec titre et boutons de navigation
\item \textbf{IonToolbar} : utilisé dans les headers et footers pour organiser les boutons et le titre
\item \textbf{IonContent} : utilisé comme conteneur principal scrollable pour le contenu de la page
\item \textbf{IonTabs} : utilisé pour créer une navigation par onglets en bas de l'écran
\item \textbf{IonModal} : utilisé pour afficher du contenu dans une fenêtre modale overlay
\item \textbf{IonAlert} : utilisé pour afficher des alertes et confirmations natives
\item \textbf{IonToast} : utilisé pour afficher des notifications temporaires en bas ou en haut de l'écran
\item \textbf{IonActionSheet} : utilisé pour présenter une liste d'actions contextuelles depuis le bas de l'écran
\item \textbf{IonPopover} : utilisé pour afficher du contenu contextuel dans une bulle attachée à un élément
\item \textbf{IonCheckbox} : utilisé pour les cases à cocher avec animations et styles natifs
\item \textbf{IonRadio} : utilisé pour les boutons radio dans des groupes de sélection unique
\item \textbf{IonToggle} : utilisé pour les interrupteurs on/off avec animations fluides
\item \textbf{IonSelect} : utilisé pour créer des listes déroulantes avec interface native
\item \textbf{IonDatetime} : utilisé pour la sélection de dates et heures avec interface native
\item \textbf{IonRange} : utilisé pour créer des curseurs de sélection de valeurs numériques
\item \textbf{IonSearchbar} : utilisé pour implémenter des barres de recherche avec fonctionnalités intégrées
\item \textbf{IonRefresher} : utilisé pour ajouter la fonctionnalité "pull-to-refresh" aux listes
\item \textbf{IonInfiniteScroll} : utilisé pour implémenter le chargement infini lors du défilement
\item \textbf{IonFab} : utilisé pour créer des boutons d'action flottants (Floating Action Button)
\item \textbf{IonGrid, IonRow, IonCol} : utilisés pour créer des layouts responsives basés sur une grille
\item \textbf{IonSpinner} : utilisé pour afficher des indicateurs de chargement animés
\item \textbf{IonProgressBar} : utilisé pour afficher la progression d'une tâche
\item \textbf{IonBadge} : utilisé pour afficher des compteurs ou des labels colorés
\item \textbf{IonChip} : utilisé pour créer des étiquettes compactes avec possibilité de fermeture
\item \textbf{IonAvatar} : utilisé pour afficher des images de profil circulaires
\item \href{https://ionicframework.com/docs/components}{Lien composants Ionic :https://ionicframework.com/docs/components}
\end{enumerate}

\section*{Avantage de Ionic}
\begin{itemize}
    \item Un seul codebase pour le web, iOS, Android et desktop
    \item Composants UI riches avec un design Material/iOS automatique
    \item Développement rapide si vous connaissez déjà React
    \item Support excellent des Progressive Web Apps (PWA) natives
\end{itemize}

\section*{Inconvénients de Ionic}
\begin{itemize}
    \item Performance moindre que les applications natives
    \item Dépendant du WebView - peut être plus lent
    \item Taille de l'application plus importante
    \item Expérience utilisateur parfois moins fluide
\end{itemize}


\subsubsection{Personnalisation des composants UI }
La personnalisation des composants ui serait sans doute une partie des plus récurrentes que vous aurez à faire 
si vous êtes un fin amoureux de la finesse et de l'esthétique le coup d oeil d un maitre ui , ux . Fort de cela , connaitre la modification 
est donc necessaire . Voyons le en exemple 

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{sheet (2).png}
    \caption{Composant Action Sheet Ionic sur Android}
    \label{fig:Action sheet UI Ionic component}
\end{figure}


En ionic React chaque composant expose trois grandes parties :
\begin{enumerate}
  \item \textbf{Les props} :Les props appelés propriétes comme vous le connaissez déja en react , les methodes , et le style \textcolor{gray}{encadré en rouge}  sur la capture
\end{enumerate}
\textcolor{gray600}{Zones en bleu} : 



\section*{CSS Custom Properties en Ionic}

Les CSS Custom Properties (variables CSS) constituent le syst\`eme de th\'eming principal d'Ionic. Elles permettent de personnaliser l'apparence des composants de mani\`ere coh\'erente et maintenable. Ionic expose des centaines de variables CSS pour contr\^oler tous les aspects visuels des composants, depuis les couleurs jusqu'aux espacements et animations.

\subsection*{Principe des Custom Properties}

Les Custom Properties sont des variables CSS natives qui peuvent \^etre d\'efinies et r\'eutilis\'ees dans toute la feuille de style. Elles suivent la syntaxe \texttt{--nom-variable} et sont h\'erit\'ees par d\'efaut dans l'arbre DOM.

\subsubsection*{Syntaxe de base}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* D\'efinition de variables globales */
:root {
  --ion-color-primary: #3880ff;
  --ion-color-secondary: #3dc2ff;
  --ion-color-tertiary: #5260ff;
}

/* Utilisation des variables */
.custom-button {
  background: var(--ion-color-primary);
  color: var(--ion-color-primary-contrast);
}

/* Avec valeur de fallback */
.element {
  padding: var(--ion-spacing-large, 16px);
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Variables de couleurs globales}

Ionic utilise un syst\`eme de palette de couleurs bas\'e sur des variables CSS :

\subsubsection*{Couleurs principales}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
:root {
  /* Couleurs primaires */
  --ion-color-primary: #3880ff;
  --ion-color-primary-rgb: 56, 128, 255;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-primary-contrast-rgb: 255, 255, 255;
  --ion-color-primary-shade: #3171e0;
  --ion-color-primary-tint: #4c8dff;

  /* Couleurs secondaires */
  --ion-color-secondary: #3dc2ff;
  --ion-color-secondary-rgb: 61, 194, 255;
  --ion-color-secondary-contrast: #ffffff;
  --ion-color-secondary-contrast-rgb: 255, 255, 255;
  --ion-color-secondary-shade: #36abe0;
  --ion-color-secondary-tint: #50c8ff;

  /* Couleurs de statut */
  --ion-color-success: #2dd36f;
  --ion-color-warning: #ffc409;
  --ion-color-danger: #eb445a;
  --ion-color-dark: #222428;
  --ion-color-medium: #92949c;
  --ion-color-light: #f4f5f8;
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Th\`eme sombre automatique}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Variables pour le th\`eme sombre */
@media (prefers-color-scheme: dark) {
  :root {
    --ion-color-primary: #428cff;
    --ion-color-primary-rgb: 66, 140, 255;
    --ion-color-primary-contrast: #ffffff;
    --ion-color-primary-contrast-rgb: 255, 255, 255;
    --ion-color-primary-shade: #3a7be0;
    --ion-color-primary-tint: #5598ff;

    --ion-color-secondary: #50c8ff;
    --ion-color-secondary-rgb: 80, 200, 255;
    --ion-color-secondary-contrast: #ffffff;
    --ion-color-secondary-contrast-rgb: 255, 255, 255;
    --ion-color-secondary-shade: #46b0e0;
    --ion-color-secondary-tint: #62ceff;
  }
}

/* Ou via une classe */
.dark-theme {
  --ion-color-primary: #428cff;
  --ion-background-color: #121212;
  --ion-text-color: #ffffff;
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Variables par composant}

Chaque composant Ionic expose ses propres variables CSS pour une personnalisation granulaire :

\subsubsection*{IonButton}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Variables disponibles pour ion-button */
ion-button {
  --background: #3880ff;
  --background-activated: #3171e0;
  --background-focused: #3880ff;
  --background-hover: #4c8dff;
  
  --color: #ffffff;
  --color-activated: #ffffff;
  --color-focused: #ffffff;
  --color-hover: #ffffff;
  
  --border-radius: 4px;
  --border-width: 0;
  --border-style: solid;
  --border-color: transparent;
  
  --box-shadow: none;
  --opacity: 1;
  
  --padding-top: 0;
  --padding-end: 16px;
  --padding-bottom: 0;
  --padding-start: 16px;
  
  --margin-top: 0;
  --margin-end: 0;
  --margin-bottom: 0;
  --margin-start: 0;
  
  --min-height: 44px;
  --min-width: auto;
  
  --transition: background-color, opacity 100ms linear;
  
  --ripple-color: currentColor;
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonInput}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
ion-input {
  --background: transparent;
  --color: var(--ion-text-color, #000);
  
  --placeholder-color: var(--ion-placeholder-color, #999);
  --placeholder-opacity: 0.6;
  
  --padding-top: 10px;
  --padding-end: 0;
  --padding-bottom: 10px;
  --padding-start: 0;
  
  --border-width: 0;
  --border-style: solid;
  --border-color: var(--ion-item-border-color, var(--ion-border-color, var(--ion-color-step-150, rgba(0, 0, 0, 0.13))));
  
  --highlight-color-focused: var(--ion-color-primary, #3880ff);
  --highlight-color-valid: var(--ion-color-success, #2dd36f);
  --highlight-color-invalid: var(--ion-color-danger, #eb445a);
  
  --highlight-height: 2px;
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonCard}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
ion-card {
  --background: var(--ion-item-background, var(--ion-background-color, #fff));
  --color: var(--ion-color-step-600, #666666);
  
  --border-radius: 4px;
  --border-width: 0;
  --border-style: solid;
  --border-color: var(--ion-color-step-150, rgba(0, 0, 0, 0.13));
  
  --box-shadow: 0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12);
  
  --transition: box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);
  
  --width: 100%;
  --min-height: auto;
  
  --padding-top: 20px;
  --padding-end: 20px;
  --padding-bottom: 20px;
  --padding-start: 20px;
  
  --margin-top: 10px;
  --margin-end: 10px;
  --margin-bottom: 10px;
  --margin-start: 10px;
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Variables de mise en page globales}

Ionic fournit des variables pour la mise en page g\'en\'erale de l'application :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
:root {
  /* Couleurs de fond */
  --ion-background-color: #ffffff;
  --ion-background-color-rgb: 255, 255, 255;
  
  /* Couleurs de texte */
  --ion-text-color: #000000;
  --ion-text-color-rgb: 0, 0, 0;
  
  /* Couleurs des bordures */
  --ion-border-color: #c8c7cc;
  --ion-item-border-color: #c8c7cc;
  
  /* Safe area (pour les encoches) */
  --ion-safe-area-top: env(safe-area-inset-top);
  --ion-safe-area-right: env(safe-area-inset-right);
  --ion-safe-area-bottom: env(safe-area-inset-bottom);
  --ion-safe-area-left: env(safe-area-inset-left);
  
  /* Espacements standardis\'es */
  --ion-margin: 16px;
  --ion-padding: 16px;
  
  /* Typographie */
  --ion-font-family: var(--ion-default-font, -apple-system, BlinkMacSystemFont, "Helvetica Neue", "Roboto", sans-serif);
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Cr\'eation de th\`emes personnalis\'es}

\subsubsection*{Th\`eme d'entreprise}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Th\`eme corporate */
.corporate-theme {
  --ion-color-primary: #1e3a8a;
  --ion-color-primary-rgb: 30, 58, 138;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-primary-shade: #1a3278;
  --ion-color-primary-tint: #3548a1;
  
  --ion-color-secondary: #059669;
  --ion-color-secondary-rgb: 5, 150, 105;
  --ion-color-secondary-contrast: #ffffff;
  --ion-color-secondary-shade: #047857;
  --ion-color-secondary-tint: #10b981;
  
  /* Personnalisation des composants */
  --ion-toolbar-background: var(--ion-color-primary);
  --ion-toolbar-color: var(--ion-color-primary-contrast);
  
  --ion-tab-bar-background: #f8fafc;
  --ion-tab-bar-color: #64748b;
  --ion-tab-bar-color-selected: var(--ion-color-primary);
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Th\`eme saisonnier}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Th\`eme automne */
.autumn-theme {
  --ion-color-primary: #dc2626;
  --ion-color-secondary: #f59e0b;
  --ion-color-tertiary: #d97706;
  
  --ion-background-color: #fef7ed;
  --ion-text-color: #451a03;
  
  /* Gradients automne */
  --autumn-gradient: linear-gradient(135deg, #dc2626 0%, #f59e0b 50%, #d97706 100%);
  
  /* Application aux composants */
  ion-button {
    --background: var(--autumn-gradient);
    --border-radius: 25px;
  }
  
  ion-card {
    --background: linear-gradient(145deg, #fed7aa 0%, #fdba74 100%);
    --box-shadow: 0 8px 32px rgba(251, 146, 60, 0.3);
  }
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Variables dynamiques avec JavaScript}

Les Custom Properties peuvent \^etre modifi\'ees dynamiquement :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
// Modification des variables en JavaScript
const changeTheme = (primaryColor) => {
  document.documentElement.style.setProperty('--ion-color-primary', primaryColor);
  
  // Calcul automatique des variantes
  const rgb = hexToRgb(primaryColor);
  document.documentElement.style.setProperty('--ion-color-primary-rgb', `${rgb.r}, ${rgb.g}, ${rgb.b}`);
  
  // Shade (version plus fonc\'ee)
  const shade = adjustBrightness(primaryColor, -0.12);
  document.documentElement.style.setProperty('--ion-color-primary-shade', shade);
  
  // Tint (version plus claire)
  const tint = adjustBrightness(primaryColor, 0.12);
  document.documentElement.style.setProperty('--ion-color-primary-tint', tint);
};

// Utilisation avec React
import { useEffect } from 'react';

const ThemeManager = ({ theme }) => {
  useEffect(() => {
    const themes = {
      dark: {
        '--ion-background-color': '#121212',
        '--ion-text-color': '#ffffff',
        '--ion-color-primary': '#bb86fc'
      },
      light: {
        '--ion-background-color': '#ffffff',
        '--ion-text-color': '#000000',
        '--ion-color-primary': '#6200ea'
      }
    };
    
    const currentTheme = themes[theme];
    Object.entries(currentTheme).forEach(([property, value]) => {
      document.documentElement.style.setProperty(property, value);
    });
  }, [theme]);
  
  return null;
};
\end{lstlisting}
\end{tcolorbox}

\subsection*{Variables de responsive design}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
:root {
  /* Variables de base (mobile) */
  --app-padding: 16px;
  --app-font-size: 16px;
  --app-header-height: 56px;
}

/* Tablettes */
@media (min-width: 768px) {
  :root {
    --app-padding: 24px;
    --app-font-size: 18px;
    --app-header-height: 64px;
  }
}

/* Desktop */
@media (min-width: 1024px) {
  :root {
    --app-padding: 32px;
    --app-font-size: 20px;
    --app-header-height: 72px;
  }
}

/* Utilisation dans les composants */
.custom-container {
  padding: var(--app-padding);
  font-size: var(--app-font-size);
}

ion-header {
  --min-height: var(--app-header-height);
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Bonnes pratiques pour les Custom Properties}

\begin{itemize}
\item \textbf{Organisation} : Groupez les variables par cat\'egorie (couleurs, espacements, typographie)
\item \textbf{Nommage} : Utilisez des noms descriptifs et coh\'erents
\item \textbf{Documentation} : Documentez l'usage de chaque variable personnalis\'ee
\item \textbf{Fallbacks} : Toujours fournir des valeurs de fallback
\item \textbf{Performance} : \'Evitez de red\'efinir trop de variables simultanément
\item \textbf{Maintenance} : Centralisez les d\'efinitions dans des fichiers d\'edi\'es
\item \textbf{Tests} : Testez les th\`emes sur diff\'erents appareils et navigateurs
\end{itemize}

\subsection*{Outils et ressources}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* G\'en\'erateur de palette Ionic */
// Utiliser l'outil officiel : https://ionicframework.com/docs/theming/color-generator

/* Variables CSS dans les DevTools */
// 1. Inspecter un \'el\'ement
// 2. Onglet "Computed" -> "Show all"
// 3. Filtrer par "--ion" pour voir toutes les variables

/* Test de variables en temps r\'eel */
document.documentElement.style.setProperty('--ion-color-primary', '#ff0000');

/* Export des variables actuelles */
const exportCurrentTheme = () => {
  const styles = getComputedStyle(document.documentElement);
  const ionVars = {};
  
  for (let i = 0; i < styles.length; i++) {
    const prop = styles[i];
    if (prop.startsWith('--ion')) {
      ionVars[prop] = styles.getPropertyValue(prop);
    }
  }
  
  return ionVars;
};
\end{lstlisting}
\end{tcolorbox}

Les CSS Custom Properties offrent un syst\`eme de th\'eming puissant et flexible pour Ionic, permettant de cr\'eer des interfaces coh\'erentes et facilement maintenables.


\section*{CSS Shadow Parts dans Ionic}

Les CSS Shadow Parts sont une fonctionnalité moderne du standard Web Components qui permet de personnaliser l'apparence des éléments internes des composants Ionic sans briser l'encapsulation du Shadow DOM. Cette approche offre un contr\^ole pr\'ecis sur le style des composants tout en maintenant leur robustesse et leur compatibilit\'e.

\subsection*{Principe des Shadow Parts}

Les Shadow Parts utilisent l'attribut \texttt{part} pour exposer des parties sp\'ecifiques d'un composant Shadow DOM au CSS externe. Contrairement aux variables CSS qui ne permettent que de modifier des propri\'et\'es pr\'ed\'efinies, les Shadow Parts donnent acc\`es direct aux \'el\'ements internes pour une personnalisation compl\`ete.

\subsubsection*{Syntaxe de base}

La syntaxe utilise le pseudo-\'el\'ement \texttt{::part()} :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Cibler une partie sp\'ecifique d'un composant */
ion-button::part(native) {
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4);
  border-radius: 25px;
  padding: 12px 24px;
}

/* Cibler plusieurs parties */
ion-input::part(native),
ion-textarea::part(native) {
  border: 2px solid #007bff;
  border-radius: 8px;
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Parts disponibles par composant}

Chaque composant Ionic expose diff\'erentes parties via l'attribut \texttt{part}. Voici les principales :

\subsubsection*{IonButton}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Part "native" : l'\'el\'ement bouton HTML natif */
ion-button::part(native) {
  background: #e74c3c;
  color: white;
  font-weight: bold;
  text-transform: none;
  letter-spacing: 1px;
}

/* Personnalisation selon l'\'etat */
ion-button::part(native):hover {
  background: #c0392b;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonInput et IonTextarea}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Part "native" : l'input ou textarea HTML natif */
ion-input::part(native) {
  background: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 6px;
  padding: 12px;
  font-size: 16px;
}

/* Focus state */
ion-input::part(native):focus {
  border-color: #007bff;
  box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
  outline: none;
}

/* Placeholder styling */
ion-input::part(native)::placeholder {
  color: #6c757d;
  font-style: italic;
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonCheckbox}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Part "container" : conteneur principal */
ion-checkbox::part(container) {
  border-radius: 50%;
  border: 2px solid #28a745;
}

/* Part "mark" : la coche */
ion-checkbox::part(mark) {
  background: #28a745;
  transform: scale(1.2);
}

/* \'Etat check\'e */
ion-checkbox.checkbox-checked::part(container) {
  background: #28a745;
  border-color: #28a745;
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonRange}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Part "track" : la piste du slider */
ion-range::part(track) {
  background: #e9ecef;
  height: 8px;
  border-radius: 4px;
}

/* Part "track-active" : partie active de la piste */
ion-range::part(track-active) {
  background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
  height: 8px;
}

/* Part "knob" : le curseur */
ion-range::part(knob) {
  background: #ffffff;
  border: 3px solid #007bff;
  width: 24px;
  height: 24px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
}
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonProgressBar}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Part "track" : la piste de fond */
ion-progress-bar::part(track) {
  background: #f1f3f4;
  height: 12px;
  border-radius: 6px;
}

/* Part "progress" : la barre de progression */
ion-progress-bar::part(progress) {
  background: linear-gradient(45deg, #667eea, #764ba2);
  border-radius: 6px;
  position: relative;
  overflow: hidden;
}

/* Animation de brillance */
ion-progress-bar::part(progress)::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
  animation: shine 2s infinite;
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Combinaison avec les variables CSS}

Les Shadow Parts peuvent \^etre combin\'ees avec les variables CSS d'Ionic pour une approche hybride :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* D\'efinition de variables globales */
:root {
  --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  --border-radius-custom: 12px;
  --shadow-custom: 0 4px 12px rgba(0, 0, 0, 0.15);
}

/* Utilisation dans les Shadow Parts */
ion-button::part(native) {
  background: var(--primary-gradient);
  border-radius: var(--border-radius-custom);
  box-shadow: var(--shadow-custom);
  border: none;
  color: white;
  font-weight: 600;
  transition: all 0.3s ease;
}

/* Variantes th\'ematiques */
ion-button.button-secondary::part(native) {
  --primary-gradient: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Personnalisation avanc\'ee avec pseudo-classes}

Les Shadow Parts supportent les pseudo-classes pour des interactions complexes :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* \'Etats interactifs */
ion-button::part(native):hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(0, 0, 0, 0.25);
}

ion-button::part(native):active {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

/* \'Etats de validation pour les inputs */
ion-input.ion-valid::part(native) {
  border-color: #28a745;
  background: rgba(40, 167, 69, 0.05);
}

ion-input.ion-invalid::part(native) {
  border-color: #dc3545;
  background: rgba(220, 53, 69, 0.05);
}

/* Focus avec validation */
ion-input.ion-invalid.ion-focused::part(native) {
  box-shadow: 0 0 0 3px rgba(220, 53, 69, 0.25);
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Responsive design avec Shadow Parts}

Les Shadow Parts fonctionnent parfaitement avec les media queries :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Design desktop */
@media (min-width: 768px) {
  ion-button::part(native) {
    padding: 16px 32px;
    font-size: 18px;
    border-radius: 8px;
  }
  
  ion-input::part(native) {
    padding: 16px;
    font-size: 16px;
  }
}

/* Design mobile */
@media (max-width: 767px) {
  ion-button::part(native) {
    padding: 12px 20px;
    font-size: 16px;
    border-radius: 25px;
    width: 100%;
  }
  
  ion-input::part(native) {
    padding: 14px;
    font-size: 16px; /* \'Evite le zoom sur iOS */
  }
}
\end{lstlisting}
\end{tcolorbox}

\subsection*{Bonnes pratiques}

\begin{itemize}
\item \textbf{Documentation} : Consultez la documentation Ionic pour conna\^itre les parts disponibles
\item \textbf{Sp\'ecificit\'e} : Les Shadow Parts ont une sp\'ecificit\'e \'elev\'ee, utilisez-les judicieusement
\item \textbf{Performance} : \'Evitez les selectors trop complexes avec les Shadow Parts
\item \textbf{Maintenance} : Groupez les styles li\'es dans des fichiers CSS d\'edi\'es
\item \textbf{Tests} : Testez sur diff\'erents navigateurs pour la compatibilit\'e
\item \textbf{Fallbacks} : Pr\'evoyez des fallbacks pour les navigateurs non compatibles
\end{itemize}

\subsection*{Outils de d\'eveloppement}

Pour identifier les Shadow Parts disponibles :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
/* Inspection dans les DevTools */
// 1. Ouvrir les DevTools
// 2. S\'electionner un composant Ionic
// 3. Dans l'onglet Elements, chercher les attributs "part"
// 4. Tester les styles directement dans l'onglet Styles

/* Exemple de debug CSS */
ion-button::part(native) {
  outline: 2px solid red !important; /* Pour visualiser */
}
\end{lstlisting}
\end{tcolorbox}

Les CSS Shadow Parts offrent une m\'ethode moderne et robuste pour personnaliser les composants Ionic tout en respectant l'architecture des Web Components.



\subsection{Composants ionic-react réutilisable}
Les composants réutilsables sont au coeur de l ecosystemes des frameworks js notament react,angual,vue ...

Pour cette approche, contrairement à celle abordée dans le chapitre React Native avec le framework Expo, essayons une approche élégante que je trouve
intéressante.\newline

Créer un nouveau projet .Ensuite faite ceci :
\begin{itemize}
  \item \textcolor{gray}{CardProfileItem.tsx}:C est le fichier de notre composant nommé \textcolor{gray}{CardProfileItem} dans le dossier \textbf{composants/} 
  \item \textcolor{gray}{Profiles.tsx}:Le fichier du servira pour rentre la liste des \textcolor{gray}{CardProfileItem} dans le dossier \textcolor{gray}{pages/}
  \item \textcolor{gray}{data/CardProfileData.tsx}:Le dossier qui contiendrait un tableau statiques des données sous forme des objets js afin de simuler les données qui proviendrait dans \textcolor{gray}{src/} .
  de votre API en backend ou API comme facker.
\end{itemize}

\vspace{0.5cm}

Votre arborescence devrait ressemble à ceci :

\dirtree{%
.1 \textcolor{gray}{src/}.
.2 \textcolor{gray}{colors/} \DTcomment{\textcolor{gray}{Dossier des fichiers de couleurs}}.
.2 \textcolor{gray}{components/}.
.3 \textcolor{gray}{CardProfileItem.tsx} \DTcomment{\textcolor{gray}{Composant CardProfileItem TypeScript React}}.
.2 \textcolor{gray}{constant} \DTcomment{\textcolor{gray}{Dossier des fichiers constants}}.
.2 \textcolor{gray}{data} \DTcomment{\textcolor{gray}{Dossier des fichiers de données}}.
.3 \textcolor{gray}{CardProfileData.tsx} \DTcomment{\textcolor{gray}{Données pour CardProfile TypeScript}}.
.2 \textcolor{gray}{pages/}.
.3 \textcolor{gray}{Profiles.tsx} \DTcomment{\textcolor{gray}{Page Profiles TypeScript React}}.
.2 \textcolor{gray}{styles/}.
.3 \textcolor{gray}{CardProfileItem.css} \DTcomment{\textcolor{gray}{Feuille de style pour CardProfileItem}}.
}


\subsubsection{CardProfileItem.tsx}

\begin{jscode}
import { IonCard, IonAvatar, IonCardContent, IonText } from "@ionic/react";

export interface ProfileCardProps {
  avatarSrc?: string;
  avatarAlt?: string;
  name?: string;
}

const CardProfileItem: React.FC<ProfileCardProps> = ({
  avatarSrc = "/public/favicon.png",
  avatarAlt = "profil",
  name = "Dr Reason Knowledge",
}) => {
  return (
    <IonCard>
      <div className="flex items-center px-4 py-3">
        <IonAvatar className="mr-3">
          <img
            src={avatarSrc}
            alt={avatarAlt}
            className="w-14 h-14 rounded-full"
          />
        </IonAvatar>
        <IonCardContent className="p-0">
          <IonText className="text-lg font-bold">
            {name}
          </IonText>
        </IonCardContent>
      </div>
    </IonCard>
  );
};

export default CardProfileItem;

\end{jscode}



\textbf{Explication:}

\begin{flushleft}
  Composant \textcolor{gray}{CardProfileItem} typé en TypeScript avec 3 props ayant des valurs par defauts définis via l'interface \textcolor{gray}{ProfileCardProps} qui permettent de personnaliser la carte de profil :
\end{flushleft}

\begin{itemize}
\item \textcolor{gray}{avatarSrc} : Chemin de l'image de l'avatar (par défaut : "/public/favicon.png").
\item \textcolor{gray}{avatarAlt} : Texte alternatif pour l'image de l'avatar (par défaut : "profile").
\item \textcolor{gray}{name} : Nom ou titre affiché dans la carte (par défaut : "Dr Reason Knowledge").
\end{itemize}


\subsubsection{ProfileCardProps}

\begin{jscode}
  import { ProfileCardProps } from "../components/CardProfileItem";

export const profileData: ProfileCardProps[] = [
  {
    avatarSrc: "/public/favicon.png",
    avatarAlt: "Profil de Dr Jane Smith",
    name: "Dr Jane Smith",
  },
  {
    avatarSrc: "/public/favicon.png",
    avatarAlt: "Profil de Dr John Doe",
    name: "Dr John Doe",
  },
  {
    avatarSrc: "/public/avatars/user3.png",
    avatarAlt: "Profil de Dr Emily Brown",
    name: "Dr Emily Brown",
  },
  {
    avatarSrc: "/public/avatars/user4.png",
    avatarAlt: "Profil de Dr Michael Lee",
    name: "Dr Michael Lee",
  },
  {
    avatarSrc: "/public/avatars/user5.png",
    avatarAlt: "Profil de Dr Sarah Wilson",
    name: "Dr Sarah Wilson",
  },
];

\end{jscode}

\textbf{Tableau des données statiques} pour sumuler les donnés provenant de votre API.Deux choses importantes ici : \newline

\begin{enumerate}
  \item \textcolor{gray}{profileData}: la constante \textbf{profileData} est typé via l interface \textbf{ProfileCardProps} qui est de type \textcolor{gray}{tableau} d ou l importance de son import dans le fichier 
  \textbf{CardProfileItem}
  \item \textcolor{gray}{Objets de profileData}:Vous constatez que les bobjet suivent la natures props ( avatarSrc ,avatarAlt et name) de CardProfileItem en respectant leur types c est a dire des strings
\end{enumerate}


\subsubsection{Profiles.tsx}
\begin{jscode}
import {
  IonContent,
  IonHeader,
  IonPage,
  IonTitle,
  IonToolbar,
} from "@ionic/react";
import CardProfileItem from "../components/CardProfileItem";
import { profileData } from "../data/CardProfildata";
import "../styles/Tab3.css";

const Profiles: React.FC = () => {
  return (
    <IonPage>
      <IonHeader>
        <IonToolbar>
          <IonTitle>Tab 3</IonTitle>
        </IonToolbar>
      </IonHeader>
      <IonContent fullscreen className="bg-white p-4">
        <div className="space-y-4">
          {profileData.map((profile, index) => (
            <CardProfileItem
              key={index}
              avatarSrc={profile.avatarSrc}
              avatarAlt={profile.avatarAlt}
              name={profile.name}
            />
          ))}
        </div>
      </IonContent>
    </IonPage>
  );
};

export default Profiles;
\end{jscode}

\textbf{Rendu du Composant CardProfileItem}
Ici on boucle sur le tableau profileData .On aurait pu faire le tout dans un seul fichier comme le dans l exemple suivant





\subsection{Navigation en Ionic React}

\section*{Navigation dans Ionic React}

La navigation dans Ionic React combine la puissance de React Router avec les composants de navigation natifs d'Ionic, offrant une expérience utilisateur fluide et intuitive sur mobile. Ionic React utilise React Router comme base pour la gestion des routes tout en ajoutant des animations et des comportements natifs sp\'ecifiques aux plateformes mobiles.

\subsection*{Composants de navigation principaux}

\subsubsection*{IonRouterOutlet}

\texttt{IonRouterOutlet} est le composant central qui remplace le \texttt{Switch} de React Router standard. Il gère les animations de transition entre les pages et maintient l'historique de navigation.

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { IonRouterOutlet } from '@ionic/react';
import { Route } from 'react-router-dom';

<IonRouterOutlet>
  <Route exact path="/home" component={Home} />
  <Route exact path="/about" component={About} />
</IonRouterOutlet>
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonTabs}

Pour cr\'eer une navigation par onglets, Ionic propose \texttt{IonTabs} qui g\`ere automatiquement l'affichage des onglets et leur \'etat actif.

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { IonTabs, IonTabBar, IonTabButton, IonIcon, IonLabel } from '@ionic/react';

<IonTabs>
  <IonRouterOutlet>
    <Route exact path="/tabs/home" component={Home} />
    <Route exact path="/tabs/profile" component={Profile} />
  </IonRouterOutlet>
  
  <IonTabBar slot="bottom">
    <IonTabButton tab="home" href="/tabs/home">
      <IonIcon icon={home} />
      <IonLabel>Accueil</IonLabel>
    </IonTabButton>
    <IonTabButton tab="profile" href="/tabs/profile">
      <IonIcon icon={person} />
      <IonLabel>Profil</IonLabel>
    </IonTabButton>
  </IonTabBar>
</IonTabs>
\end{lstlisting}
\end{tcolorbox}

\subsection*{Techniques de navigation}

\subsubsection*{Navigation programmatique}

Ionic React offre plusieurs m\'ethodes pour naviguer programmatiquement :

\begin{itemize}
\item \textbf{useHistory Hook} : Utilise le hook React Router pour la navigation
\item \textbf{useIonRouter Hook} : Hook sp\'ecifique Ionic avec fonctionnalit\'es avanc\'ees
\item \textbf{Props de navigation} : Via les props pass\'ees aux composants
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { useHistory, useIonRouter } from '@ionic/react';

const MyComponent = () => {
  const history = useHistory();
  const ionRouter = useIonRouter();
  
  const navigateToPage = () => {
    history.push('/about');
    
    ionRouter.push('/about', 'forward');
  };
  
  return <IonButton onClick={navigateToPage}>Naviguer</IonButton>;
};
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Navigation avec param\`etres}

Les param\`etres peuvent \^etre pass\'es via l'URL ou l'\'etat de navigation :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
history.push('/user/123');

history.push('/user', { userId: 123, userData: {...} });

import { useParams, useLocation } from 'react-router-dom';

const UserProfile = () => {
  const { id } = useParams();
  const location = useLocation();
  const userData = location.state?.userData;
  
  return <div>Utilisateur ID: {id}</div>;
};
\end{lstlisting}
\end{tcolorbox}

\subsection*{Animations et transitions}

Ionic React g\`ere automatiquement les animations de transition selon la plateforme :

\begin{itemize}
\item \textbf{iOS} : Animations de glissement lat\'eral (slide)
\item \textbf{Android} : Animations de type Material Design
\item \textbf{Web} : Animations adapt\'ees au navigateur
\end{itemize}

Les animations peuvent \^etre personnalis\'ees :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { createAnimation } from '@ionic/react';

const customAnimation = (baseEl: any, opts?: any) => {
  const root = baseEl.shadowRoot || baseEl;
  const enteringEl = root.querySelector(':host > ion-content');
  
  const animation = createAnimation()
    .addElement(enteringEl)
    .duration(300)
    .easing('ease-in-out')
    .fromTo('opacity', 0, 1);
    
  return animation;
};

<IonRouterOutlet animation={customAnimation}>
\end{lstlisting}
\end{tcolorbox}

\subsection*{Navigation hi\'erarchique}

Pour les applications avec une navigation complexe, Ionic propose plusieurs patterns :

\subsubsection*{Stack Navigation}

Navigation empil\'ee avec bouton retour automatique :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
<IonHeader>
  <IonToolbar>
    <IonButtons slot="start">
      <IonBackButton defaultHref="/home" />
    </IonButtons>
    <IonTitle>D\'etails</IonTitle>
  </IonToolbar>
</IonHeader>
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{Menu lateral}

Navigation avec menu coulissant :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { IonMenu, IonMenuButton } from '@ionic/react';

<IonMenu contentId="main-content">
  <IonHeader>
    <IonToolbar>
      <IonTitle>Menu</IonTitle>
    </IonToolbar>
  </IonHeader>
  <IonContent>
    <IonList>
      <IonItem routerLink="/home">
        <IonLabel>Accueil</IonLabel>
      </IonItem>
    </IonList>
  </IonContent>
</IonMenu>

<IonPage id="main-content">
  <IonHeader>
    <IonToolbar>
      <IonButtons slot="start">
        <IonMenuButton />
      </IonButtons>
      <IonTitle>Page principale</IonTitle>
    </IonToolbar>
  </IonHeader>
</IonPage>
\end{lstlisting}
\end{tcolorbox}


\subsection*{Bonnes pratiques}

\begin{itemize}
\item \textbf{Utiliser IonRouterOutlet} : Toujours utiliser ce composant au lieu de Switch
\item \textbf{Respecter la hi\'erarchie} : Organiser les routes de mani\`ere logique
\item \textbf{G\'erer l'historique} : Utiliser correctement les m\'ethodes push/replace
\item \textbf{Optimiser les performances} : Utiliser le lazy loading pour les routes
\item \textbf{Tester sur device} : V\'erifier le comportement sur appareils r\'eels
\item \textbf{Accessibilit\'e} : S'assurer que la navigation est accessible
\end{itemize}

\subsection*{Lazy Loading}

Pour optimiser les performances, impl\'ementer le chargement paresseux :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { lazy, Suspense } from 'react';

const HomePage = lazy(() => import('./pages/HomePage'));
const AboutPage = lazy(() => import('./pages/AboutPage'));

<IonRouterOutlet>
  <Route exact path="/home">
    <Suspense fallback={<IonSpinner />}>
      <HomePage />
    </Suspense>
  </Route>
</IonRouterOutlet>
\end{lstlisting}
\end{tcolorbox}





\subsection{Integration des fonctionalité natifs:Capacitor et Cordova}

\section*{Apache Cordova}

Apache Cordova a été l'un des premiers frameworks à permettre le développement d'applications mobiles hybrides en utilisant les technologies web (HTML, CSS, JavaScript). Lancé en 2009, Cordova a révolutionné le développement mobile en offrant une alternative aux applications natives traditionnelles.

\subsection*{Principe de fonctionnement de Cordova}

Cordova encapsule les applications web dans un conteneur natif, permettant ainsi de déployer des applications web sur les app stores comme de véritables applications natives. Le framework fonctionne selon les principes suivants :

\begin{itemize}
\item \textbf{WebView natif} : L'application s'exécute dans une WebView intégrée à l'application native
\item \textbf{Plugins} : Accès aux APIs natives du device via un système de plugins
\item \textbf{Bridge JavaScript} : Communication entre le code JavaScript et les fonctions natives
\item \textbf{Multi-plateforme} : Un seul code base pour iOS, Android, et autres plateformes
\end{itemize}

\subsection*{Avantages de Cordova}

\begin{itemize}
\item \textbf{Réutilisation du code} : Une base de code unique pour toutes les plateformes
\item \textbf{Compétences web} : Utilisation des technologies web familières
\item \textbf{Développement rapide} : Cycles de développement plus courts
\item \textbf{Écosystème riche} : Large gamme de plugins disponibles
\item \textbf{Coût réduit} : Moins de ressources nécessaires qu'un développement natif multiple
\end{itemize}

\subsection*{Limitations de Cordova}

Malgré ses avantages, Cordova présente certaines limitations qui ont motivé le développement de solutions plus modernes :

\begin{itemize}
\item \textbf{Performance} : Les performances peuvent être inférieures aux applications natives
\item \textbf{Interface utilisateur} : Difficultés à reproduire parfaitement l'UX native
\item \textbf{Taille des applications} : Applications généralement plus volumineuses
\item \textbf{Maintenance} : Dépendance aux mises à jour des plugins tiers
\item \textbf{Debugging complexe} : Débogage plus difficile entre les couches web et native
\end{itemize}

\section*{Capacitor : L'évolution moderne}

Face aux limitations de Cordova, l'équipe d'Ionic a développé Capacitor comme successeur moderne et plus performant. Capacitor conserve les avantages du développement hybride tout en résolvant les principaux problèmes de Cordova.

Capacitor permet au JavaScript d'interagir directement avec les APIs natives.
Les applications web peuvent accéder à toute la puissance des APIs natives grâce aux plugins, qui encapsulent les opérations natives communes tout en exposant une API cohérente et cross-platform au JavaScript.

\subsection*{Architecture de Capacitor}

Capacitor fonctionne comme une couche d'abstraction moderne :

\begin{itemize}
\item \textbf{WebView} : Affiche votre app web avec des performances optimisées
\item \textbf{Bridge} : Communication bidirectionnelle JS $\leftrightarrow$ Native
\item \textbf{Plugins} : Accès aux fonctionnalités du device
\item \textbf{Configuration} : Gestion centralisée des paramètres d'application
\item \textbf{Runtime} : Gestion du cycle de vie de l'app
\end{itemize}

\subsection*{Avantages de Capacitor par rapport à Cordova}

\begin{itemize}
\item \textbf{Performance améliorée} : WebView plus moderne et optimisée
\item \textbf{Développement natif simplifié} : Accès direct aux projets iOS/Android
\item \textbf{Plugins modernes} : API plus cohérente et maintenue par l'équipe Ionic
\item \textbf{Configuration simplifiée} : Moins de fichiers de configuration complexes
\item \textbf{Debugging facilité} : Meilleurs outils de débogage et inspection
\item \textbf{Progressive Web App} : Support natif des PWA
\end{itemize}

\subsection{Build et deploiement}

\subsubsection{Build}
Pour build votre application native il faut :


\section{Ionic Vue}

% Subsection for introducing Ionic Vue
\subsection{Ionic Vue}
Ionic Vue est la version d'Ionic conçue pour construire des applications mobiles en utilisant Vue 3 avec l'API de composition, TypeScript et la syntaxe \texttt{<script setup>}. Elle fournit une collection de composants UI optimisés pour le mobile et des outils pour accélérer le développement d'applications hybrides.

% Links to official documentation
\href{https://ionicframework.com/docs/vue/overview}{Documentation Ionic Vue} \newline
\href{https://vuejs.org/}{Documentation Vue 3}

% Unnumbered section for architecture and operation
\section*{Architecture et fonctionnement d'Ionic Vue}
\begin{itemize}
  \item \textbf{Vue 3} : Utilisation exclusive de l'API de composition avec \texttt{<script setup>} pour la logique et les composants.
  \item \textbf{Capacitor} : Accès aux fonctionnalités natives via des plugins modernes.
  \item \textbf{WebView} : Rendu de l'application dans une WebView optimisée pour mobile.
  \item \textbf{Composants UI pré-construits} : Offrent un design natif pour iOS et Android.
\end{itemize}

% Subsection for project installation and structure
\subsection{Installation d'un projet Ionic Vue : structure de base}
Pour démarrer un projet Ionic Vue avec TypeScript, l'API de composition et \texttt{<script setup>}, utilisez la CLI Ionic comme suit :

% Unnumbered subsection for project creation
\subsection*{Création d'un projet Ionic Vue}
Voici les options pour créer un projet Ionic Vue avec différents templates, en privilégiant TypeScript et l'API de composition :

\begin{itemize}
  \item \textbf{Vérifiez la liste des templates disponibles} : \textcolor{gray600}{ionic start --list}
  \item \textbf{Option 1 - Template blank} : Page unique pour débuter. \\
    \subitem \textcolor{gray600}{ionic start MonApp blank --type=vue --typescript}
  \item \textbf{Option 2 - Template tabs} : Navigation par onglets. \\
    \subitem \textcolor{gray600}{ionic start MonApp tabs --type=vue --typescript}
  \item \textbf{Option 3 - Template sidemenu} : Menu latéral coulissant. \\
    \subitem \textcolor{gray600}{ionic start MonApp sidemenu --type=vue --typescript}
\end{itemize}

% Subsection for project structure
\subsection*{Structure d'un projet Ionic Vue TypeScript}
Voici l'arborescence par défaut d'un projet Ionic Vue créé avec TypeScript et l'API de composition :

\dirtree{%
.1 \textcolor{gray}{ionic-vue/}.
.2 \textcolor{gray}{.git/} \DTcomment{\textcolor{gray}{Dossier de gestion Git}}.
.2 \textcolor{gray}{.vscode/} \DTcomment{\textcolor{gray}{Configuration Visual Studio Code}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{public/} \DTcomment{\textcolor{gray}{Fichiers statiques servis directement}}.
.2 \textcolor{gray}{src/} \DTcomment{\textcolor{gray}{Code source de l'application}}.
.3 \textcolor{gray}{assets/} \DTcomment{\textcolor{gray}{Ressources statiques (images, etc.)}}.
.3 \textcolor{gray}{components/} \DTcomment{\textcolor{gray}{Composants réutilisables Vue}}.
.3 \textcolor{gray}{composables/} \DTcomment{\textcolor{gray}{Composables pour l'API de composition}}.
.3 \textcolor{gray}{router/} \DTcomment{\textcolor{gray}{Configuration du routeur Vue}}.
.3 \textcolor{gray}{views/} \DTcomment{\textcolor{gray}{Vues/écrans de l'application}}.
.3 \textcolor{gray}{theme/} \DTcomment{\textcolor{gray}{Configuration des thèmes CSS}}.
.4 \textcolor{gray}{variables.css} \DTcomment{\textcolor{gray}{Variables CSS personnalisées}}.
.3 \textcolor{gray}{App.vue} \DTcomment{\textcolor{gray}{Composant racine Vue avec \texttt{<script setup>}}}.
.3 \textcolor{gray}{main.ts} \DTcomment{\textcolor{gray}{Point d'entrée TypeScript avec Vite}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichiers ignorés par Git}}.
.2 \textcolor{gray}{capacitor.config.ts} \DTcomment{\textcolor{gray}{Configuration Capacitor TypeScript}}.
.2 \textcolor{gray}{index.html} \DTcomment{\textcolor{gray}{Page HTML principale}}.
.2 \textcolor{gray}{ionic.config.json} \DTcomment{\textcolor{gray}{Configuration du CLI Ionic}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Fichier des Métadonnées ,script ,dépendances du projet}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration TypeScript}}.
.2 \textcolor{gray}{vite.config.ts} \DTcomment{\textcolor{gray}{Configuration Vite}}.
}

% Subsection for Ionic UI components
\subsection{Composants UI Ionic}
Ionic Vue propose une gamme de composants UI optimisés pour le mobile, compatibles avec l'API de composition et \texttt{<script setup>}. Voici quelques exemples :

\begin{enumerate}
  \item \textbf{IonCard} : Affiche du contenu dans des cartes, idéal pour listes ou profils.
  \item \textbf{IonInput} : Champs de saisie avec validation et styles natifs.
  \item \textbf{IonList} : Listes d'éléments avec séparateurs, pour menus ou données.
  \item \textbf{IonItem} : Conteneur pour éléments de liste, souvent avec \texttt{IonList}.
  \item \textbf{IonHeader} : En-tête de page avec titre et boutons de navigation.
  \item \textbf{IonToolbar} : Organise boutons et titres dans headers/footers.
  \item \textbf{IonContent} : Conteneur principal scrollable pour le contenu.
  \item \textbf{IonTabs} : Navigation par onglets en bas de l'écran.
  \item \textbf{IonModal} : Fenêtre modale pour contenu overlay.
  \item \textbf{IonAlert} : Alertes et confirmations natives.
  \item \textbf{IonToast} : Notifications temporaires en haut ou en bas.
  \item \textbf{IonActionSheet} : Liste d'actions contextuelles depuis le bas.
  \item \textbf{IonPopover} : Contenu contextuel dans une bulle.
  \item \textbf{IonCheckbox} : Cases à cocher avec animations natives.
  \item \textbf{IonRadio} : Boutons radio pour sélection unique.
  \item \textbf{IonToggle} : Interrupteurs on/off avec animations.
  \item \textbf{IonSelect} : Listes déroulantes avec interface native.
  \item \textbf{IonDatetime} : Sélection de dates/heures avec interface native.
  \item \textbf{IonRange} : Curseurs pour valeurs numériques.
  \item \textbf{IonSearchbar} : Barres de recherche avec fonctionnalités intégrées.
  \item \textbf{IonRefresher} : Fonctionnalité "pull-to-refresh" pour listes.
  \item \textbf{IonInfiniteScroll} : Chargement infini au défilement.
  \item \textbf{IonFab} : Boutons d'action flottants (FAB).
  \item \textbf{IonGrid, IonRow, IonCol} : Layouts responsives basés sur grille.
  \item \textbf{IonSpinner} : Indicateurs de chargement animés.
  \item \textbf{IonProgressBar} : Progression de tâches.
  \item \textbf{IonBadge} : Compteurs ou labels colorés.
  \item \textbf{IonChip} : Étiquettes compactes avec option de fermeture.
  \item \textbf{IonAvatar} : Images de profil circulaires.
  \item \href{https://ionicframework.com/docs/components}{Documentation des composants Ionic}
\end{enumerate}


\subsection{Composants ionic-vue réutilisable}


% Unnumbered section for advantages and disadvantages
\section*{Avantages d'Ionic Vue}
\begin{itemize}
  \item Un seul codebase pour web, iOS, Android et desktop.
  \item Composants UI riches avec design Material/iOS automatique.
  \item Développement rapide avec Vue 3, l'API de composition et \texttt{<script setup>}.
  \item Support des Progressive Web Apps (PWA).
\end{itemize}

\section*{Inconvénients d'Ionic Vue}
\begin{itemize}
  \item Performance moindre comparée aux applications natives.
  \item Dépendance au WebView, pouvant être plus lent.
  \item Taille d'application plus importante.
  \item Expérience utilisateur parfois moins fluide.
\end{itemize}

% Subsection for UI component customization
\subsubsection{Personnalisation des composants UI}
La personnalisation des composants est essentielle pour une interface esthétique et fonctionnelle, en utilisant l'API de composition avec \texttt{<script setup>} :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<template>
  <ion-button :color="buttonColor" @click="handleClick">Bouton Personnalis\'e</ion-button>
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import { IonButton } from '@ionic/vue';

const buttonColor = ref('primary');
const handleClick = () => {
  buttonColor.value = buttonColor.value === 'primary' ? 'secondary' : 'primary';
};
</script>

<style scoped>
ion-button {
  --border-radius: 10px;
  --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
</style>
\end{lstlisting}
\end{tcolorbox}

% Unnumbered section for CSS custom properties
\section*{CSS Custom Properties en Ionic Vue}
Les CSS Custom Properties permettent de personnaliser l'apparence des composants de manière cohérente. Elles utilisent la syntaxe \texttt{--nom-variable} et sont héritées dans le DOM.

\subsection*{Syntaxe de base}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
/* D\'efinition dans variables.css */
:root {
  --ion-color-primary: #3880ff;
  --ion-color-secondary: #3dc2ff;
}

/* Utilisation dans un composant */
.custom-button {
  background: var(--ion-color-primary);
  color: var(--ion-color-primary-contrast);
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for global color variables
\subsection*{Variables de couleurs globales}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
:root {
  --ion-color-primary: #3880ff;
  --ion-color-primary-rgb: 56, 128, 255;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-secondary: #3dc2ff;
  --ion-color-success: #2dd36f;
  --ion-color-warning: #ffc409;
  --ion-color-danger: #eb445a;
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for dark theme
\subsection*{Thème sombre automatique}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
@media (prefers-color-scheme: dark) {
  :root {
    --ion-color-primary: #428cff;
    --ion-background-color: #121212;
    --ion-text-color: #ffffff;
  }
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for component-specific variables
\subsection*{Variables par composant}
\subsubsection*{IonButton}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
ion-button {
  --background: #3880ff;
  --color: #ffffff;
  --border-radius: 4px;
  --padding-start: 16px;
  --padding-end: 16px;
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for navigation in Ionic Vue
\subsection{Navigation en Ionic Vue}
Ionic Vue utilise Vue Router avec des composants Ionic pour une navigation fluide et native, optimisée avec l'API de composition et \texttt{<script setup>}.

\subsubsection*{IonRouterOutlet}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<template>
  <ion-router-outlet>
    <router-view />
  </ion-router-outlet>
</template>

<script lang="ts" setup>
import { IonRouterOutlet } from '@ionic/vue';
</script>
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonTabs}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<template>
  <ion-tabs>
    <ion-router-outlet></ion-router-outlet>
    <ion-tab-bar slot="bottom">
      <ion-tab-button tab="home" href="/home">
        <ion-icon :icon="home" />
        <ion-label>Accueil</ion-label>
      </ion-tab-button>
    </ion-tab-bar>
  </ion-tabs>
</template>

<script lang="ts" setup>
import { IonTabs, IonTabBar, IonTabButton, IonIcon, IonLabel } from '@ionic/vue';
import { home } from 'ionicons/icons';
</script>
\end{lstlisting}
\end{tcolorbox}

% Subsection for programmatic navigation
\subsubsection*{Navigation programmatique}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<template>
  <ion-button @click="navigateToPage">Naviguer</ion-button>
</template>

<script lang="ts" setup>
import { useRouter } from 'vue-router';
import { IonButton } from '@ionic/vue';

const router = useRouter();
const navigateToPage = () => {
  router.push('/about');
};
</script>
\end{lstlisting}
\end{tcolorbox}

% Subsection for Capacitor integration
\subsection{Intégration des fonctionnalités natives : Capacitor}
Capacitor permet d'accéder aux fonctionnalités natives dans Ionic Vue en utilisant l'API de composition avec \texttt{<script setup>}.

\begin{itemize}
  \item \textbf{WebView} : Rendu optimisé pour mobile.
  \item \textbf{Plugins} : Accès aux APIs natives via plugins.
  \item \textbf{Bridge} : Communication JavaScript $\leftrightarrow$ Native.
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<template>
  <ion-button @click="takePhoto">Prendre une photo</ion-button>
  <img v-if="photo" :src="photo" alt="Photo">
</template>

<script lang="ts" setup>
import { ref } from 'vue';
import { IonButton } from '@ionic/vue';
import { Camera, CameraResultType } from '@capacitor/camera';

const photo = ref<string | null>(null);
const takePhoto = async () => {
  const image = await Camera.getPhoto({
    resultType: CameraResultType.Uri,
    quality: 90,
  });
  photo.value = image.webPath ?? null;
};
</script>
\end{lstlisting}
\end{tcolorbox}










































\section{Ionic Angualr}


% Subsection for introducing Ionic Angular
\subsection{Ionic Angular}
Ionic Angular est la version d'Ionic conçue pour construire des applications mobiles en utilisant Angular avec TypeScript. Elle fournit une collection de composants UI optimisés pour le mobile et des outils pour accélérer le développement d'applications hybrides.

% Links to official documentation
\href{https://ionicframework.com/docs/angular/overview}{Documentation Ionic Angular} \newline
\href{https://angular.io/}{Documentation Angular}

% Unnumbered section for architecture and operation
\section*{Architecture et fonctionnement d'Ionic Angular}
\begin{itemize}
  \item \textbf{Angular} : Utilisation du framework Angular pour la logique et les composants.
  \item \textbf{Capacitor} : Accès aux fonctionnalités natives via des plugins modernes.
  \item \textbf{WebView} : Rendu de l'application dans une WebView optimisée pour mobile.
  \item \textbf{Composants UI pré-construits} : Offrent un design natif pour iOS et Android.
\end{itemize}

% Subsection for project installation and structure
\subsection{Installation d'un projet Ionic Angular : structure de base}
Pour démarrer un projet Ionic Angular avec TypeScript, utilisez la CLI Ionic comme suit :

% Unnumbered subsection for project creation
\subsection*{Création d'un projet Ionic Angular}
Voici les options pour créer un projet Ionic Angular avec différents templates :

\begin{itemize}
  \item \textbf{Vérifiez la liste des templates disponibles} : \textcolor{gray600}{ionic start --list}
  \item \textbf{Option 1 - Template blank} : Page unique pour débuter. \\
    \subitem \textcolor{gray600}{ionic start MonApp blank --type=angular}
  \item \textbf{Option 2 - Template tabs} : Navigation par onglets. \\
    \subitem \textcolor{gray600}{ionic start MonApp tabs --type=angular}
  \item \textbf{Option 3 - Template sidemenu} : Menu latéral coulissant. \\
    \subitem \textcolor{gray600}{ionic start MonApp sidemenu --type=angular}
\end{itemize}

% Subsection for project structure
\subsection*{Structure d'un projet Ionic Angular TypeScript}
Voici l'arborescence par défaut d'un projet Ionic Angular créé avec TypeScript :

\dirtree{%
.1 \textcolor{gray}{ionic-angular/}.
.2 \textcolor{gray}{.git/} \DTcomment{\textcolor{gray}{Dossier de gestion Git}}.
.2 \textcolor{gray}{.vscode/} \DTcomment{\textcolor{gray}{Configuration Visual Studio Code}}.
.2 \textcolor{gray}{node\_modules/} \DTcomment{\textcolor{gray}{Dépendances installées par npm}}.
.2 \textcolor{gray}{src/} \DTcomment{\textcolor{gray}{Code source de l'application}}.
.3 \textcolor{gray}{app/} \DTcomment{\textcolor{gray}{Composants, modules et services Angular}}.
.4 \textcolor{gray}{components/} \DTcomment{\textcolor{gray}{Composants réutilisables Angular}}.
.4 \textcolor{gray}{pages/} \DTcomment{\textcolor{gray}{Pages/écrans de l'application}}.
.4 \textcolor{gray}{services/} \DTcomment{\textcolor{gray}{Services pour la logique métier}}.
.4 \textcolor{gray}{app.component.ts} \DTcomment{\textcolor{gray}{Composant racine Angular}}.
.4 \textcolor{gray}{app.module.ts} \DTcomment{\textcolor{gray}{Module principal Angular}}.
.4 \textcolor{gray}{app-routing.module.ts} \DTcomment{\textcolor{gray}{Configuration du routeur Angular}}.
.3 \textcolor{gray}{assets/} \DTcomment{\textcolor{gray}{Ressources statiques (images, etc.)}}.
.3 \textcolor{gray}{theme/} \DTcomment{\textcolor{gray}{Configuration des thèmes CSS}}.
.4 \textcolor{gray}{variables.css} \DTcomment{\textcolor{gray}{Variables CSS personnalisées}}.
.3 \textcolor{gray}{main.ts} \DTcomment{\textcolor{gray}{Point d'entrée TypeScript avec Angular}}.
.2 \textcolor{gray}{.gitignore} \DTcomment{\textcolor{gray}{Fichiers ignorés par Git}}.
.2 \textcolor{gray}{angular.json} \DTcomment{\textcolor{gray}{Configuration Angular CLI}}.
.2 \textcolor{gray}{capacitor.config.ts} \DTcomment{\textcolor{gray}{Configuration Capacitor TypeScript}}.
.2 \textcolor{gray}{index.html} \DTcomment{\textcolor{gray}{Page HTML principale}}.
.2 \textcolor{gray}{ionic.config.json} \DTcomment{\textcolor{gray}{Configuration du CLI Ionic}}.
.2 \textcolor{gray}{package.json} \DTcomment{\textcolor{gray}{Fichier des Métadonnées ,script ,dépendances du projet}}.
.2 \textcolor{gray}{tsconfig.json} \DTcomment{\textcolor{gray}{Configuration TypeScript}}.
}



% Subsection for Ionic UI components
\subsection{Composants UI Ionic}
Ionic Angular propose une gamme de composants UI optimisés pour le mobile, compatibles avec Angular. Voici quelques exemples :

\begin{enumerate}
  \item \textbf{IonCard} : Affiche du contenu dans des cartes, idéal pour listes ou profils.
  \item \textbf{IonInput} : Champs de saisie avec validation et styles natifs.
  \item \textbf{IonList} : Listes d'éléments avec séparateurs, pour menus ou données.
  \item \textbf{IonItem} : Conteneur pour éléments de liste, souvent avec \texttt{IonList}.
  \item \textbf{IonHeader} : En-tête de page avec titre et boutons de navigation.
  \item \textbf{IonToolbar} : Organise boutons et titres dans headers/footers.
  \item \textbf{IonContent} : Conteneur principal scrollable pour le contenu.
  \item \textbf{IonTabs} : Navigation par onglets en bas de l'écran.
  \item \textbf{IonModal} : Fenêtre modale pour contenu overlay.
  \item \textbf{IonAlert} : Alertes et confirmations natives.
  \item \textbf{IonToast} : Notifications temporaires en haut ou en bas.
  \item \textbf{IonActionSheet} : Liste d'actions contextuelles depuis le bas.
  \item \textbf{IonPopover} : Contenu contextuel dans une bulle.
  \item \textbf{IonCheckbox} : Cases à cocher avec animations natives.
  \item \textbf{IonRadio} : Boutons radio pour sélection unique.
  \item \textbf{IonToggle} : Interrupteurs on/off avec animations.
  \item \textbf{IonSelect} : Listes déroulantes avec interface native.
  \item \textbf{IonDatetime} : Sélection de dates/heures avec interface native.
  \item \textbf{IonRange} : Curseurs pour valeurs numériques.
  \item \textbf{IonSearchbar} : Barres de recherche avec fonctionnalités intégrées.
  \item \textbf{IonRefresher} : Fonctionnalité "pull-to-refresh" pour listes.
  \item \textbf{IonInfiniteScroll} : Chargement infini au défilement.
  \item \textbf{IonFab} : Boutons d'action flottants (FAB).
  \item \textbf{IonGrid, IonRow, IonCol} : Layouts responsives basés sur grille.
  \item \textbf{IonSpinner} : Indicateurs de chargement animés.
  \item \textbf{IonProgressBar} : Progression de tâches.
  \item \textbf{IonBadge} : Compteurs ou labels colorés.
  \item \textbf{IonChip} : Étiquettes compactes avec option de fermeture.
  \item \textbf{IonAvatar} : Images de profil circulaires.
  \item \href{https://ionicframework.com/docs/components}{Documentation des composants Ionic}
\end{enumerate}


\subsection{Composants ionic-angualr réutilisable}

% Unnumbered section for advantages and disadvantages
\section*{Avantages d'Ionic Angular}
\begin{itemize}
  \item Un seul codebase pour web, iOS, Android et desktop.
  \item Composants UI riches avec design Material/iOS automatique.
  \item Développement structuré avec Angular et TypeScript.
  \item Support des Progressive Web Apps (PWA).
\end{itemize}

\section*{Inconvénients d'Ionic Angular}
\begin{itemize}
  \item Performance moindre comparée aux applications natives.
  \item Dépendance au WebView, pouvant être plus lent.
  \item Taille d'application plus importante.
  \item Expérience utilisateur parfois moins fluide.
\end{itemize}

% Subsection for UI component customization
\subsubsection{Personnalisation des composants UI}
La personnalisation des composants est essentielle pour une interface esthétique et fonctionnelle, en utilisant Angular avec TypeScript :

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<ion-button [color]="buttonColor" (click)="handleClick()">Bouton Personnalis\'e</ion-button>

<script lang="ts">
import { Component } from '@angular/core';
import { IonicModule } from '@ionic/angular';

@Component({
  selector: 'app-custom-button',
  templateUrl: './custom-button.component.html',
  styleUrls: ['./custom-button.component.scss'],
  standalone: true,
  imports: [IonicModule]
})
export class CustomButtonComponent {
  buttonColor: string = 'primary';

  handleClick() {
    this.buttonColor = this.buttonColor === 'primary' ? 'secondary' : 'primary';
  }
}
</script>

<style scoped>
ion-button {
  --border-radius: 10px;
  --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
</style>
\end{lstlisting}
\end{tcolorbox}

% Unnumbered section for CSS custom properties
\section*{CSS Custom Properties en Ionic Angular}
Les CSS Custom Properties permettent de personnaliser l'apparence des composants de manière cohérente. Elles utilisent la syntaxe \texttt{--nom-variable} et sont héritées dans le DOM.

\subsection*{Syntaxe de base}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
/* D\'efinition dans variables.css */
:root {
  --ion-color-primary: #3880ff;
  --ion-color-secondary: #3dc2ff;
}

/* Utilisation dans un composant */
.custom-button {
  background: var(--ion-color-primary);
  color: var(--ion-color-primary-contrast);
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for global color variables
\subsection*{Variables de couleurs globales}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
:root {
  --ion-color-primary: #3880ff;
  --ion-color-primary-rgb: 56, 128, 255;
  --ion-color-primary-contrast: #ffffff;
  --ion-color-secondary: #3dc2ff;
  --ion-color-success: #2dd36f;
  --ion-color-warning: #ffc409;
  --ion-color-danger: #eb445a;
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for dark theme
\subsection*{Thème sombre automatique}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
@media (prefers-color-scheme: dark) {
  :root {
    --ion-color-primary: #428cff;
    --ion-background-color: #121212;
    --ion-text-color: #ffffff;
  }
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for component-specific variables
\subsection*{Variables par composant}
\subsubsection*{IonButton}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
ion-button {
  --background: #3880ff;
  --color: #ffffff;
  --border-radius: 4px;
  --padding-start: 16px;
  --padding-end: 16px;
}
\end{lstlisting}
\end{tcolorbox}

% Subsection for navigation in Ionic Angular
\subsection{Navigation en Ionic Angular}
Ionic Angular utilise le routeur Angular avec des composants Ionic pour une navigation fluide et native.

\subsubsection*{IonRouterOutlet}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<ion-router-outlet></ion-router-outlet>

<script lang="ts">
import { Component } from '@angular/core';
import { IonicModule } from '@ionic/angular';
import { RouterModule } from '@angular/router';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  standalone: true,
  imports: [IonicModule, RouterModule]
})
export class AppComponent {}
</script>
\end{lstlisting}
\end{tcolorbox}

\subsubsection*{IonTabs}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<ion-tabs>
  <ion-router-outlet></ion-router-outlet>
  <ion-tab-bar slot="bottom">
    <ion-tab-button tab="home" href="/home">
      <ion-icon name="home"></ion-icon>
      <ion-label>Accueil</ion-label>
    </ion-tab-button>
  </ion-tab-bar>
</ion-tabs>

<script lang="ts">
import { Component } from '@angular/core';
import { IonicModule } from '@ionic/angular';
import { RouterModule } from '@angular/router';

@Component({
  selector: 'app-tabs',
  templateUrl: './tabs.component.html',
  standalone: true,
  imports: [IonicModule, RouterModule]
})
export class TabsComponent {}
</script>
\end{lstlisting}
\end{tcolorbox}

% Subsection for programmatic navigation
\subsubsection*{Navigation programmatique}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<ion-button (click)="navigateToPage()">Naviguer</ion-button>

<script lang="ts">
import { Component } from '@angular/core';
import { IonicModule } from '@ionic/angular';
import { Router } from '@angular/router';

@Component({
  selector: 'app-nav',
  templateUrl: './nav.component.html',
  standalone: true,
  imports: [IonicModule]
})
export class NavComponent {
  constructor(private router: Router) {}

  navigateToPage() {
    this.router.navigate(['/about']);
  }
}
</script>
\end{lstlisting}
\end{tcolorbox}

% Subsection for Capacitor integration
\subsection{Intégration des fonctionnalités natives : Capacitor}
Capacitor permet d'accéder aux fonctionnalités natives dans Ionic Angular.

\begin{itemize}
  \item \textbf{WebView} : Rendu optimisé pour mobile.
  \item \textbf{Plugins} : Accès aux APIs natives via plugins.
  \item \textbf{Bridge} : Communication JavaScript $\leftrightarrow$ Native.
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
<ion-button (click)="takePhoto()">Prendre une photo</ion-button>
<img *ngIf="photo" [src]="photo" alt="Photo">

<script lang="ts">
import { Component } from '@angular/core';
import { IonicModule } from '@ionic/angular';
import { Camera, CameraResultType } from '@capacitor/camera';

@Component({
  selector: 'app-camera',
  templateUrl: './camera.component.html',
  standalone: true,
  imports: [IonicModule]
})
export class CameraComponent {
  photo: string | null = null;

  async takePhoto() {
    const image = await Camera.getPhoto({
      resultType: CameraResultType.Uri,
      quality: 90
    });
    this.photo = image.webPath ?? null;
  }
}
</script>
\end{lstlisting}
\end{tcolorbox}




\chapter{Flutter}
\addtocontents{toc}{\vspace{1em}}

\section{Qu'est-ce que Flutter}
Flutter est un framework open-source de Google pour développer des applications multiplateformes (iOS, Android, web, desktop) avec une seule base de code, utilisant le langage Dart.

% Links to official documentation
\href{https://flutter.dev/}{Documentation Flutter} \newline
\href{https://dart.dev/}{Documentation Dart}

\section{Installation de Flutter}
\begin{enumerate}
  \item \textbf{Téléchargez le SDK Flutter} : Depuis \href{https://flutter.dev/docs/get-started/install}{flutter.dev}.
  \item \textbf{creez un dossier pour le SDK de flutter } :Une fois le SDK telecharger vous devez creer un dossier la ou vous voulez placer le SDK .Le dossie ne doit pas comporter des \textbf{espace} ou \textbf{caractères spéciaux} ou 
  ou lui meme etre dans un dossier qui en contient .
  \item \textbf{Extrayez l archive} : Décompresser l archive dans le dossier que vous venez de creez et qui ne contient pas \textbf{espace} ou \textbf{caractères spéciaux}
  \item \textbf{Ajouter le SDK aux variables d'environnement} :Taper variable dans la barre de recherche inferieur de windows 
\end{enumerate}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{v1.png}
    \caption{Logo de React Native}
    \label{fig:variables d env}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.45\textwidth]{var4.PNG}
    \hfill
    \includegraphics[width=0.45\textwidth]{var5.PNG}
    \caption{Variables d'environnement - Images côte à côte}
    \label{fig:variables_env}
\end{figure}


\begin{figure}[H]
    \centering
    \includegraphics[width=0.50\textwidth]{var5.PNG}
    \caption{Logo de React Native}
    \label{fig:variables d env 4}
\end{figure}


\begin{enumerate}
  \item[5.] \textbf{Configurez l'environnement} : Installez un éditeur VS Code si ce n est fait, configurez le chemin du SDK et exécutez \textcolor{gray600}{flutter doctor}.
  \item[6.] \textbf{Créez un projet} :Taper la commande \textcolor{gray600}{flutter create mvp} .Noter que le nom du projet doit etre en miniscule .
\end{enumerate}


\section{Structure de base d'un projet Flutter}
\dirtree{%
.1 MVP/.
.2 .dart\_tool/ \DTcomment{Outils et cache Dart}.
.2 android/ \DTcomment{Configuration Android}.
.2 build/ \DTcomment{Fichiers générés par la compilation}.
.2 ios/ \DTcomment{Configuration iOS}.
.2 lib/ \DTcomment{Code source Dart}.
.2 macos/ \DTcomment{Configuration macOS}.
.2 test/ \DTcomment{Tests unitaires}.
.2 web/ \DTcomment{Configuration web}.
.2 windows/ \DTcomment{Configuration Windows}.
.2 .gitignore \DTcomment{Fichier d'exclusion Git}.
.2 analysis\_options.yaml \DTcomment{Options d'analyse statique}.
.2 mvp.iml \DTcomment{Fichier de configuration IntelliJ}.
.2 pubspec.lock \DTcomment{Verrouillage des dépendances}.
.2 pubspec.yaml \DTcomment{Dépendances et configuration}.
.2 README.md \DTcomment{Fichier de documentation}.
}



\section*{Plugins cs code pour fluter}
\begin{flushleft}
  Pour éviter d' \'ecrire manuellement ,le code minimal d une structure d écran en fluter à savoir les class qui hérite du widget Stateless ou Statefull ,la structure du Scalford
  etc ... Installez les plugin suivants:
\end{flushleft}

\textbf{Snippets Flutter}
\begin{itemize}
  \item \texttt{fstful} : Snippet StatefulWidget. Alternative \`a \texttt{stful}.
  \item \texttt{fstless} : Snippet StatelessWidget. Alternative \`a \texttt{stless}.
  \item \texttt{fscaff} : Snippet widget Scaffold.
  \item \texttt{fedgall} : Snippet EdgeInsets avec constructeur nomm\'e all.
  \item \texttt{fedgonly} : Snippet EdgeInsets avec constructeur nomm\'e only.
  \item \texttt{ftxt} : Snippet widget Text.
  \item \texttt{finitlf} : Snippet m\'ethode lifecycle initState Flutter.
  \item \texttt{fic} : Snippet widget Icon Flutter.
  \item \texttt{fcont} : Snippet widget Container Flutter.
  \item \texttt{fcent} : Snippet widget Center Flutter.
  \item \texttt{frow} : Snippet widget Row Flutter.
  \item \texttt{fcol} : Snippet widget Column Flutter.
  \item \texttt{fex} : Snippet widget Expand.
  \item \texttt{fszbw} : Snippet SizedBox avec argument width seulement.
  \item \texttt{fszbh} : Snippet SizedBox avec argument height seulement.
  \item \texttt{fszb} : Snippet SizedBox avec arguments width et height.
  \item \texttt{fedgsym} : Snippet EdgeInsets avec constructeur nomm\'e symmetric.
  \item \texttt{fedgsymv} : Snippet EdgeInsets avec constructeur symmetric et param\`etre vertical.
  \item \texttt{fedgsymh} : Snippet EdgeInsets avec constructeur symmetric et param\`etre horizontal.
  \item \texttt{fimpmat} : Ajouter l'import du package material.
  \item \texttt{fstream} : Afficher un widget StreamBuilder.
  \item \texttt{felbtn} : Snippet ElevatedButton Flutter.
\end{itemize}

\vspace{0.5cm}

\textbf{Snippets Dart} 
\begin{itemize}
  \item \texttt{dvar} : D\'eclaration variable Dart avec var.
  \item \texttt{dfinal} : D\'eclaration variable Dart avec final.
  \item \texttt{dconst} : D\'eclaration variable Dart avec const.
  \item \texttt{dinvar} : Snippet variable d'instance publique Dart.
  \item \texttt{dprinvar} : Snippet variable d'instance priv\'ee Dart.
  \item \texttt{dmt} : Snippet m\'ethode publique Dart.
  \item \texttt{dprmt} : Snippet m\'ethode priv\'ee Dart.
  \item \texttt{darr} : Snippet fonction fl\'ech\'ee publique Dart.
  \item \texttt{dprarr} : Snippet fonction fl\'ech\'ee priv\'ee Dart.
  \item \texttt{dopnctor} : Snippet constructeur avec param\`etres nomm\'es optionnels Dart.
  \item \texttt{dlist} : Snippet collection List Dart.
  \item \texttt{dmap} : Snippet collection Map Dart.
  \item \texttt{dset} : Snippet collection Set Dart.
  \item \texttt{dgetarr} : Snippet getter avec fonction fl\'ech\'ee Dart.
  \item \texttt{dimpas} : Snippet import as Dart.
  \item \texttt{dimpshow} : Snippet import show Dart.
  \item \texttt{dimplazy} : Snippet import deferred as Dart.
  \item \texttt{dimphide} : Snippet import hide Dart.
  \item \texttt{dexhide} : Snippet export hide Dart.
  \item \texttt{dexshow} : Snippet export show Dart.
  \item \texttt{dconvert} : Snippet import de la lib convert Dart.
  \item \texttt{dimpmeta} : Ajouter l'import du package meta.
  \item \texttt{dan} : Ajouter une fonction anonyme Dart.
  \item \texttt{dcla} : Ajouter un snippet Class Dart.
  \item \texttt{dclae} : Ajouter un snippet Class Dart avec extends.
\end{itemize}

\section{composants d Intergace Utilisateur (UI): Widgets Flutter}
Les widgets sont les blocs de construction de l'interface utilisateur dans Flutter. Tout est un widget (boutons, textes, layouts). Pour les développeurs venant de l'écosystème React, notamment React Native pour le mobile, la comparaison est directe. En React, nous avons des composants, et chaque composant possède des \textcolor{gray600}{props} et des \textcolor{gray600}{méthodes}. De manière similaire, en Flutter, les widgets ont des propriétés (équivalentes aux props) et des méthodes associées.

Chaque prop en React a un type spécifique, tout comme les propriétés des widgets en Flutter. Voici les types de données couramment utilisés pour les props en JavaScript, qui trouvent leur équivalent dans les propriétés des widgets Flutter :

\begin{itemize}[after=\vspace{5mm}]
  \item \textcolor{gray600}{string} : Chaîne de caractères, utilisée pour les textes, labels ou identifiants.
  \item \textcolor{gray600}{number} : Nombre (entier ou flottant), utilisé pour les tailles, marges, ou autres valeurs numériques.
  \item \textcolor{gray600}{boolean} : Valeur booléenne (\texttt{true} ou \texttt{false}), utilisée pour activer/désactiver des fonctionnalités.
  \item \textcolor{gray600}{object} : Objet JavaScript, utilisé pour passer des données complexes ou structurées.
  \item \textcolor{gray600}{array} : Tableau, utilisé pour des listes de données ou d'éléments.
  \item \textcolor{gray600}{function} : Fonction, utilisée pour les gestionnaires d'événements (par exemple, \texttt{onClick}).
  \item \textcolor{gray600}{null} : Valeur nulle, utilisée pour indiquer l'absence de valeur.
  \item \textcolor{gray600}{undefined} : Valeur non définie, souvent utilisée par défaut avant l'initialisation.
\end{itemize}

Le composant TextInput avec les plus props et methodes utilisées en React Native 

\begin{itemize}[label={}]
  \item \textcolor{gray600}{TextInput} 
\end{itemize}

\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{value → string}
    \item \textcolor{gray600}{onChangeText → function}
    \item \textcolor{gray600}{placeholder → string}
    \item \textcolor{gray600}{style → TextStyle}
    \item \textcolor{gray600}{keyboardType → enum('default', 'email-address', 'numeric', 'phone-pad')}
    \item \textcolor{gray600}{secureTextEntry → bool}
    \item \textcolor{gray600}{multiline → bool}
    \item \textcolor{gray600}{maxLength → number}
    \item \textcolor{gray600}{autoFocus → bool}
    \item \textcolor{gray600}{editable → bool}
    \item \textcolor{gray600}{autoCapitalize → enum('none', 'sentences', 'words', 'characters')}
    \item \textcolor{gray600}{placeholderTextColor → ColorValue}
    \item \textcolor{gray600}{defaultValue → string}
    \item \textcolor{gray600}{returnKeyType → enum('done', 'go', 'next', 'search', 'send')}
    \item \textcolor{gray600}{onSubmitEditing → function}
    \item \textcolor{gray600}{onFocus → function}
    \item \textcolor{gray600}{onBlur → function}
    \item \textcolor{gray600}{textAlign → enum('left', 'center', 'right')}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{focus() → void}
    \item \textcolor{gray600}{blur() → void}
    \item \textcolor{gray600}{clear() → void}
\end{itemize}

\vspace{0.5cm}

\textbf{usage de TextInput} \newline
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
import { TextInput } from 'react-native';
  <TextInput
    value={text}
    onChangeText={setText}
    placeholder="Entrez votre nom"
    style={{
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 10,
    borderRadius: 5
  }}
    onChangeText={handleTextChange}
  />
\end{lstlisting}
\end{tcolorbox}


% TextField
\begin{itemize}[label={}]
    \item \textcolor{gray600}{TextField}
\end{itemize}

% Props les plus utilisées
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{controller $\to$ TextEditingController?}
    \item \textcolor{gray600}{onChanged $\to$ ValueChanged<String>?}
    \item \textcolor{gray600}{decoration $\to$ InputDecoration?}
    \item \textcolor{gray600}{keyboardType $\to$ TextInputType?}
    \item \textcolor{gray600}{obscureText $\to$ bool}
    \item \textcolor{gray600}{maxLines $\to$ int?}
    \item \textcolor{gray600}{maxLength $\to$ int?}
\end{itemize}

% Méthodes du TextEditingController
\textbf{Méthodes du TextEditingController}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{text $\to$ String (getter/setter)}
    \item \textcolor{gray600}{clear() $\to$ void}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
TextField(
    controller: _controller,
    decoration: const InputDecoration(
      labelText: 'Entrez votre texte',
      border: OutlineInputBorder(),
      hintText: 'Saisissez quelque chose...',
    ),
    onChanged: (value) {
      setState(() {
        _displayText = value;
      });
    },
  ),
\end{lstlisting}
\end{tcolorbox}



\subsection*{Widgets Cupertino }
Les widgets \textbf{Cupertino} imitent le style iOS, suivant les \href{https://developer.apple.com/design/human-interface-guidelines}{\textit{Human Interface Guidelines}} (HIG) d'Apple, avec des bordures fines (1px), des coins arrondis (8px), et des animations fluides.\newline
Retrouvez la liste non exhaustive des widgets cupertino ici : \href{https://docs.flutter.dev/ui/widgets/cupertino}{Cupertino widgets} \newline
Liste non exhaustive des widgets cupertino sur leur chaine youtube : \href{https://docs.flutter.dev/ui/widgets/cupertino}{Cupertino widgets}


\subsection*{Widgets Material}
Les widgets \textbf{Material} suivent le \href{https://m3.material.io}{\textit{Material Design}} de Google, avec des ombres, des bordures marquées, et un style moderne adapté à Android et au web. Les widgets de base, quant à eux, sont neutres et nécessitent une personnalisation manuelle.

% Tableau comparatif Cupertino vs Material
\begin{table}[h]
    \centering
    \caption{Nuances entre Cupertino et Material}
    \begin{tabular}{|l|l|l|}
        \hline
        \textbf{Critère} & \textbf{Cupertino} & \textbf{Material} \\
        \hline
        Design & Style iOS (HIG), minimaliste, verre dépoli & Material Design, ombres, couleurs vives \\
        \hline
        Bordures & Fines (1px), rayon 8px & Marquées (1-2px), rayon 4px ou carré \\
        \hline
        Animations & Fluides, glissement horizontal & Dynamiques, élévation marquée \\
        \hline
        Plateforme cible & iOS (mais utilisable sur Android) & Android, web (mais utilisable sur iOS) \\
        \hline
        Personnalisation & Limitée (conforme HIG) & Élevée via \texttt{ThemeData} \\
        \hline
    \end{tabular}
\end{table}


\section*{Widgets de base en Flutter}
Comme vous vous en doutez , en flutter egalement il existe des widgets de base comme les composants de 
base en react native ces widgets permettent de construire vos interface UI complexe et avancés .Ce sont en outre 


% Widget Text
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Text-class.html}{Text}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{data → String}
    \item \textcolor{gray600}{style → TextStyle}
    \item \textcolor{gray600}{strutStyle → StrutStyle}
    \item \textcolor{gray600}{textAlign → TextAlign('left', 'right', 'center', 'justify', 'start', 'end')}
    \item \textcolor{gray600}{textDirection → TextDirection('ltr', 'rtl')}
    \item \textcolor{gray600}{locale → Locale}
    \item \textcolor{gray600}{softWrap → bool}
    \item \textcolor{gray600}{overflow → TextOverflow('clip', 'fade', 'ellipsis', 'visible')}
    \item \textcolor{gray600}{textScaleFactor → double}
    \item \textcolor{gray600}{maxLines → int}
    \item \textcolor{gray600}{semanticsLabel → String}
    \item \textcolor{gray600}{textWidthBasis → TextWidthBasis('parent', 'longestLine')}
    \item \textcolor{gray600}{textHeightBehavior → TextHeightBehavior}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Text.rich() → Constructor pour RichText}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Text(
  'Bonjour Flutter !',
  style: TextStyle(
    fontSize: 20,
    fontWeight: FontWeight.bold,
    color: Colors.blue,
  ),
  textAlign: TextAlign.center,
  maxLines: 2,
  overflow: TextOverflow.ellipsis,
)
\end{lstlisting}
\end{tcolorbox}

% Widget Container
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Container-class.html}{Container}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{child → Widget}
    \item \textcolor{gray600}{alignment → Alignment}
    \item \textcolor{gray600}{padding → EdgeInsets}
    \item \textcolor{gray600}{color → Color}
    \item \textcolor{gray600}{decoration → Decoration}
    \item \textcolor{gray600}{foregroundDecoration → Decoration}
    \item \textcolor{gray600}{width → double}
    \item \textcolor{gray600}{height → double}
    \item \textcolor{gray600}{constraints → BoxConstraints}
    \item \textcolor{gray600}{margin → EdgeInsets}
    \item \textcolor{gray600}{transform → Matrix4}
    \item \textcolor{gray600}{transformAlignment → Alignment}
    \item \textcolor{gray600}{clipBehavior → Clip('none', 'hardEdge', 'antiAlias', 'antiAliasWithSaveLayer')}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Aucune méthode publique notable}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Container(
  width: 200,
  height: 100,
  padding: EdgeInsets.all(16),
  margin: EdgeInsets.symmetric(vertical: 8),
  decoration: BoxDecoration(
    color: Colors.blue.shade100,
    borderRadius: BorderRadius.circular(12),
    boxShadow: [
      BoxShadow(
        color: Colors.grey.withOpacity(0.3),
        spreadRadius: 2,
        blurRadius: 5,
      ),
    ],
  ),
  alignment: Alignment.center,
  child: Text('Container stylis\'e'),
)
\end{lstlisting}
\end{tcolorbox}

% Widget Column
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Column-class.html}{Column}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{children → List<Widget>}
    \item \textcolor{gray600}{mainAxisAlignment → MainAxisAlignment('start', 'end', 'center', 'spaceBetween', 'spaceAround', 'spaceEvenly')}
    \item \textcolor{gray600}{mainAxisSize → MainAxisSize('min', 'max')}
    \item \textcolor{gray600}{crossAxisAlignment → CrossAxisAlignment('start', 'end', 'center', 'stretch', 'baseline')}
    \item \textcolor{gray600}{textDirection → TextDirection('ltr', 'rtl')}
    \item \textcolor{gray600}{verticalDirection → VerticalDirection('up', 'down')}
    \item \textcolor{gray600}{textBaseline → TextBaseline('alphabetic', 'ideographic')}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Aucune méthode publique notable}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Column(
  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
  crossAxisAlignment: CrossAxisAlignment.start,
  children: [
    Text('Premier \'el\'ement'),
    Container(
      width: 100,
      height: 50,
      color: Colors.blue,
    ),
    ElevatedButton(
      onPressed: () {},
      child: Text('Bouton'),
    ),
  ],
)
\end{lstlisting}
\end{tcolorbox}

% Widget Row
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Row-class.html}{Row}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{children → List<Widget>}
    \item \textcolor{gray600}{mainAxisAlignment → MainAxisAlignment('start', 'end', 'center', 'spaceBetween', 'spaceAround', 'spaceEvenly')}
    \item \textcolor{gray600}{mainAxisSize → MainAxisSize('min', 'max')}
    \item \textcolor{gray600}{crossAxisAlignment → CrossAxisAlignment('start', 'end', 'center', 'stretch', 'baseline')}
    \item \textcolor{gray600}{textDirection → TextDirection('ltr', 'rtl')}
    \item \textcolor{gray600}{verticalDirection → VerticalDirection('up', 'down')}
    \item \textcolor{gray600}{textBaseline → TextBaseline('alphabetic', 'ideographic')}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Aucune méthode publique notable}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Row(
  mainAxisAlignment: MainAxisAlignment.spaceBetween,
  crossAxisAlignment: CrossAxisAlignment.center,
  children: [
    Icon(Icons.home, size: 30),
    Expanded(
      child: Text(
        'Texte qui s\'adapte',
        textAlign: TextAlign.center,
      ),
    ),
    Icon(Icons.settings, size: 30),
  ],
)
\end{lstlisting}
\end{tcolorbox}

% Widget ElevatedButton
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/material/ElevatedButton-class.html}{ElevatedButton}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{onPressed → Function}
    \item \textcolor{gray600}{onLongPress → Function}
    \item \textcolor{gray600}{onHover → Function(bool)}
    \item \textcolor{gray600}{onFocusChange → Function(bool)}
    \item \textcolor{gray600}{style → ButtonStyle}
    \item \textcolor{gray600}{focusNode → FocusNode}
    \item \textcolor{gray600}{autofocus → bool}
    \item \textcolor{gray600}{clipBehavior → Clip}
    \item \textcolor{gray600}{child → Widget}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{ElevatedButton.icon() → Constructor avec icône}
\item \textcolor{gray600}{ElevatedButton.styleFrom() → Méthode pour créer ButtonStyle}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
ElevatedButton(
  onPressed: () {
    print('Bouton press\'e !');
  },
  style: ElevatedButton.styleFrom(
    backgroundColor: Colors.blue,
    foregroundColor: Colors.white,
    padding: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
    shape: RoundedRectangleBorder(
      borderRadius: BorderRadius.circular(8),
    ),
  ),
  child: Text('Cliquez-moi'),
)

ElevatedButton.icon(
  onPressed: () {},
  icon: Icon(Icons.download),
  label: Text('T\'el\'echarger'),
)
\end{lstlisting}
\end{tcolorbox}

% Widget Image
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Image-class.html}{Image}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{image → ImageProvider}
    \item \textcolor{gray600}{frameBuilder → ImageFrameBuilder}
    \item \textcolor{gray600}{loadingBuilder → ImageLoadingBuilder}
    \item \textcolor{gray600}{errorBuilder → ImageErrorWidgetBuilder}
    \item \textcolor{gray600}{semanticLabel → String}
    \item \textcolor{gray600}{excludeFromSemantics → bool}
    \item \textcolor{gray600}{width → double}
    \item \textcolor{gray600}{height → double}
    \item \textcolor{gray600}{color → Color}
    \item \textcolor{gray600}{opacity → Animation<double>}
    \item \textcolor{gray600}{colorBlendMode → BlendMode}
    \item \textcolor{gray600}{fit → BoxFit('fill', 'contain', 'cover', 'fitWidth', 'fitHeight', 'none', 'scaleDown')}
    \item \textcolor{gray600}{alignment → AlignmentGeometry}
    \item \textcolor{gray600}{repeat → ImageRepeat('noRepeat', 'repeat', 'repeatX', 'repeatY')}
    \item \textcolor{gray600}{centerSlice → Rect}
    \item \textcolor{gray600}{matchTextDirection → bool}
    \item \textcolor{gray600}{gaplessPlayback → bool}
    \item \textcolor{gray600}{isAntiAlias → bool}
    \item \textcolor{gray600}{filterQuality → FilterQuality}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Image.asset() → Constructor pour assets locaux}
\item \textcolor{gray600}{Image.network() → Constructor pour URLs}
\item \textcolor{gray600}{Image.file() → Constructor pour fichiers}
\item \textcolor{gray600}{Image.memory() → Constructor pour données en mémoire}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Image.network(
  'https://picsum.photos/200/300',
  width: 200,
  height: 150,
  fit: BoxFit.cover,
  loadingBuilder: (context, child, loadingProgress) {
    if (loadingProgress == null) return child;
    return CircularProgressIndicator();
  },
)

Image.asset(
  'assets/images/logo.png',
  width: 100,
  height: 100,
  fit: BoxFit.contain,
)
\end{lstlisting}
\end{tcolorbox}

% Widget Icon
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/Icon-class.html}{Icon}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{icon → IconData}
    \item \textcolor{gray600}{size → double}
    \item \textcolor{gray600}{color → Color}
    \item \textcolor{gray600}{semanticLabel → String}
    \item \textcolor{gray600}{textDirection → TextDirection}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Aucune méthode publique notable}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
Icon(
  Icons.favorite,
  color: Colors.red,
  size: 30,
  semanticLabel: 'Favori',
)

// Dans un bouton
IconButton(
  onPressed: () {},
  icon: Icon(
    Icons.thumb_up,
    color: Colors.blue,
  ),
)
\end{lstlisting}
\end{tcolorbox}

% Widget TextField
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/material/TextField-class.html}{TextField}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{controller → TextEditingController}
    \item \textcolor{gray600}{focusNode → FocusNode}
    \item \textcolor{gray600}{decoration → InputDecoration}
    \item \textcolor{gray600}{keyboardType → TextInputType}
    \item \textcolor{gray600}{textInputAction → TextInputAction}
    \item \textcolor{gray600}{textCapitalization → TextCapitalization}
    \item \textcolor{gray600}{style → TextStyle}
    \item \textcolor{gray600}{strutStyle → StrutStyle}
    \item \textcolor{gray600}{textAlign → TextAlign}
    \item \textcolor{gray600}{textAlignVertical → TextAlignVertical}
    \item \textcolor{gray600}{textDirection → TextDirection}
    \item \textcolor{gray600}{autofocus → bool}
    \item \textcolor{gray600}{obscureText → bool}
    \item \textcolor{gray600}{autocorrect → bool}
    \item \textcolor{gray600}{enableSuggestions → bool}
    \item \textcolor{gray600}{maxLines → int}
    \item \textcolor{gray600}{minLines → int}
    \item \textcolor{gray600}{expands → bool}
    \item \textcolor{gray600}{readOnly → bool}
    \item \textcolor{gray600}{enabled → bool}
    \item \textcolor{gray600}{cursorWidth → double}
    \item \textcolor{gray600}{cursorHeight → double}
    \item \textcolor{gray600}{cursorRadius → Radius}
    \item \textcolor{gray600}{cursorColor → Color}
    \item \textcolor{gray600}{selectionHeightStyle → BoxHeightStyle}
    \item \textcolor{gray600}{selectionWidthStyle → BoxWidthStyle}
    \item \textcolor{gray600}{keyboardAppearance → Brightness}
    \item \textcolor{gray600}{scrollPadding → EdgeInsets}
    \item \textcolor{gray600}{dragStartBehavior → DragStartBehavior}
    \item \textcolor{gray600}{enableInteractiveSelection → bool}
    \item \textcolor{gray600}{selectionControls → TextSelectionControls}
    \item \textcolor{gray600}{onChanged → Function(String)}
    \item \textcolor{gray600}{onEditingComplete → Function}
    \item \textcolor{gray600}{onSubmitted → Function(String)}
    \item \textcolor{gray600}{onAppPrivateCommand → Function}
    \item \textcolor{gray600}{inputFormatters → List<TextInputFormatter>}
    \item \textcolor{gray600}{mouseCursor → MouseCursor}
    \item \textcolor{gray600}{buildCounter → InputCounterWidgetBuilder}
    \item \textcolor{gray600}{scrollController → ScrollController}
    \item \textcolor{gray600}{scrollPhysics → ScrollPhysics}
    \item \textcolor{gray600}{autofillHints → Iterable<String>}
    \item \textcolor{gray600}{clipBehavior → Clip}
    \item \textcolor{gray600}{restorationId → String}
    \item \textcolor{gray600}{scribbleEnabled → bool}
    \item \textcolor{gray600}{enableIMEPersonalizedLearning → bool}
\end{itemize}

\textbf{Méthodes}
\begin{itemize}[label={}]
\item \textcolor{gray600}{Aucune méthode publique notable}
\end{itemize}

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
TextField(
  controller: TextEditingController(),
  decoration: InputDecoration(
    labelText: 'Nom d\'utilisateur',
    hintText: 'Entrez votre nom',
    prefixIcon: Icon(Icons.person),
    suffixIcon: Icon(Icons.clear),
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(8),
    ),
    filled: true,
    fillColor: Colors.grey.shade100,
  ),
  keyboardType: TextInputType.text,
  textInputAction: TextInputAction.next,
  maxLines: 1,
  onChanged: (value) {
    print('Texte saisi: $value');
  },
  onSubmitted: (value) {
    print('Formulaire soumis avec: $value');
  },
)
\end{lstlisting}
\end{tcolorbox}

% Widget ListView
\begin{itemize}[label={}]
    \item \textcolor{gray600}{\href{https://api.flutter.dev/flutter/widgets/ListView-class.html}{ListView}}
\end{itemize}
\textbf{Props}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{children $\to$ List<Widget>}
    \item \textcolor{gray600}{scrollDirection $\to$ Axis('horizontal', 'vertical')}
    \item \textcolor{gray600}{reverse $\to$ bool}
    \item \textcolor{gray600}{controller $\to$ ScrollController}
    \item \textcolor{gray600}{primary $\to$ bool}
    \item \textcolor{gray600}{physics $\to$ ScrollPhysics}
    \item \textcolor{gray600}{shrinkWrap $\to$ bool}
    \item \textcolor{gray600}{padding $\to$ EdgeInsets}
    \item \textcolor{gray600}{itemExtent $\to$ double}
    \item \textcolor{gray600}{prototypeItem $\to$ Widget}
    \item \textcolor{gray600}{addAutomaticKeepAlives $\to$ bool}
    \item \textcolor{gray600}{addRepaintBoundaries $\to$ bool}
    \item \textcolor{gray600}{addSemanticIndexes $\to$ bool}
    \item \textcolor{gray600}{cacheExtent $\to$ double}
    \item \textcolor{gray600}{semanticChildCount $\to$ int}
    \item \textcolor{gray600}{dragStartBehavior $\to$ DragStartBehavior}
    \item \textcolor{gray600}{keyboardDismissBehavior $\to$ ScrollViewKeyboardDismissBehavior}
    \item \textcolor{gray600}{restorationId $\to$ String}
    \item \textcolor{gray600}{clipBehavior $\to$ Clip}
\end{itemize}
\textbf{M\'ethodes}
\begin{itemize}[label={}]
    \item \textcolor{gray600}{ListView.builder() $\to$ Quand tu veux construire une liste mais que t'as trop d'items... \#DynamicVibes}
    \item \textcolor{gray600}{ListView.separated() $\to$ Parce que m\^eme tes items ont besoin d'espace personnel. \#SocialDistancing}
    \item \textcolor{gray600}{ListView.custom() $\to$ Pour ceux qui aiment tout personnaliser. \#DIYMaster}
\end{itemize}


\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
ListView(
  padding: EdgeInsets.all(16),
  children: [
    ListTile(
      leading: CircleAvatar(child: Text('A')),
      title: Text('Alice'),
      subtitle: Text('alice@email.com'),
      trailing: Icon(Icons.more_vert),
    ),
    Divider(),
    ListTile(
      leading: CircleAvatar(child: Text('B')),
      title: Text('Bob'),
      subtitle: Text('bob@email.com'),
      trailing: Icon(Icons.more_vert),
    ),
  ],
)

ListView.builder(
  itemCount: 100,
  itemBuilder: (context, index) {
    return ListTile(
      title: Text('Item $index'),
      onTap: () => print('Item $index tap\'e'),
    );
  },
)
\end{lstlisting}
\end{tcolorbox}


\section*{Utilisation d un widgets :Comment ca marche ?}
Les widgets en flutter sont assez intimidant dans une classe d interface utilisateur .La prise en 
main d un widget necessite un regard particulier .Pour une un cpmprehnesion facile d un wiget 
deux elements essentielles sont a prendre en compte . \newline
\begin{itemize}[label=$\blacksquare$]
  \item \textcolor{gray600}{Propriété required} : \textcolor{gray600}{En effet, sur la liste des propriétés, certaines sont \textbf{required}, ce qui veut dire qu'elles sont obligatoires et si elle(s) vient/viennent à manquer dans l'usage du widget, vous aurez une erreur.} \newline
  
  \item \textcolor{gray600}{Type de la propriété} : \textcolor{gray600}{Le type d'une propriété est la partie la plus intéressante. Car c'est là que souvent les choses se compliquent puisque le type peut être un widget et lui, à son tour, a des propriétés et méthodes, ce qui entraîne ces cascades presque infinies et vous donne le tournis.} \newline
  
  \item \textcolor{gray600}{Vous remarquerez par la même occasion que lorsque le type de la propriété n'est pas un type primitif, il s'agira d'une classe qui appelle une propriété, cette dernière ayant ses propres caractéristiques.}
\end{itemize}

\textbf{Discutons ce exemple:}
\begin{jscode}
TextField(
  controller: TextEditingController(),
  decoration: InputDecoration(
    labelText: 'Nom d\'utilisateur',
    hintText: 'Entrez votre nom',
    prefixIcon: Icon(Icons.person),
    suffixIcon: Icon(Icons.clear),
    border: OutlineInputBorder(
      borderRadius: BorderRadius.circular(8),
    ),
    filled: true,
    fillColor: Colors.grey.shade100,
  ),
  keyboardType: TextInputType.text,
  textInputAction: TextInputAction.next,
  maxLines: 1,
  onChanged: (value) {
    print('Texte saisi: $value');
  },
  onSubmitted: (value) {
    print('Formulaire soumis avec: $value');
  },
)
\end{jscode}
 

\begin{flushleft}
  Intéressons-nous à la propriété decoration (lignes 3 à 13), qui est une instance de la classe InputDecoration.
  On peut facilement constater cette imbrication de trois niveaux car nous avons :
\end{flushleft}


\begin{enumerate}
    \item Le widget \texttt{TextField}, qui est le champ de saisie principal.\newline
    \item La propriété \texttt{decoration} de ce widget, qui est une instance de la classe \texttt{InputDecoration} et permet de définir l'apparence du champ de saisie.
    Ici vous avez la , le constructeur (constructor) de de cette et rappelez-vous le constructeur en dart comme en java et kottlin porte le meme nom .
    Et comme vous le savez un constructeur a des arguments , mais encore plus loin car ces argument sont aussi des differents types  (primitives :int , ...) , mais surtout sont aussi des
    \textcolor{gray600}{instances} d' autre classes cas de \textbf{OutlineInputBorder} comme vous pouvez le constatez.\newline
    \item Les propriétés internes de \texttt{InputDecoration}, comme \texttt{border}, qui utilise \texttt{OutlineInputBorder} pour définir la bordure du champ de saisie.
\end{enumerate}

\section*{Resumé}
En sommes l usage d un widget, est un parcours de proche si les propriétés sont
sont des instances de classes ou des sont de types widgets.Ca veut dire que dans l un des cas , vous srrez amenez a 
à cliquer sur le nom du constructeur de la classe ou du widgets donc il est une instance ou type pour voir quels sont les propriétés qu elle expose avec ses methodes.


% Defining the document structure for widgets
\section{Widget sans \'{e}tat, avec \'{e}tat}

% Subsection for Stateless Widget
\subsection{Classe Stateless}
Un \texttt{StatelessWidget} est un widget immuable qui ne g\`{e}re pas d'\'{e}tat interne. Il est utilis\'{e} pour afficher un contenu statique qui ne change pas apr\`{e}s sa cr\'{e}ation, comme du texte fixe, des ic\^{o}nes ou des layouts statiques. La m\'{e}thode \texttt{build} est appel\'{e}e une seule fois ou lorsque le widget parent est reconstruit.

% Stateless Widget example in tcolorbox
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
class MonWidgetStateless extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('Contenu statique');
  }
}
\end{lstlisting}
\end{tcolorbox}

Les cas d'usage des \texttt{StatelessWidget} incluent :
\begin{itemize}
  \item Affichage de texte fixe, comme des titres ou des \'{e}tiquettes.
  \item Pr\'{e}sentation d'ic\^{o}nes ou d'images statiques.
  \item Cr\'{e}ation de layouts statiques, comme des conteneurs sans interaction.
  \item Widgets de navigation fixes, comme des barres d'application sans \'{e}tat dynamique.
\end{itemize}


% Subsection for Stateful Widget
\subsection{Classe Stateful}
Un \texttt{StatefulWidget} est un widget dynamique qui g\`{e}re un \'{e}tat interne mutable. Il est compos\'{e} de deux parties : une classe immuable h\'{e}ritant de \texttt{StatefulWidget}, qui d\'{e}finit le widget, et une classe d'\'{e}tat h\'{e}ritant de \texttt{State}, qui g\`{e}re les variables mutables et la logique. Voici un r\'{e}sum\'{e} du fonctionnement : dans un premier temps, une classe h\'{e}rite de \texttt{StatefulWidget}. Ensuite, la m\'{e}thode \texttt{createState} est red\'{e}finie pour retourner une instance de la classe d'\'{e}tat, nomm\'{e}e par convention avec un underscore (par exemple, \texttt{\_MonWidgetStatefulState}) pour indiquer qu'elle est priv\'{e}e. Cette instance est cr\'{e}\'{e}e via son constructeur par d\'{e}faut. Enfin, l'\'{e}tat et la logique (comme les variables et les fonctions) sont g\'{e}r\'{e}s dans la classe d'\'{e}tat, et la m\'{e}thode \texttt{build} est appel\'{e}e \`{a} chaque mise \`{a} jour de l'\'{e}tat via \texttt{setState}.

% Stateful Widget example in tcolorbox
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
class MonWidgetStateful extends StatefulWidget {
  @override
  _MonWidgetStatefulState createState() => _MonWidgetStatefulState();
}

class _MonWidgetStatefulState extends State<MonWidgetStateful> {
  int compteur = 0;

  void incrementer() {
    setState(() {
      compteur++;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Compteur : $compteur'),
        ElevatedButton(
          onPressed: incrementer,
          child: Text('Incr\'{e}menter'),
        ),
      ],
    );
  }
}
\end{lstlisting}
\end{tcolorbox}

% Part 1: Definition of StatefulWidget and createState
\textcolor{gray600}{D\'{e}finition de la classe StatefulWidget et de la m\'{e}thode createState qui retourne une instance de la classe d'\'{e}tat.}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100,]
\begin{lstlisting}[language=html]
class MonWidgetStateful extends StatefulWidget {
  @override
  _MonWidgetStatefulState createState() => _MonWidgetStatefulState();
}
\end{lstlisting}
\end{tcolorbox}

% Part 2: State class with state variable and logic
\textcolor{gray600}{D\'{e}finition de la classe d'\'{e}tat avec la variable d'\'{e}tat (compteur) et la fonction pour mettre \`{a} jour l'\'{e}tat.}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
class _MonWidgetStatefulState extends State<MonWidgetStateful> {
  int compteur = 0;

  void incrementer() {
    setState(() {
      compteur++;
    });
  }
\end{lstlisting}
\end{tcolorbox}


% Part 3: Build method for UI
\textcolor{gray600}{M\'{e}thode build qui construit l'interface utilisateur en fonction de l'\'{e}tat actuel.}
\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100, breakable]
\begin{lstlisting}[language=html]
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Text('Compteur : $compteur'),
        ElevatedButton(
          onPressed: incrementer,
          child: Text('Incr\'{e}menter'),
        ),
      ],
    );
  }
}
\end{lstlisting}
\end{tcolorbox}



Les cas d'usage des \texttt{StatefulWidget} incluent :
\begin{itemize}
  \item Gestion de compteurs ou de valeurs num\'{e}riques modifiables par l'utilisateur.
  \item Cr\'{e}ation de formulaires interactifs avec des champs de texte dynamiques.
  \item Animations contr\^{o}l\'{e}es par des \'{e}v\'{e}nements ou des temporisations.
  \item Affichage de donn\'{e}es dynamiques, comme des listes mises \`{a} jour en temps r\'{e}el.
\end{itemize}


\section{Les composant par defaut de chaque ecran:Scalfold}
Dans une application flutter ,chaque ecran debut avec un composant \textbf{Scalfold} .
Par comparaison avec l univers web ,c est l equivalent de la balise \textbf{html}.
En effet en structure d une page Web

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
  <html>
    <body>
      <header>Navigation</header>
      <main>Contenu principal</main>
      <aside>Menu lat\'eral</aside>
      <footer>Pied de page</footer>
      <button class="floating-btn">+</button>
    </body>
  </html>
\end{lstlisting}
\end{tcolorbox}

Avec scalfold:

\begin{tcolorbox}[size=fbox, boxrule=1pt, colback=mytransparentblue, colframe=blue100 ,breakable]
\begin{lstlisting}[language=html]
  Scaffold(
    appBar: AppBar(...),         <header>
    body: Text('Contenu'),       <main>
    drawer: Drawer(...),         <aside>
    bottomNavigationBar: ...,    <footer>
    floatingActionButton: ...,    bouton flottant
  )
\end{lstlisting}
\end{tcolorbox}

\section{Requete HTPP}

En Flutter, les requêtes HTTP sont effectuées avec la bibliothèque \textbf{http}. Plusieurs classes clés interviennent, directement ou indirectement lors de ces derniers .
Voici une liste concise des classes principales impliquées, basée sur l'utilisation de la bibliothèque http (la plus courante pour les requêtes HTTP) et leur rôle dans le processus :

\setlength{\leftmargini}{0.5em}
\begin{enumerate}
  \item \textcolor{gray}{Classes de la bibliothèque du package http}
  \begin{itemize}
    \item \textcolor{gray}{http.Client}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Classe de base pour effectuer des requêtes HTTP. Elle maintient une connexion persistante (si nécessaire) et permet d'envoyer des requêtes GET, POST, PUT, DELETE, etc.
        \item \textcolor{gray}{Exemple} : \texttt{final client = http.Client(); client.get(Uri.parse(url));}
        \item \textcolor{gray}{Utilité} : Utile pour gérer plusieurs requêtes ou personnaliser les configurations (ex. : timeout, intercepteurs).
      \end{itemize}
    \item \textcolor{gray}{http.Request}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Représente une requête HTTP générique. Permet de configurer des requêtes personnalisées (méthode, headers, body).
        \item \textcolor{gray}{Exemple} : \texttt{http.Request('GET', Uri.parse(url))}
        \item \textcolor{gray}{Utilité} : Moins courante que les méthodes directes comme \texttt{http.get}, mais utile pour des requêtes complexes.
      \end{itemize}
    \item \textcolor{gray}{http.Response}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Représente la réponse HTTP renvoyée par le serveur. Contient le \texttt{statusCode}, le \texttt{body} (données), les headers, etc.
        \item \textcolor{gray}{Exemple} : \texttt{final response = await http.get(Uri.parse(url)); print(response.body);}
        \item \textcolor{gray}{Utilité} : Utilisée pour extraire les données ou vérifier le succès de la requête.
      \end{itemize}
    \item \textcolor{gray}{http.StreamedResponse}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Gère les réponses HTTP en streaming (ex. : pour des fichiers volumineux).
        \item \textcolor{gray}{Exemple} : \texttt{final streamedResponse = await client.send(http.Request('GET', Uri.parse(url)));}
        \item \textcolor{gray}{Utilité} : Rare pour les API JSON classiques, mais utile pour des téléchargements ou des flux.
      \end{itemize}
  \end{itemize}
  \item \textcolor{gray}{Classes Dart associées}
  \begin{itemize}
    \item \textcolor{gray}{Uri}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Représente une URL et permet de la construire ou parser.
        \item \textcolor{gray}{Exemple} : \texttt{Uri.parse('https://api.example.com/data')}
        \item \textcolor{gray}{Utilité} : Essentielle pour spécifier l'endpoint de la requête.
      \end{itemize}
    \item \textcolor{gray}{Map<String, dynamic>}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Structure utilisée pour parser les réponses JSON (via \texttt{jsonDecode}) ou construire les payloads JSON (via \texttt{jsonEncode}).
        \item \textcolor{gray}{Exemple} : \texttt{final data = jsonDecode(response.body) as Map<String, dynamic>;}
        \item \textcolor{gray}{Utilité} : Représentation des données JSON avant ou après sérialisation.
      \end{itemize}
    \item \textcolor{gray}{List}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Structure utilisée pour parser des tableaux JSON ou construire des listes de données à envoyer.
        \item \textcolor{gray}{Exemple} : \texttt{final List<dynamic> data = jsonDecode(response.body);}
        \item \textcolor{gray}{Utilité} : Représente des collections de données JSON, souvent imbriquées dans un \texttt{Map<String, dynamic>}.
      \end{itemize}
    \item \textcolor{gray}{Future}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Représente une opération asynchrone (les requêtes HTTP sont asynchrones).
        \item \textcolor{gray}{Exemple} : \texttt{Future<http.Response> future = http.get(Uri.parse(url));}
        \item \textcolor{gray}{Utilité} : Gère le résultat des requêtes avec \texttt{async/await}.
      \end{itemize}
  \end{itemize}
  \item \textcolor{gray}{Classes pour la sérialisation}
  \begin{itemize}
    \item \textcolor{gray}{Classes de modèle personnalisées (ex. : Post)}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Représentent les données structurées de l'API (ex. : un post avec \texttt{id}, \texttt{title}, \texttt{body}).
        \item \textcolor{gray}{Exemple} : \texttt{class Post \{ final int id; final String title; ... factory Post.fromJson(Map<String, dynamic> json); \}}
        \item \textcolor{gray}{Utilité} : Facilite le parsing des réponses JSON et leur utilisation dans l'UI.
      \end{itemize}
    \item \textcolor{gray}{json\_serializable}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Génère automatiquement les méthodes \texttt{fromJson} et \texttt{toJson} pour les classes de modèle.
        \item \textcolor{gray}{Exemple} : \texttt{@JsonSerializable() class Post \{ ... \}}
        \item \textcolor{gray}{Utilité} : Simplifie la gestion des API complexes.
      \end{itemize}
  \end{itemize}
  \item \textcolor{gray}{Classes Flutter pour l'intégration dans l'UI}
  \begin{itemize}
    \item \textcolor{gray}{FutureBuilder}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Widget qui gère l'état d'une \texttt{Future} (ex. : chargement, succès, erreur) pour afficher les données.
        \item \textcolor{gray}{Exemple} : \texttt{FutureBuilder<Post>(future: fetchPost(), builder: (context, snapshot) \{ ... \});}
        \item \textcolor{gray}{Utilité} : Rend l'affichage des données asynchrones simple et réactif.
      \end{itemize}
    \item \textcolor{gray}{ScaffoldMessenger}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Affiche des notifications (ex. : \texttt{SnackBar}) pour indiquer le succès ou l'échec d'une requête.
        \item \textcolor{gray}{Exemple} : \texttt{ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Post supprimé')));}
        \item \textcolor{gray}{Utilité} : Fournit un retour utilisateur après des opérations comme DELETE ou PUT.
      \end{itemize}
  \end{itemize}
  \item \textcolor{gray}{Classe utilitaire (optionnelle)}
  \begin{itemize}
    \item \textcolor{gray}{Dio}
      \begin{itemize}
        \item \textcolor{gray}{Rôle} : Classe principale du package \texttt{dio} pour des requêtes HTTP avancées (intercepteurs, gestion des erreurs, etc.).
        \item \textcolor{gray}{Exemple} : \texttt{final dio = Dio(); dio.get('https://api.example.com/data');}
        \item \textcolor{gray}{Utilité} : Alternative à \texttt{http} avec plus de fonctionnalités.
      \end{itemize}
  \end{itemize}
\end{enumerate}

\subsection{Crud en htpp}
Plus souvent , on a un backend separé , via alors nos fameux operations fétiches CRUD (Cread Read Update Delete) le classique quoi .
Voici comment proceder tout en vérifiant la version actuelle:

\begin{enumerate}
  \item \textcolor{gray}{Ajouter la dépendance}
\end{enumerate}

\begin{jscode}
dependencies:
  http: ^1.2.2
\end{jscode}

\begin{enumerate}
  \item[2.] \textcolor{gray}{Exécuter ensuite la commande}
\end{enumerate}

\begin{jscode}
  flutter pub get
\end{jscode}


\begin{enumerate}
  \item[3.] \textcolor{gray}{Permission android} :naviguez dans le dossier android/app/src/main/AndroidManifest.xml et ajouter ceci qui suit
\end{enumerate}

\begin{jscode}
  <uses-permission android:name="android.permission.INTERNET" />
\end{jscode}



\subsection{Operation Create}
\begin{jscode}
  Future<void> CreateData() async {
  try {
    final response = await http.post(
      Uri.parse('https://jsonplaceholder.typicode.com/posts'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'title': 'Nouveau post',
        'body': 'Contenu du post',
        'userId': 1,
      }),
    );

    if (response.statusCode == 201) {
      print('Post cr\'ee: ${response.body}');
    } else {
      print('Erreur: ${response.statusCode}');
    }
  } catch (e) {
    print('Exception: $e');
  }
}
\end{jscode}





\subsection{Operation Read}

\begin{jscode}
import 'package:http/http.dart' as http;
import 'dart:convert';

Future<void> ReadData() async {
  try {
    final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1'));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      print(data);
      print('Erreur: ${response.statusCode}');
    }
  } catch (e) {
    print('Exception: $e');
  }
}
\end{jscode}

\subsection{Operation Update}
\begin{jscode}
Future<void> UpdateData(int id) async {
  try {
    final response = await http.put(
      Uri.parse('https://jsonplaceholder.typicode.com/posts/$id'),
      headers: {'Content-Type': 'application/json'},
      body: jsonEncode({
        'id': id,
        'title': 'Post mis a jour',
        'body': 'Contenu mis a jour',
        'userId': 1,
      }),
    );

    if (response.statusCode == 200) {
      print('Post mis a jour: ${response.body}');
    } else {
      print('Erreur: ${response.statusCode}');
    }
  } catch (e) {
    print('Exception: $e');
  }
}
\end{jscode}



\subsection{Operation Delete}
\begin{jscode}
Future<void> DeleteData(int id) async {
  try {
    final response = await http.delete(
      Uri.parse('https://jsonplaceholder.typicode.com/posts/$id'),
      headers: {'Content-Type': 'application/json'},
    );

    if (response.statusCode == 200) {
      print('Post supprim\'e avec succes');
    } else {
      print('Erreur: ${response.statusCode}');
    }
  } catch (e) {
    print('Exception: $e');
  }
}
\end{jscode}





\section*{Rendu des data dans UI}
Apres l étape de recuperation vient souvent celle du rendu des données dans l UI (User Interface) Inferface Utilisateur en francais
c est a dire tout simplement dans les widgets . Pour ce faire des options suivantes sont disponibles .

\subsubsection{Widget \textcolor{gray}{FutureBuilder}}
La m\'ethode \textcolor{gray}{FutureBuilder} est un widget Flutter qui g\`ere l'\'etat d'un \texttt{Future} pour afficher des donn\'ees asynchrones, comme celles provenant d'une API, en g\'erant automatiquement les \'etats de chargement, succ\`es et erreur.

\begin{itemize}
  \item \textcolor{gray}{Avantages} :
    \begin{itemize}
      \item G\`ere automatiquement les \'etats asynchrones (chargement, succ\`es, erreur).
      \item Simple \`a utiliser pour une requ\^ete unique.
      \item Compatible avec tout type de donn\'ees (classe de mod\`ele, \texttt{Map<String, dynamic>}, etc.).
    \end{itemize}
  \item \textcolor{gray}{Inconv\'enients} :
    \begin{itemize}
      \item Moins adapt\'e pour des mises \`a jour fr\'equentes ou des donn\'ees partag\'ees entre widgets.
      \item Reconstruction du widget \`a chaque changement d'\'etat.
    \end{itemize}
\end{itemize}

\begin{jscode}
class Post {
  final int id;
  final String title;

  Post({required this.id, required this.title});

  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(id: json['id'] as int, title: json['title'] as String);
  }
}

Future<Post> fetchPost() async {
  final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1'));
  if (response.statusCode == 200) {
    return Post.fromJson(jsonDecode(response.body));
  }
  throw Exception('Erreur');
}

Widget build(BuildContext context) {
  return FutureBuilder<Post>(
    future: fetchPost(),
    builder: (context, snapshot) {
      if (snapshot.connectionState == ConnectionState.waiting) {
        return CircularProgressIndicator();
      } else if (snapshot.hasError) {
        return Text('Erreur: ${snapshot.error}');
      } else if (snapshot.hasData) {
        return Text('Titre: ${snapshot.data!.title}');
      }
      return Text('Aucune donn\'ee');
    },
  );
}
\end{jscode}

Explication : Le widget \textcolor{gray}{FutureBuilder} prend un \texttt{Future<Post>} et utilise un \texttt{builder} pour construire l'UI en fonction de l'\'etat du \texttt{Future}. La classe \textcolor{gray}{Post} structure les donn\'ees JSON. Le \texttt{snapshot} g\`ere les \'etats (\texttt{waiting}, \texttt{hasData}, \texttt{hasError}) pour afficher un indicateur de chargement, les donn\'ees, ou une erreur.

\subsubsection{La m\'ethode \textcolor{gray}{SetState}}
La m\'ethode \textcolor{gray}{SetState} permet de g\'erer manuellement l'\'etat d'un widget \texttt{StatefulWidget} en d\'eclenchant une reconstruction de l'UI lorsque les donn\'ees d'une API sont re\c{c}ues.

\begin{itemize}
  \item \textcolor{gray}{Avantages} :
    \begin{itemize}
      \item Contr\^ole granulaire sur la logique de mise \`a jour.
      \item Pas de d\'ependances suppl\'ementaires.
      \item Utile pour des cas simples ou personnalis\'es.
    \end{itemize}
  \item \textcolor{gray}{Inconv\'enients} :
    \begin{itemize}
      \item Code plus verbeux, n\'ecessitant une gestion manuelle des \'etats.
      \item Moins adapt\'e pour des applications complexes ou des donn\'ees partag\'ees.
    \end{itemize}
\end{itemize}

\begin{jscode}
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  Post? post;
  bool isLoading = true;
  String? error;

  @override
  void initState() {
    super.initState();
    fetchPost();
  }

  Future<void> fetchPost() async {
    try {
      final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1'));
      if (response.statusCode == 200) {
        setState(() {
          post = Post.fromJson(jsonDecode(response.body));
          isLoading = false;
        });
      } else {
        setState(() {
          error = 'Erreur: ${response.statusCode}';
          isLoading = false;
        });
      }
    } catch (e) {
      setState(() {
        error = 'Exception: $e';
        isLoading = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (isLoading) return CircularProgressIndicator();
    if (error != null) return Text(error!);
    if (post != null) return Text('Titre: ${post!.title}');
    return Text('Aucune donn\'ee');
  }
}
\end{jscode}

Explication : La méthode \textcolor{gray}{SetState} est utilis\'ee dans un \texttt{StatefulWidget} pour mettre \`a jour l'\'etat (\texttt{post}, \texttt{isLoading}, \texttt{error}) apr\`es une requ\^ete HTTP. La classe \textcolor{gray}{Post} structure les donn\'ees. \texttt{setState} d\'eclenche la reconstruction du widget avec les nouvelles donn\'ees.

\subsubsection{La méthode \textcolor{gray}{StreamBuilder}}
La m\'ethode \textcolor{gray}{StreamBuilder} est un widget Flutter qui g\`ere un \texttt{Stream} pour afficher des donn\'ees en continu, comme celles provenant d'une API en temps r\'eel (ex. : WebSocket).

\begin{itemize}
  \item \textcolor{gray}{Avantages} :
    \begin{itemize}
      \item Id\'eal pour les donn\'ees en temps r\'eel ou les mises \`a jour fr\'equentes.
      \item G\`ere automatiquement les \'etats du \texttt{Stream} (en attente, donn\'ees, erreur).
      \item Compatible avec des donn\'ees structur\'ees ou non.
    \end{itemize}
  \item \textcolor{gray}{Inconv\'enients} :
    \begin{itemize}
      \item Moins courant pour les API REST classiques (comme JSONPlaceholder).
      \item Configuration plus complexe pour des requ\^etes simples.
    \end{itemize}
\end{itemize}

\begin{jscode}
Stream<Map<String, dynamic>> streamPosts() async* {
  while (true) {
    await Future.delayed(Duration(seconds: 2));
    final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1'));
    if (response.statusCode == 200) {
      yield jsonDecode(response.body);
    } else {
      throw Exception('Erreur');
    }
  }
}

Widget build(BuildContext context) {
  return StreamBuilder<Map<String, dynamic>>(
    stream: streamPosts(),
    builder: (context, snapshot) {
      if (snapshot.connectionState == ConnectionState.waiting) {
        return CircularProgressIndicator();
      } else if (snapshot.hasError) {
        return Text('Erreur: ${snapshot.error}');
      } else if (snapshot.hasData) {
        return Text('Titre: ${snapshot.data!['title']}');
      }
      return Text('Aucune donn\'ee');
    },
  );
}
\end{jscode}

Explication : Le widget \textcolor{gray}{StreamBuilder} prend un \texttt{Stream<Map<String, dynamic>>} et utilise un \texttt{builder} pour afficher les donn\'ees en continu. Le \texttt{snapshot} g\`ere les \'etats (\texttt{waiting}, \texttt{hasData}, \texttt{hasError}). Ici, un \texttt{Stream} simule des mises \`a jour p\'eriodiques d'une API.

\subsubsection{Notes}
\begin{itemize}
  \item \textcolor{gray}{Provider}
  \item \textcolor{gray}{Bloc}
\end{itemize}


\subsubsection{La m\'ethode \textcolor{gray}{Provider}}
La m\'ethode \textcolor{gray}{Provider} est une solution de gestion d'\'etat dans Flutter qui permet de partager et de mettre \`a jour des donn\'ees d'une API entre plusieurs widgets via un \texttt{ChangeNotifier}.

\begin{itemize}
  \item \textcolor{gray}{Avantages} :
    \begin{itemize}
      \item Permet de partager des donn\'ees entre plusieurs widgets de mani\`ere efficace.
      \item Id\'eal pour les applications complexes avec des mises \`a jour dynamiques.
      \item Int\'egration simple avec les requ\^etes HTTP et les classes de mod\`ele.
    \end{itemize}
  \item \textcolor{gray}{Inconv\'enients} :
    \begin{itemize}
      \item N\'ecessite une d\'ependance suppl\'ementaire (\texttt{provider}).
      \item Configuration initiale plus complexe que \texttt{FutureBuilder} ou \texttt{setState}.
    \end{itemize}
\end{itemize}

\begin{jscode}
class Post {
  final int id;
  final String title;

  Post({required this.id, required this.title});

  factory Post.fromJson(Map<String, dynamic> json) {
    return Post(id: json['id'] as int, title: json['title'] as String);
  }
}

class PostProvider with ChangeNotifier {
  Post? post;
  bool isLoading = true;
  String? error;

  Future<void> fetchPost() async {
    try {
      final response = await http.get(Uri.parse('https://jsonplaceholder.typicode.com/posts/1'));
      if (response.statusCode == 200) {
        post = Post.fromJson(jsonDecode(response.body));
        isLoading = false;
      } else {
        error = 'Erreur: ${response.statusCode}';
        isLoading = false;
      }
    } catch (e) {
      error = 'Exception: $e';
      isLoading = false;
    }
    notifyListeners();
  }
}

Widget build(BuildContext context) {
  return ChangeNotifierProvider(
    create: (context) => PostProvider()..fetchPost(),
    child: Consumer<PostProvider>(
      builder: (context, provider, child) {
        if (provider.isLoading) return CircularProgressIndicator();
        if (provider.error != null) return Text(provider.error!);
        if (provider.post != null) return Text('Titre: ${provider.post!.title}');
        return Text('Aucune donn\'ee');
      },
    ),
  );
}
\end{jscode}

Explication : La classe \textcolor{gray}{PostProvider} (h\'eritant de \texttt{ChangeNotifier}) g\`ere l'\'etat des donn\'ees (\texttt{post}, \texttt{isLoading}, \texttt{error}). \texttt{notifyListeners} informe les widgets des changements apr\`es une requ\^ete HTTP. \texttt{ChangeNotifierProvider} fournit l'\'etat, et \texttt{Consumer} reconstruit l'UI avec les donn\'ees de la classe \textcolor{gray}{Post}.


\section{Backend avec Firebase}

L'intégration de Firebase dans une application Flutter, en particulier pour utiliser Firestore pour les opérations CRUD (Create, Read, Update, Delete), est un processus courant et puissant pour développer des applications mobiles avec une base de données en temps réel. Voici une explication détaillée et structurée :

\subsection{Intégration de Firebase dans une application Flutter}

\subsubsection{Option 1 : Integration Automatique en cli}

\begin{itemize}
  \item \textbf{Connection à CLI Firebase}
\end{itemize}

\begin{jscode}
  firebase login
\end{jscode}

\textcolor{gray}{La commande firebase login connecte votre environnement local (votre machine) à votre compte Google associé à Firebase. Cela permet à la CLI Firebase d'accéder à vos projets Firebase dans la console Firebase} \newline


\begin{itemize}
  \item Une fois connecté via firebase login, la CLI Firebase peut :
  \begin{enumerate}
    \item \textcolor{gray}{lister} vos projets associés à votre compte Firebase
    \item \textcolor{gray}{sélectionner} un projet associé à votre compte Firebase
    \item \textcolor{gray}{créer} des projets associé à votre compte Firebase 
  \end{enumerate}
\end{itemize}

\begin{flushleft}
  Cela est nécessaire pour des commandes comme flutterfire configure, qui configure votre application Flutter pour un projet Firebase.Par exemple, lors de l'exécution de flutterfire configure, la CLI a besoin de savoir à quel projet Firebase connecter votre application, et cela repose sur l'authentification préalable via
\end{flushleft}


\begin{itemize}
  \item \textbf{installation de CLI FlutterFire}
\end{itemize}

\begin{jscode}
  dart pub global activate flutterfire_cli
\end{jscode}


\begin{itemize}
  \item \textbf{Ajouter un projet firebase à votre projet fluuter}
\end{itemize}

\begin{jscode}
  flutterfire configure
\end{jscode}


\begin{itemize}
  \item Cette commande
  \begin{enumerate}
    \item Permet de \textcolor{gray}{sélectionner un projet Firebase} existant ou d'en créer un nouveau.
    \item \textcolor{gray}{Détecte automatiquement les informations de ton application} comme le nom du package pour Android ou l'identifiant de bundle pour iOS) à partir des fichiers de configuration de ton projet Flutter (par exemple, android/app/build.gradle ou ios/Runner/Info.plist).
    \item Génère un fichier \textcolor{gray}{firebase\_options.dart} dans \textbf{lib/} qui contient les configurations un peu comme suit:
  \end{enumerate}
\end{itemize}



\begin{jscode}
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart' show defaultTargetPlatform, kIsWeb, TargetPlatform;

class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      default:
        throw UnsupportedError('DefaultFirebaseOptions are not supported for this platform.');
    }
  }

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'votre-api-key',
    appId: 'votre-app-id',
    messagingSenderId: 'votre-sender-id',
    projectId: 'votre-project-id',
    storageBucket: 'votre-storage-bucket',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'votre-api-key',
    appId: 'votre-app-id',
    messagingSenderId: 'votre-sender-id',
    projectId: 'votre-project-id',
    storageBucket: 'votre-storage-bucket',
    iosBundleId: 'com.example.myapp',
  );

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'votre-api-key',
    appId: 'votre-app-id',
    messagingSenderId: 'votre-sender-id',
    projectId: 'votre-project-id',
    storageBucket: 'votre-storage-bucket',
  );
}
\end{jscode}


\begin{enumerate}
  \item[4.] Ajoute automatiquement les plugins Gradle nécessaires pour Android et met à jour les configurations pour iOS ou Web.
\end{enumerate}


\begin{enumerate}
  \item[5.] \textbf{Initialiser Firebase dans votre application}
\end{enumerate}

\begin{jscode}
  flutter pub add firebase_core
\end{jscode}

\textcolor{gray}{Cette commande ajoute le plug-in} core de firebase c est a dire le coeur du SDK de firebase .


\begin{enumerate}
  \item[6.] \textbf{Initialiser Firebase dans votre application}
\end{enumerate}

\begin{jscode}
  flutterfire configure
\end{jscode}

\textcolor{gray}{Cette commande ajoute le plug-in} prise en code de plugin ajouté.


\begin{enumerate}
  \item[6.] Dans votre fichier  \textbf{lib/main.dart }, importez le plug-in principal Firebase et le fichier de configuration que vous avez généré précédemment:
\end{enumerate}

\begin{jscode}
 import 'package:firebase_core/firebase_core.dart';
 import 'firebase_options.dart';
\end{jscode}



\begin{enumerate}
  \item[7.] Dans votre fichier lib/main.dart, initialisez également Firebase à l'aide de l'objet DefaultFirebaseOptions exporté par le fichier de configuration:
\end{enumerate}

\begin{jscode}
WidgetsFlutterBinding.ensureInitialized();
await Firebase.initializeApp(
  options: DefaultFirebaseOptions.currentPlatform,
);
runApp(const MyApp());
\end{jscode}


Lien doc officiel:\href{https://firebase.google.com/docs/flutter/setup?hl=fr&platform=ios}{Configuration firebase flutter ios}

Lien doc officiel:\href{https://firebase.google.com/docs/flutter/setup?hl=fr&platform=android}{Configuration firebase flutter android}

Lien doc officiel:\href{https://firebase.google.com/docs/flutter/setup?hl=fr&platform=web}{Configuration firebase flutter web} \newline

Vous pouvez desormais ajouter des plugins de la liste ci dessous suivant la commande de votre choix.

\begin{jscode}
  flutter pub add nom-du-plugin
\end{jscode}

\vspace{0.5cm}

\begin{itemize}
  \item \textcolor{gray}{cloud\_firestore}: Base de données NoSQL en temps réel pour stocker et synchroniser des données entre les clients et le cloud.
  \item \textcolor{gray}{cloud\_functions}: Permet d'exécuter du code backend personnalisé en réponse à des événements déclenchés par Firebase ou des requêtes HTTPS.
  \item \textcolor{gray}{firebase\_analytics}: Fournit des outils pour suivre et analyser le comportement des utilisateurs dans l'application.
  \item \textcolor{gray}{firebase\_app\_check}: Protège les ressources backend contre les abus en vérifiant l'intégrité des requêtes de l'application.
  \item \textcolor{gray}{firebase\_app\_installations}: Fournit un identifiant unique pour chaque installation d'application, utilisé pour la gestion des installations.
  \item \textcolor{gray}{firebase\_auth}: Gère l'authentification des utilisateurs via email, réseaux sociaux, ou anonymement.
  \item \textcolor{gray}{firebase\_core}: Plugin de base requis pour initialiser Firebase dans une application Flutter.
  \item \textcolor{gray}{firebase\_crashlytics}: Permet de suivre et d'analyser les plantages d'application pour améliorer la stabilité.
  \item \textcolor{gray}{firebase\_data\_connect}: Facilite l'intégration de données avec des API GraphQL pour des requêtes personnalisées.
  \item \textcolor{gray}{firebase\_database}: Base de données en temps réel pour stocker et synchroniser des données JSON.
  \item \textcolor{gray}{firebase\_dynamic\_links}: Crée des liens profonds pour diriger les utilisateurs vers un contenu spécifique dans l'application.
  \item \textcolor{gray}{firebase\_in\_app\_messaging}: Affiche des messages contextuels dans l'application pour engager les utilisateurs.
  \item \textcolor{gray}{firebase\_messaging}: Permet l'envoi et la réception de notifications push dans l'application.
  \item \textcolor{gray}{firebase\_ml\_model\_downloader}: Télécharge des modèles d'apprentissage automatique personnalisés pour une utilisation hors ligne.
  \item \textcolor{gray}{firebase\_performance}: Surveille les performances de l'application, comme le temps de chargement et les requêtes réseau.
  \item \textcolor{gray}{firebase\_remote\_config}: Permet de modifier le comportement et l'apparence de l'application sans mise à jour.
  \item \textcolor{gray}{firebase\_storage}: Stocke et récupère des fichiers (images, vidéos, etc.) dans le cloud.
  \item \textcolor{gray}{firebase\_vertexai}: Fournit des outils pour intégrer des fonctionnalités d'IA générative dans l'application (anciennement firebase\_ai).
\end{itemize}
  

\subsection{Usage de firestore:CRUD}

Comme presenter dans le chapitre expo react firebase ,firestore est un product de firebase.

\begin{enumerate}
  \item \textbf{Connecter si ce n est pas fait }
\end{enumerate}

\begin{jscode}
firebase login
\end{jscode}

\begin{enumerate}
  \item[2.] \textbf{Ajouter le plugin firestore }
\end{enumerate}

\begin{jscode}
flutter pub add cloud_firestore
\end{jscode}


\begin{enumerate}
  \item[2.] \textbf{Exécutez }
\end{enumerate}

\begin{jscode}
flutterfire configure
\end{jscode}


\begin{enumerate}
  \item[3.] \textbf{Récréez votre build }
\end{enumerate}

\begin{jscode}
flutter run
\end{jscode}

Importer dans votre fichier dart
\begin{jscode}
import 'package:cloud_firestore/cloud_firestore.dart';
\end{jscode}


\begin{jscode}
FirebaseFirestore firestore = FirebaseFirestore.instance;

Future<void> createUser(String name, int age) async {
  try {
    await firestore.collection('users').add({
      'name': name,
      'age': age,
      'createdAt': FieldValue.serverTimestamp(),
    });
    print('Utilisateur cree avec succes');
  } catch (e) {
    print('Erreur lors de la creation : $e');
  }
}
\end{jscode}


% Read operation
\begin{enumerate}
  \item[5.] \textbf{Lire les utilisateurs}
\end{enumerate}

\begin{jscode}
Future<void> getUser(String userId) async {
  try {
    DocumentSnapshot doc = await firestore.collection('users').doc(userId).get();
    if (doc.exists) {
      print('Donnees utilisateur : ${doc.data()}');
    } else {
      print('Aucun utilisateur trouve');
    }
  } catch (e) {
    print('Erreur lors de la lecture : $e');
  }
}

Future<void> getAllUsers() async {
  try {
    QuerySnapshot querySnapshot = await firestore.collection('users').get();
    for (var doc in querySnapshot.docs) {
      print('Utilisateur : ${doc.data()}');
    }
  } catch (e) {
    print('Erreur lors de la recuperation : $e');
  }
}
\end{jscode}

% Update operation
\begin{enumerate}
  \item[6.] \textbf{Mettre a jour un utilisateur}
\end{enumerate}

\begin{jscode}
Future<void> updateUser(String userId, String newName, int newAge) async {
  try {
    await firestore.collection('users').doc(userId).update({
      'name': newName,
      'age': newAge,
      'updatedAt': FieldValue.serverTimestamp(),
    });
    print('Utilisateur mis a jour avec succes');
  } catch (e) {
    print('Erreur lors de la mise a jour : $e');
  }
}
\end{jscode}

% Delete operation
\begin{enumerate}
  \item[7.] \textbf{Supprimer un utilisateur}
\end{enumerate}

\begin{jscode}
Future<void> deleteUser(String userId) async {
  try {
    await firestore.collection('users').doc(userId).delete();
    print('Utilisateur supprime avec succes');
  } catch (e) {
    print('Erreur lors de la suppression : $e');
  }
}
\end{jscode}

\textbf{Rétrouver le site officiel firebase flutter} :\href{https://firebase.flutter.dev/docs/overview}{https://firebase.flutter.dev/}


\section{Backend avec Supabase}
Tout comme il est possible d utiliser expo framework avec Supabase , vous avez aussi la possibilité de le faire avec flutter si ous etes amoureux de postgresql .
Suivez la doc officiel: \href{https://supabase.com/docs/guides/getting-started/quickstarts/flutter}{flutter supabase}

\section{Fonctionnalités natives:Plateform channels et packages}
\subsection{Plateform channels}

Les \textbf{Platform Channels} en Flutter sont un mécanisme essentiel permettant une communication bidirectionnelle entre le code Dart (utilisé dans Flutter) et le code natif des plateformes sous-jacentes, comme Android (Kotlin/Java) ou iOS (Swift/Objective-C).
Ils servent de pont pour accéder à des fonctionnalités spécifiques à une plateforme qui ne sont pas directement disponibles dans le framework Flutter. Voici une explication détaillée en français

\subsubsection{Qu'est-ce que les Platform Channels ?}
Les Platform Channels sont des canaux de communication qui permettent d'échanger des messages de manière asynchrone entre l'application Flutter (écrite en Dart) et le code natif de la plateforme hôte (Android ou iOS).
Ils utilisent un système de messagerie basé sur des canaux nommés pour invoquer des méthodes spécifiques et transmettre des données dans les deux sens. \newline

Flutter propose trois types principaux de Platform Channels, chacun ayant un usage spécifique :

\begin{enumerate}
  \item \textcolor{gray}{MethodChannel}:Utilisé pour appeler des méthodes spécifiques sur la plateforme native et recevoir une réponse unique (par exemple, obtenir le niveau de batterie ou accéder à une API native).
  \item \textcolor{gray}{EventChannel}:Conçu pour transmettre un flux continu de données depuis la plateforme native vers Flutter, comme des mises à jour en temps réel (par exemple, données de capteurs ou notifications).
  \item \textcolor{gray}{BasicMessageChannel}:Permet une communication bidirectionnelle pour des messages simples sans attendre de réponse structurée, utile pour des échanges de données brutes
\end{enumerate}

\subsubsection{À quoi servent les Platform Channels ?}
Les Platform Channels sont utilisés lorsque Flutter ne propose pas de solution native pour une fonctionnalité spécifique ou lorsque vous avez besoin d'intégrer des bibliothèques ou APIs natives.

\begin{enumerate}
  \item \textbf{Accès aux fonctionnalités spécifiques à la plateforme} 
  \begin{itemize}
    \item Certaines fonctionnalités, comme l'accès à la caméra, au GPS, aux capteurs (gyroscope, accéléromètre), ou à l'authentification biométrique, nécessitent des appels aux APIs natives d'Android ou iOS.
    \item Les Platform Channels permettent d'exécuter du code natif pour accéder à ces fonctionnalités et de renvoyer les résultats à Flutter.
  \end{itemize}
  \item \textbf{Intégration avec des SDK tiers}
  \begin{itemize}
    \item Si vous devez utiliser un SDK spécifique (par exemple, un SDK de paiement ou d'analyse) qui n'a pas de plugin Flutter, vous pouvez utiliser les Platform Channels pour appeler les méthodes du SDK depuis le code natif.
  \end{itemize}
  \item \textbf{Amélioration des performances}
  \begin{itemize}
    \item Pour des tâches nécessitant des performances élevées ou des optimisations spécifiques à la plateforme, le code natif peut être plus efficace. Les Platform Channels permettent d'exécuter ce code tout en restant intégré à l'application Flutter.
  \end{itemize}
  \item \textbf{Communication en temps réel}
  \begin{itemize}
    \item Avec l'EventChannel, vous pouvez recevoir des flux de données continus, comme des mises à jour de localisation ou des notifications push, directement dans votre application Flutter.
  \end{itemize}
  \item \textbf{Personnalisation avancée}
  \begin{itemize}
    \item Les Platform Channels permettent d'implémenter des comportements ou des interfaces spécifiques à une plateforme (par exemple, des composants d'interface native comme une vue native intégrée dans Flutter).
  \end{itemize}
\end{enumerate}


\vspace{0.5cm}

\subsubsection{Comment fonctionnent-ils ?}

Les Platform Channels reposent sur un système de messagerie asynchrone. Voici les étapes principales

\vspace{0.5cm}

\begin{enumerate}
  \item \textbf{Définition du canal}
  \begin{itemize}
    \item Un canal est créé avec un nom unique (par exemple, com.exemple/moncanal) dans le code Dart et dans le code natif. Ce nom doit être identique des deux côtés pour établir la connexion.
  \end{itemize}
  \item \textbf{Envoi de messages depuis Flutter}
   \begin{itemize}
    \item Dans le code Dart, vous utilisez un \textcolor{gray}{MethodChannel} pour invoquer une méthode spécifique (par exemple, \textcolor{gray}{invokeMethod('getBatteryLevel')}). Ce message est envoyé à la plateforme native.
  \end{itemize}
  \item  \textbf{Traitement dans le code natif}
  \begin{itemize}
    \item Sur la plateforme native (Android ou iOS), un gestionnaire de canal (\textcolor{gray}{MethodCallHandler} pour Android,\textcolor{gray}{FlutterMethodChannel} pour iOS) intercepte l'appel, exécute la logique correspondante (par exemple, appeler une API native), et renvoie une réponse (succès, erreur, ou données) à Flutter.
  \end{itemize}
  \item  \textbf{Réception de la réponse dans Flutter}
  \begin{itemize}
    \item La réponse est reçue dans le code Dart via une promesse \textcolor{gray}{(Future)} ou un flux  \textcolor{gray}{(Stream)}  pour les EventChannel.
  \end{itemize}
\end{enumerate}


\section*{Exemple simple : Obtenir le niveau de batterie}

\subsubsection{Code Dart (Flutter) :}
\begin{jscode}
import 'package:flutter/services.dart';

class BatteryLevel {
  static const MethodChannel _channel = MethodChannel('com.exemple/battery');

  static Future<String> getBatteryLevel() async {
    try {
      final int batteryLevel = await _channel.invokeMethod('getBatteryLevel');
      return 'Niveau de batterie : $batteryLevel%';
    } catch (e) {
      return 'Erreur : $e';
    }
  }
}
\end{jscode}


\subsubsection{Code Kotlin (Android)}
\begin{jscode}
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import android.content.Context
import android.os.BatteryManager

class MainActivity : FlutterActivity() {
    private val CHANNEL = "com.exemple/battery"

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)
        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
            if (call.method == "getBatteryLevel") {
                val batteryLevel = getBatteryLevel()
                if (batteryLevel != -1) {
                    result.success(batteryLevel)
                } else {
                    result.error("UNAVAILABLE", "Niveau de batterie non disponible.", null)
                }
            } else {
                result.notImplemented()
            }
        }
    }

    private fun getBatteryLevel(): Int {
        val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager
        return batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
    }
}
\end{jscode}


\subsection{Code Swift (iOS)}
\begin{jscode}
import Flutter
import UIKit

@UIApplicationMain
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    let controller = window?.rootViewController as! FlutterViewController
    let batteryChannel = FlutterMethodChannel(name: "com.exemple/battery", binaryMessenger: controller.binaryMessenger)

    batteryChannel.setMethodCallHandler { (call: FlutterMethodCall, result: @escaping FlutterResult) in
      if call.method == "getBatteryLevel" {
        let batteryLevel = self.getBatteryLevel()
        if batteryLevel == -1 {
          result(FlutterError(code: "UNAVAILABLE", message: "Niveau de batterie non disponible.", details: nil))
        } else {
          result(batteryLevel)
        }
      } else {
        result(FlutterMethodNotImplemented)
      }
    }

    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }

  private func getBatteryLevel() -> Int {
    UIDevice.current.isBatteryMonitoringEnabled = true
    if UIDevice.current.batteryState == .unknown {
      return -1
    } else {
      return Int(UIDevice.current.batteryLevel * 100)
    }
  }
}
\end{jscode}

\vspace{0.25cm}

\subsubsection{Avantages des Platform Channels}

\begin{itemize}
  \item \textbf{Flexibilité} : Permet d'accéder à toutes les fonctionnalités natives, même celles non prises en charge par les plugins Flutter existants, comme les APIs spécifiques à une plateforme ou les SDK tiers propriétaires.
  \item \textbf{Sécurité} : La communication s'effectue dans le même processus d'application, garantissant une intégration sécurisée sans interférence extérieure.
  \item \textbf{Performance} : Les appels asynchrones évitent de bloquer l'interface utilisateur, assurant une expérience fluide même pour des opérations complexes.
  \item \textbf{Sérialisation automatique} : Les données (booléens, chaînes, listes, etc.) sont automatiquement sérialisées et désérialisées via un codec standard, simplifiant le transfert entre Dart et le code natif.
  \item \textbf{Personnalisation} : Permet d'implémenter des comportements ou interfaces spécifiques à une plateforme, comme des vues natives intégrées ou des fonctionnalités hardware avancées.
  \item \textbf{Support des flux de données} : Grâce à l'EventChannel, il est possible de recevoir des mises à jour en temps réel, comme des données de capteurs ou des notifications.
  \item \textbf{Compatibilité multiplateforme} : Un seul canal peut gérer les implémentations Android (Kotlin/Java) et iOS (Swift/Objective-C), facilitant le développement multiplateforme.
\end{itemize}


\subsubsection{Limites des Platform Channels}

\begin{itemize}
  \item \textbf{Complexité accrue} : Nécessite des connaissances en développement natif (Kotlin/Java pour Android, Swift/Objective-C pour iOS), ce qui peut compliquer le développement pour les équipes principalement habituées à Dart.
  \item \textbf{Exécution sur le thread principal} : Les appels des Platform Channels doivent être effectués sur le thread principal, ce qui peut poser des problèmes pour des opérations lourdes nécessitant un thread séparé.
  \item \textbf{Maintenance difficile} : L'ajout de code natif pour plusieurs plateformes augmente la complexité de maintenance, surtout pour des applications multiplateformes de grande échelle.
  \item \textbf{Risques d'erreurs} : La gestion manuelle des appels natifs peut introduire des erreurs, comme des problèmes de sérialisation ou des incompatibilités entre plateformes.
  \item \textbf{Dépendance aux plateformes} : L'utilisation de Platform Channels peut réduire la portabilité du code, car il devient spécifique à Android ou iOS, contrairement à l'approche purement Flutter.
  \item \textbf{Temps de développement} : Implémenter et tester des Platform Channels prend plus de temps que d'utiliser des plugins existants, ce qui peut ralentir le développement.
\end{itemize}

\subsubsection{Quand utiliser les Platform Channels ?}

\begin{itemize}
  \item \textbf{Accès à des APIs non couvertes} : Lorsque des fonctionnalités natives spécifiques (par exemple, APIs récentes d'Android ou iOS, comme Apple Intelligence ou capteurs avancés) ne sont pas disponibles via les plugins Flutter.
  \item \textbf{Intégration de SDK tiers} : Pour utiliser des SDK propriétaires ou non open-source (par exemple, SDK bancaires ou d'équipements IoT) qui n'ont pas de plugin Flutter.
  \item \textbf{Optimisations spécifiques} : Lorsqu'une performance optimale est requise via du code natif (par exemple, chiffrement hardware ou accès bas-niveau au système).
  \item \textbf{Vues natives personnalisées} : Pour intégrer des composants d'interface native (par exemple, MapKit sur iOS ou vues Android spécifiques) non pris en charge par les widgets Flutter.
  \item \textbf{Flux de données en temps réel} : Lors de l'utilisation d'EventChannel pour recevoir des données continues, comme des mises à jour de capteurs ou de localisation.
  \item \textbf{Fonctionnalités beta ou expérimentales} : Pour accéder à des APIs en version beta ou non encore intégrées dans les plugins communautaires.
\end{itemize}


\subsection{Packages vs plugins}
Tout comme dans les écosystèmes \textbf{React} et \textbf{React Native}, les packages sont devenus incontournables dans le développement \textbf{Flutter}. Souvent créés par la communauté, ils enrichissent considérablement les fonctionnalités de l'application.
En fluuter , certains packages et plugins permettent à l accès au fonctionnalités natives et donc vous excemptent du Plateform channels ,ils sont d ailleurs recommandés. Vous pouvez retrouver les meilleurs packages l équipe Google et communautaire sur \href{https://pub.dev/}{pub.dev}. \newline


\subsubsection{Différence entre packages et plugins}

\begin{itemize}
  \item \textbf{Package Dart} : Un répertoire contenant au minimum un fichier \texttt{pubspec.yaml}. Il peut inclure des dépendances, des bibliothèques Dart, des applications, des ressources, des tests, des images, des polices et des exemples. Les packages sont répertoriés sur \href{https://pub.dev}{pub.dev} et développés par Google ou la communauté.
  \item \textbf{Plugin} : Un type spécifique de package qui fournit des fonctionnalités natives pour une ou plusieurs plateformes (Android avec Kotlin/Java, iOS avec Swift/Objective-C, Web, macOS, Windows, Linux). Par exemple, un plugin peut permettre d'accéder à l'appareil photo ou à d'autres APIs natives.
  \item \textbf{Distinction clé} : Tous les plugins sont des packages, mais tous les packages ne sont pas des plugins. Les plugins incluent du code spécifique à la plateforme, contrairement aux packages purement Dart.
\end{itemize}

\subsubsection{Ajout d'une dépendance de package à une application}

\begin{enumerate}
  \item \textbf{Recherche de packages} : Consultez \href{https://pub.dev}{pub.dev} pour trouver des packages compatibles avec Flutter. Utilisez les filtres pour cibler des plateformes spécifiques (Android, iOS, Web, Linux, Windows, macOS) ou explorez les \textit{Favoris Flutter} sur \href{https://pub.dev/flutter/favorites}{pub.dev/flutter/favorites} pour des packages recommandés.
  \item \textbf{Ajout avec \texttt{flutter pub add}} :
    \begin{itemize}
      \item Exécutez \texttt{flutter pub add nom\_du\_package} (par exemple, \texttt{flutter pub add css\_colors}) dans le répertoire du projet pour ajouter automatiquement la dépendance au fichier \texttt{pubspec.yaml}.
      \item Ajoutez une instruction \texttt{import} dans le code Dart (par exemple, \texttt{import 'package:css\_colors/css\_colors.dart';}).
      \item Redémarrez l'application si elle contient du code spécifique à la plateforme pour éviter des erreurs comme \texttt{MissingPluginException}.
    \end{itemize}
  \item \textbf{Ajout manuel} :
    \begin{itemize}
  \item Ouvrez le fichier \texttt{pubspec.yaml} et ajoutez la dépendance sous \texttt{dependencies} (par exemple, \texttt{css\_colors: \^\ 1.0.0}).
  \item Exécutez \texttt{flutter pub get} dans le terminal, ou cliquez sur ``Obtenir les packages'' dans VS Code ou Android Studio.
  \item Importez le package dans le code Dart et redémarrez l'application si nécessaire.
    \end{itemize}
\end{enumerate}

\subsubsection{Suppression d'une dépendance de package}

\begin{itemize}
  \item \textbf{Utilisation de \texttt{flutter pub remove}} : Ascending: \item \textbf{Utilisation de \texttt{flutter pub remove}} : Exécutez \texttt{flutter pub remove nom\_du\_package} (par exemple, \texttt{flutter pub remove css\_colors}) dans le répertoire du projet pour supprimer la dépendance du fichier \texttt{pubspec.yaml}.
  \item \textbf{Manuellement} : Supprimez la ligne correspondante dans \texttt{pubspec.yaml} sous \texttt{dependencies} et exécutez \texttt{flutter pub get} pour mettre à jour.
  \item \textbf{Note} : Supprimez également les instructions \texttt{import} associées dans le code Dart pour éviter des erreurs.
\end{itemize}

\subsubsection{Gestion des dépendances et des versions des packages}

\begin{itemize}
  \item \textbf{Spécification des versions} :
    \begin{itemize}
      \item Utilisez des contraintes de plage pour éviter les conflits (par exemple, \texttt{url\_launcher: '>=5.4.0 <6.0.0'} pour accepter toute version entre 5.4.0 inclus et 6.0.0 exclus).
      \item Préférez la syntaxe du caret (\texttt{\^\ 5.4.0}) pour accepter toutes les versions jusqu'à la prochaine version majeure (par exemple, \texttt{>=5.4.0 <6.0.0}).
    \end{itemize}
  \item \textbf{Résolution des conflits} :
    \begin{itemize}
      \item Si deux packages dépendent de versions différentes d'un même package (par exemple, \texttt{url\_launcher}), utilisez \texttt{dependency\_overrides} dans \texttt{pubspec.yaml} pour forcer une version spécifique (par exemple, \texttt{dependency\_overrides: url\_launcher: '5.4.0'}).
      \item Pour les dépendances Android comme \texttt{guava}, ajoutez une règle dans \texttt{android/build.gradle} (par exemple, \texttt{force 'com.google.guava:guava:28.0-android'}). Notez que CocoaPods (iOS) ne supporte pas les remplacements de dépendances.
    \end{itemize}
  \item \textbf{Dépendances non publiées} :
    \begin{itemize}
      \item \textbf{Dépendance par chemin} : Spécifiez un chemin local (par exemple, \texttt{path: ../packageA/}) pour des packages privés.
      \item \textbf{Dépendance Git} : Utilisez un dépôt Git public (par exemple, \texttt{git: url: \href{https://github.com/flutter/packageA.git}{https://github.com/flutter/packageA.git}}) ou privé via SSH (par exemple, \texttt{git: url: git@github.com:flutter/packageA.git}), avec un chemin optionnel (\texttt{path: packages/packageA}) ou une référence spécifique (\texttt{ref: branche\_ou\_commit}).
    \end{itemize}
\end{itemize}

\subsubsection{Mise à jour des dépendances des packages}

\begin{itemize}
  \item \textbf{Verrouillage des versions} : Lors de l exécution de \texttt{flutter pub get}, Flutter enregistre la version exacte dans \texttt{pubspec.lock} pour garantir la cohérence entre les développeurs.
  \item \textbf{Mise à jour} : Exécutez \texttt{flutter pub upgrade} pour récupérer la version la plus récente autorisée par les contraintes de \texttt{pubspec.yaml}. Cette commande est différente de \texttt{flutter upgrade} (pour Flutter lui-même).
  \item \textbf{Note} : Vérifiez les notes de version sur \href{https://pub.dev}{pub.dev} (par exemple, \href{https://pub.dev/packages/url_launcher/versions}{url\_launcher versions}) pour éviter des ruptures de compatibilité lors des mises à jour.
\end{itemize}

Voici une liste non exhaustive de packages populaires et leur utilité :\newline

\begin{itemize}
    \item \textbf{toastification} : Sert à afficher des notifications temporaires et non intrusives, similaires à des "toasts", pour informer l'utilisateur d'un événement (succès, erreur, etc.).
    \item \textbf{bloc} : Sert à implémenter le design pattern \textbf{Business Logic Component}. Il aide à séparer la logique métier de l'interface utilisateur, rendant le code plus facile à tester et à maintenir.
    \item \textbf{provider} : Sert à gérer l'état d'une application de manière simple et performante. C'est un des packages de gestion d'état les plus populaires, basé sur la notion d'héritage d'objets (InheritedWidget).
    \item \textbf{get\_it} : Sert à implémenter un "service locator" (localisateur de services). Il permet d'accéder facilement à des objets (services) depuis n'importe où dans l'application sans avoir à les passer manuellement à travers les widgets.
    \item \textbf{dio} : Sert de client HTTP puissant pour effectuer des requêtes réseau (GET, POST, etc.) vers des API REST. Il offre des fonctionnalités avancées comme les intercepteurs, la gestion des requêtes simultanées et les téléchargements de fichiers.
    \item \textbf{shared\_preferences} : Sert à stocker de petites quantités de données de type clé-valeur de manière simple sur l'appareil. Idéal pour les préférences utilisateur, les paramètres ou l'état de l'authentification.
    \item \textbf{flutter\_svg} : Sert à afficher des images au format SVG (Scalable Vector Graphics), qui peuvent être redimensionnées sans perte de qualité.
    \item \textbf{url\_launcher} : Sert à ouvrir des URL externes dans le navigateur web par défaut du système d'exploitation, ou à lancer des applications spécifiques comme des clients de messagerie ou de téléphone.
    \item \textbf{path\_provider} : Sert à obtenir les chemins d'accès au système de fichiers de l'appareil pour stocker des fichiers de manière temporaire ou permanente.
\end{itemize}


\section*{Exemple d usage pour la fonctionnalité native camera via le package}


\subsubsection{Utilisation du package camera avec Flutter}

Le package \texttt{camera} permet d'accéder aux fonctionnalités de la caméra des appareils Android et iOS dans une application Flutter. Il offre des outils pour afficher un aperçu en temps réel, capturer des photos et enregistrer des vidéos. Voici les étapes pour implémenter une fonctionnalité de prise de photo avec un bouton minimal.

\subsubsection{Étapes de configuration}

\begin{enumerate}
  \item \textbf{Ajout des dépendances} :
    \begin{itemize}
      \item Ajoutez les packages \texttt{camera}, \texttt{path\_provider} et \texttt{path} dans \texttt{pubspec.yaml} :
\begin{verbatim}
dependencies:
  camera: ^0.10.0
  path_provider: ^2.0.9
  path: ^1.8.0
\end{verbatim}
      \item Exécutez \texttt{flutter pub get} pour installer les dépendances.
    \end{itemize}
  \item \textbf{Configuration des permissions} :
    \begin{itemize}
      \item Pour Android, mettez à jour \texttt{android/app/build.gradle} pour définir \texttt{minSdkVersion 21} ou supérieur.
      \item Pour iOS, ajoutez les permissions dans \texttt{ios/Runner/Info.plist} :
\begin{verbatim}
<key>NSCameraUsageDescription</key>
<string>Application needs camera access to take photos.</string>
<key>NSMicrophoneUsageDescription</key>
<string>Application needs microphone access for video recording.</string>
\end{verbatim}
    \end{itemize}
  \item \textbf{Initialisation de la caméra} :
    \begin{itemize}
      \item Récupérez la liste des caméras disponibles avec \texttt{availableCameras()}.
      \item Créez un \texttt{CameraController} pour contrôler une caméra spécifique (par exemple, la caméra arrière).
      \item Initialisez le contrôleur dans \texttt{initState} et libérez-le dans \texttt{dispose}.
    \end{itemize}
  \item \textbf{Affichage de l'aperçu} :
    \begin{itemize}
      \item Utilisez le widget \texttt{CameraPreview} pour afficher le flux de la caméra.
      \item Attendez l'initialisation du contrôleur avec \texttt{FutureBuilder} pour gérer le chargement.
    \end{itemize}
  \item \textbf{Prise de photo} :
    \begin{itemize}
      \item Utilisez la méthode \texttt{takePicture()} du \texttt{CameraController} pour capturer une photo, qui retourne un \texttt{XFile}.
      \item Affichez l'image capturée avec \texttt{Image.file}.
    \end{itemize}
\end{enumerate}

\subsubsection{Exemple de code minimal}

Voici un exemple de code minimal pour une application Flutter avec un bouton pour prendre une photo, affichant l'aperçu de la caméra et l'image capturée.

\begin{jscode}
import 'dart:io';
import 'package:camera/camera.dart';
import 'package:flutter/material.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  final cameras = await availableCameras();
  final firstCamera = cameras.first;
  runApp(MyApp(camera: firstCamera));
}

class MyApp extends StatelessWidget {
  final CameraDescription camera;
  const MyApp({super.key, required this.camera});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      home: TakePictureScreen(camera: camera),
    );
  }
}

class TakePictureScreen extends StatefulWidget {
  final CameraDescription camera;
  const TakePictureScreen({super.key, required this.camera});

  @override
  TakePictureScreenState createState() => TakePictureScreenState();
}

class TakePictureScreenState extends State<TakePictureScreen> {
  late CameraController _controller;
  late Future<void> _initializeControllerFuture;
  String? _imagePath;

  @override
  void initState() {
    super.initState();
    _controller = CameraController(widget.camera, ResolutionPreset.medium);
    _initializeControllerFuture = _controller.initialize();
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Prendre une photo')),
      body: Column(
        children: [
          FutureBuilder<void>(
            future: _initializeControllerFuture,
            builder: (context, snapshot) {
              if (snapshot.connectionState == ConnectionState.done) {
                return CameraPreview(_controller);
              } else {
                return const Center(child: CircularProgressIndicator());
              }
            },
          ),
          if (_imagePath != null)
            Container(
              height: 200,
              child: Image.file(File(_imagePath!)),
            ),
        ],
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          try {
            await _initializeControllerFuture;
            final image = await _controller.takePicture();
            setState(() {
              _imagePath = image.path;
            });
          } catch (e) {
            print(e);
          }
        },
        child: const Icon(Icons.camera_alt),
      ),
    );
  }
}
\end{jscode}

\subsubsection{Bonnes pratiques}

\begin{itemize}
  \item \textbf{Gestion des erreurs} : Encapsulez \texttt{takePicture()} dans un bloc \texttt{try/catch} pour gérer les exceptions, comme les erreurs de permissions.
  \item \textbf{Performance} : Utilisez \texttt{ResolutionPreset.medium} pour un équilibre entre qualité et performance, sauf si une haute résolution est nécessaire.
  \item \textbf{Lifecycle} : Implémentez \texttt{WidgetsBindingObserver} pour gérer les états du cycle de vie de l'application (par exemple, libérer la caméra quand l'application est en arrière-plan).
  \item \textbf{Documentation} : Consultez la documentation officielle sur \href{https://pub.dev/packages/camera}{pub.dev} pour des fonctionnalités avancées comme l'enregistrement vidéo ou le changement de caméra.
\end{itemize}


\section{Buid et Deploiement en flutter}


\end{document}
